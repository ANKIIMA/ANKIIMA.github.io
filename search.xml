<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图形学知识合集</title>
    <url>/2023/07/31/CGCollection/</url>
    <content><![CDATA[<p>经过大约一年时间的学习，深感图形学内容的丰富，加上接触了游戏引擎，从底层API到上层如unity shader都有了一定认识，但是由于之前没有系统整理，现在决定从头梳理一遍知识目录，作为日后参考使用，保持更新或修改。</p>
<span id="more"></span>
<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><p>基础部分以了解底层原理为主，具体实现参考TinyRenderer，该项目用C++实现了从模型读取到输出渲染结果的软光栅化渲染管线，对理解原理很有帮助。</p>
<h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><p>主要是一些常用的计算方法，向量矩阵加减乘之类的就不说了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内容</th>
<th style="text-align:left">应用</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>三角形重心坐标</td>
<td style="text-align:left">软光栅化，光线追踪，判断点是否在三角形内部，三角形内部坐标插值</td>
<td style="text-align:left"><a href="https://zhuanlan.zhihu.com/p/58199366">https://zhuanlan.zhihu.com/p/58199366</a></td>
</tr>
<tr>
<td>傅里叶变换</td>
<td style="text-align:left">反走样</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>线性变换/仿射变换/齐次坐标</td>
<td style="text-align:left">MVP变换</td>
<td style="text-align:left">fundamentals of computer graphics 第六章</td>
</tr>
<tr>
<td>SVD奇异值分解</td>
<td style="text-align:left">将线性变换矩阵分解为平移、缩放、旋转的组合矩阵形式</td>
<td style="text-align:left">fundamentals of computer graphics 第六章</td>
</tr>
<tr>
<td>Peath分解</td>
<td style="text-align:left">将旋转分解为错切的组合形式</td>
<td style="text-align:left">fundamentals of computer graphics 第六章</td>
</tr>
<tr>
<td>TBN矩阵</td>
<td style="text-align:left">法线纹理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>法向量平移</td>
<td style="text-align:left">MVP变换</td>
</tr>
</tbody>
</table>
</div>
<h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th style="text-align:left">简述</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>概念渲染管线</td>
<td style="text-align:left">出自实时渲染第四版，将渲染管线抽象总结为概念上的渲染管线，可以称为大多数管线的做法</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader1/">https://ankiima.github.io/2023/04/11/uni-shader1/</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>在现代管线中只需要绘制三角形就可以了，直线的绘制则是最基本的知识，都需要熟练掌握，最好能手写。图元的绘制也被称为光栅化。</p>
<h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><p>Bresenham算法：迭代绘制，不计算浮点数提高了运行效率。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常见形式</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>推导决策量：$P_k$</td>
<td style="text-align:left"><a href="https://blog.csdn.net/qq_41883085/article/details/102706471">https://blog.csdn.net/qq_41883085/article/details/102706471</a></td>
</tr>
<tr>
<td>直接计算(不使用浮点数)</td>
<td style="text-align:left"><a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm">https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h3><p>主要是新旧两种做法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>(旧)扫描线法</td>
<td style="text-align:left">三角形分上下两部分，根据三角形边界分别填充它们</td>
<td style="text-align:left"><a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling">https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling</a></td>
</tr>
<tr>
<td>(新)像素迭代法</td>
<td style="text-align:left">确定包围三角形的正方形，判断每个像素是否在三角形内进行绘制</td>
<td style="text-align:left"><a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling">https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法/问题</th>
<th style="text-align:left">简述</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>画家算法</td>
<td style="text-align:left">排序所有面，先绘制在后面的，然后绘制在前面的面以遮挡后面的面，开销大，且不保证得到完全正确的顺序</td>
<td style="text-align:left"><a href="https://zh.wikipedia.org/wiki/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95">https://zh.wikipedia.org/wiki/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95</a></td>
</tr>
<tr>
<td>Z-buffer</td>
<td style="text-align:left">用缓存区存储深度信息，绘制在前面，也就是深度值排在前面的面，需要对单个像素进行插值</td>
<td style="text-align:left"><a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-3:-Hidden-faces-removal-(z-buffer">https://github.com/ssloy/tinyrenderer/wiki/Lesson-3:-Hidden-faces-removal-(z-buffer</a>)</td>
</tr>
<tr>
<td>z-fighting</td>
<td style="text-align:left">z-buffer深度值不精确比较带来的像素抖动</td>
<td style="text-align:left"><a href="https://zhuanlan.zhihu.com/p/78769570">https://zhuanlan.zhihu.com/p/78769570</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="背面剔除"><a href="#背面剔除" class="headerlink" title="背面剔除"></a>背面剔除</h3><p>下面分类的方法没有任何依据，我只是想说明可以用不同方法定义背面。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">简述</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">根据光照方向判断</td>
<td style="text-align:left">法线和光线方向夹角小于90度认为是正面，否则剔除</td>
<td style="text-align:left"><a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling">https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling</a></td>
</tr>
<tr>
<td style="text-align:center">顺/逆时针判断</td>
<td style="text-align:left">根据面的前后两面中顶点的顺/逆时针确定前面和背面，如OpenGL</td>
<td style="text-align:left"><a href="https://blog.csdn.net/wangdingqiaoit/article/details/52267314">https://blog.csdn.net/wangdingqiaoit/article/details/52267314</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><p>由于像素是离散的，我们绘制的时候如果像素太少，导致采样的频率不高，就会出现信号走样的问题，直观来说就是锯齿。为了在不改变硬件条件下修改这些锯齿表现，提出一系列方法改进。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">简介</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSAA(超采样)</td>
<td style="text-align:left">将一个片元划分为多个进行光栅化，每个片元平均自身划分采样的结果，从而增大采样频率</td>
<td></td>
</tr>
<tr>
<td>FXAA</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td>TAA</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h2><h2 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h2><h3 id="着色方式"><a href="#着色方式" class="headerlink" title="着色方式"></a>着色方式</h3><p>模型文件一般会给出每个面的法向量，我们着色要对每个像素确定一个光照的值，所以根据着色计算频率可以分为不同的着色方式。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方式</th>
<th style="text-align:left">简述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Flat Shading</td>
<td style="text-align:left">每个面计算一次，作为面内所有像素的着色，是逐个面的着色</td>
</tr>
<tr>
<td>Gouraud Shading</td>
<td style="text-align:left">每个顶点计算一次，顶点法向量通过对顶点连接的面计算得到(可以是简单平均)，面内像素对三个顶点的颜色线性插值得到像素的颜色，实际上是逐顶点的着色</td>
</tr>
<tr>
<td>Phong Shading</td>
<td style="text-align:left">每个像素计算一次，像素对应的法向量由顶点的法向量插值得到，逐像素的着色</td>
</tr>
</tbody>
</table>
</div>
<h3 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>模型</th>
<th>简述</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>Phong</td>
<td>最经典的经验光照模型，不满足能量守恒，将物体表面的光分为Ambient，Diffuse，Specular三种分别计算后相加</td>
<td></td>
</tr>
<tr>
<td>Blinn-Phong</td>
<td>对Phong进行了一点改进，不在比较反射光和观察视角的夹角作为镜面光，而是计算观察视角和光照方向的半程向量，同法线比较作为镜面光</td>
<td></td>
</tr>
<tr>
<td>Cook-Torrance / PBR</td>
<td>PBR光照模型，定义了满足能量守恒的BRDF函数，计算光照到达物体之后被折射和被反射的部分</td>
<td><a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">https://learnopengl-cn.github.io/07%20PBR/01%20Theory/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><h4 id="软阴影"><a href="#软阴影" class="headerlink" title="软阴影"></a>软阴影</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>简述</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="硬阴影"><a href="#硬阴影" class="headerlink" title="硬阴影"></a>硬阴影</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>简述</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="纹理原理"><a href="#纹理原理" class="headerlink" title="纹理原理"></a>纹理原理</h2><h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><p>每个顶点拥有一个纹理坐标(u,v)，通过纹理坐标找到纹理图中的颜色，就可以作为顶点颜色。但光栅化的时候为了得到每个像素的颜色，自然不能逐像素地添加纹理坐标，一个三角形片元只有三个顶点的三个纹理坐标，通常有两种方法获得逐像素的颜色。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">简介</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>纹理坐标插值</td>
<td style="text-align:left">通过重心坐标对纹理坐标进行插值，得到逐像素的纹理坐标，再进行纹理映射，可以配合纹理图得到丰富的细节</td>
<td></td>
</tr>
<tr>
<td>顶点颜色插值</td>
<td style="text-align:left">对三个顶点的颜色进行插值，得到逐像素的平滑颜色，细节不足，但是足够平滑</td>
<td><a href="https://ankiima.github.io/2023/08/01/tinyRenderer2/#more">https://ankiima.github.io/2023/08/01/tinyRenderer2/#more</a></td>
</tr>
<tr>
<td>纹理放大</td>
<td style="text-align:left">由于纹理图片分辨率低，一个uv坐标放大到纹理分辨率后是非整数值，夹在几个像素点之间，需要对这几个像素点的颜色进行插值。</td>
<td></td>
</tr>
<tr>
<td>纹理缩小</td>
<td style="text-align:left">由于纹理图片分辨率过大，一个uv坐标放大到纹理分辨率后同时对应好几个像素点，而不是夹在几个点之间，如果只采用查询点的像素值会导致抖动，需要用Mipmap让范围查询代替点查询。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>二次贝塞尔曲线</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2022/09/07/games4/">https://ankiima.github.io/2022/09/07/games4/</a></td>
</tr>
<tr>
<td>分段贝塞尔曲线</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h3><h4 id="Subdivision"><a href="#Subdivision" class="headerlink" title="Subdivision"></a>Subdivision</h4><p>将曲面分成更多的面，提升模型的精度。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th style="text-align:left">简述</th>
<th style="text-align:left">文章</th>
</tr>
</thead>
<tbody>
<tr>
<td>Loop Subvision</td>
<td style="text-align:left">只能用于三角形的曲面细分方法</td>
<td style="text-align:left"><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/thesis-10.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/thesis-10.pdf</a></td>
</tr>
<tr>
<td>Catmull—Clark Subvision</td>
<td style="text-align:left">适应任意形状的曲面细分方法</td>
<td style="text-align:left"><a href="https://www.cs.jhu.edu/~cohen/Seminar/cc.pdf">https://www.cs.jhu.edu/~cohen/Seminar/cc.pdf</a></td>
</tr>
</tbody>
</table>
</div>
<h4 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h4><p>将曲面合并成更少的面，减少性能开销。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>简述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Edge Collapsing &amp; Quadric Error Metrics</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h4><p>将不规则分布的曲面规则化，不改变模型面数的情况下提升表现效果。</p>
<h2 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h2><p>不同于光栅化的着色方法，基本按照光学原理在场景中计算光线的弹射，模拟全局光照效果。解决了光栅化无法一次完成阴影计算，以及无法模拟全局光照的问题。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">简述</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>光线追踪技术合集</td>
<td style="text-align:left">关于光线追踪的技术论文合集</td>
<td style="text-align:left"><a href="https://github.com/LouiValley/RayTracing-Tech#industry-contributions">https://github.com/LouiValley/RayTracing-Tech#industry-contributions</a></td>
</tr>
<tr>
<td>加速结构</td>
<td style="text-align:left">加快光线追踪中光线求交的一种区域划分方法</td>
</tr>
</tbody>
</table>
</div>
<h2 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h2><p>光线追踪将光照模拟为折射和反射，折射后通过判断此时是否能达到光源，也就是是否产生镜面光作为收敛条件，忽略了漫反射的存在。路径追踪和光线追踪的方法类似，但是模拟了多条光线反射的情况，不只是一次光线追踪，所以能达到更好的效果。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><h2 id="Vulkan"><a href="#Vulkan" class="headerlink" title="Vulkan"></a>Vulkan</h2><h2 id="DirectX"><a href="#DirectX" class="headerlink" title="DirectX"></a>DirectX</h2><h1 id="Shader-Language"><a href="#Shader-Language" class="headerlink" title="Shader Language"></a>Shader Language</h1><h2 id="C-for-Graphics"><a href="#C-for-Graphics" class="headerlink" title="C for Graphics"></a>C for Graphics</h2><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><h2 id="HLSL"><a href="#HLSL" class="headerlink" title="HLSL"></a>HLSL</h2><h1 id="Unity-Shader"><a href="#Unity-Shader" class="headerlink" title="Unity Shader"></a>Unity Shader</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:left">简述</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>概念流水线</td>
<td style="text-align:left">渲染管线的抽象总结，分成应用、几何、光栅化三个阶段</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader1/">https://ankiima.github.io/2023/04/11/uni-shader1/</a></td>
</tr>
<tr>
<td>Shader</td>
<td style="text-align:left">渲染流水线中高度可编程的阶段</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader1/">https://ankiima.github.io/2023/04/11/uni-shader1/</a></td>
</tr>
<tr>
<td>渲染状态</td>
<td style="text-align:left">定义场景中的网格怎么渲染，绑定Shader，材质，光源等内容，例如混合，深度缓冲，背面裁剪等</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>Unity Shader</td>
<td style="text-align:left">既能同时编写顶点和片元着色器，又能设置渲染状态的高级编辑工具，采用ShaderLab语言编写</td>
<td style="text-align:left">《Unity Shader入门精要》 第一章</td>
</tr>
<tr>
<td>Unity Shader基本结构和语法</td>
<td style="text-align:left">一个Unity Shader文件使用Properties语义作为输入，包含多个SubShader，选择第一个能运行的SubShader。一个SubShader有多个Pass，程序会从上到下运行这些Pass。</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader2/">https://ankiima.github.io/2023/04/11/uni-shader2/</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:left">简述</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础Phong光照</td>
<td style="text-align:left">Phong光照以及Blinn-Phong光照的实现</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader3/">https://ankiima.github.io/2023/04/11/uni-shader3/</a></td>
</tr>
<tr>
<td>纹理</td>
<td style="text-align:left">实现颜色纹理、法线纹理、渐变纹理、遮罩纹理</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader3/">https://ankiima.github.io/2023/04/11/uni-shader3/</a> and<a href="https://ankiima.github.io/2023/04/11/uni-shader4/">https://ankiima.github.io/2023/04/11/uni-shader4/</a></td>
</tr>
<tr>
<td>透明与混合</td>
<td style="text-align:left">实现透明和带混合的透明效果</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader4/">https://ankiima.github.io/2023/04/11/uni-shader4/</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="高级纹理"><a href="#高级纹理" class="headerlink" title="高级纹理"></a>高级纹理</h3><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:left">简述</th>
<th style="text-align:left">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>立方体纹理</td>
<td style="text-align:left">创建和应用天空盒子CubeMap，实现对立方体纹理的采样</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader5/">https://ankiima.github.io/2023/04/11/uni-shader5/</a></td>
</tr>
<tr>
<td>渲染纹理</td>
<td style="text-align:left">将场景渲染到一张纹理中保存起来</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader5/">https://ankiima.github.io/2023/04/11/uni-shader5/</a></td>
</tr>
<tr>
<td>程序纹理</td>
<td style="text-align:left">使用脚本生成纹理</td>
<td style="text-align:left"><a href="https://ankiima.github.io/2023/04/11/uni-shader5/">https://ankiima.github.io/2023/04/11/uni-shader5/</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法复习（1）概述</title>
    <url>/2022/08/01/DA-0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本专题作为考研408复习笔记，以王道考研书为准复习，计划在本月内学习整理完所有知识点。题目只做选择题并记录错误，无习题讲解，以记录算法本身为主。<br><img src="/2022/08/01/DA-0/5.jpg" alt="场景"></p>
<hr>
<p>知识整理目前已经更新完成，相应的算法练习会整理成项目放到GitHub上。<br><span id="more"></span></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本章除了时间复杂度和空间复杂度以外不在考纲中，但是要重点掌握前者，并且了解一些基本概念。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>数据，是信息的载体，描述客观事物属性的数、字符并能被计算机处理的集合；</p>
<p>数据元素，数据的基本单位，可由若干数据项组成，数据项是构成数据元素的最小单位；</p>
<p>数据对象，具有相同性质的数据元素的集合，是数据的子集；</p>
<p>数据类型，定义为包括值的集合和在此集合上操作的总称{<em>Data，Operation</em>}，分为原子类型，结构类型和抽象数据类型；</p>
<p>数据结构，互相存在一种或多种特定关系的数据元素的集合，包括三要素。</p>
<blockquote>
<p>区分数据结构和抽象数据类型，数据结构是具体的，要求描述具体的实现方法在内的三要素，但是抽象数据类型是抽象的，不用说明实现方法，只需要定义值和对值的操作。<br>例如，栈就是抽象数据类型，可以用链式存储或者顺序存储处理数据，只表示逻辑结构；而循环队列则是具体的数据结构，用顺序表表示队列。</p>
<h4 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h4><p>逻辑结构指数据元素之间的逻辑关系，与数据的存储无关，独立于计算机。分为线性结构（线性表）和非线性结构（集合，树，图）。<br><img src="/2022/08/01/DA-0/1.jpg" alt="场景"><br>存储结构指数据在计算机中的表示，也称物理结构，包括数据元素的表示和关系的表示，是用计算机语言实现的逻辑结构，主要有顺序存储，链式存储，索引存储和散列存储。</p>
</blockquote>
<p>数据的计算指施加在数据上的运算，包括运算的定义和实现。定义针对逻辑结构，实现针对存储结构。 </p>
<h3 id="算法和算法评价"><a href="#算法和算法评价" class="headerlink" title="算法和算法评价"></a>算法和算法评价</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>算法，对特定问题求解步骤的描述，是指令的有限序列，其中每条指令表示一个或多个操作。<br>特点：有穷性，确定性，可行性，输入，输出。</p>
<p>优秀算法目标：正确性，可读性，健壮性，效率和低存储需求。</p>
<h4 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h4><p>时间复杂度，所有语句频度之和的数量级。记为：<br><img src="/2022/08/01/DA-0/2.jpg" alt="场景"><br>根据具体场景，分为最坏，最好，平均时间复杂度，遵循加法和乘法规则：<br><img src="/2022/08/01/DA-0/3.jpg" alt="场景"></p>
<p>空间复杂度，算法耗费的存储空间。记为：<br><img src="/2022/08/01/DA-0/4.jpg" alt="场景"><br>算法原地工作是算法所需要的辅助空间为常量<em>O(</em>1<em>)</em>。</p>
<p>以斐波那契数列求解的递归和非递归（循环）方式为例，分析时间复杂度。<br>递归求解，表示成二叉树形式，时间复杂度是对树高（规模n）的函数（结点数），为2的n次方减一；</p>
<blockquote>
<p>更正，这篇<a href="https://zhuanlan.zhihu.com/p/257214075">博客</a>指出应该是$O((1+\sqrt{5})/2)^n$</p>
</blockquote>
<p>循环求解，直接循环n次就得到结果，时间复杂度自然是<em>O(</em>n<em>)</em>。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法复习（2）线性表</title>
    <url>/2022/08/02/DA-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章介绍线性表，包括顺序表示和链式表示，要熟练掌握，要能写出最优性能。要注意动手编写代码。<br><img src="/2022/08/02/DA-1/2.jpg" alt="场景"><br><span id="more"></span></p>
<h1 id="定义和基本操作"><a href="#定义和基本操作" class="headerlink" title="定义和基本操作"></a>定义和基本操作</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>线性表是具有相同数据类型的<em>n</em>个数据元素的有限序列，<em>n</em>为表长，<em>n = 0</em>时表为空表。</p>
<p>线性表有唯一一个表头元素和唯一一个表尾元素，且除表头元素外，每个元素都有且仅有一个前驱；除表尾元素外，每个元素都有且仅有一个后继。</p>
<p>线性表是逻辑结构，表示元素间一对一的相对关系。顺序表和链表是存储结构。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InitList(&amp;L)</span><br><span class="line">Length(&amp;L)</span><br><span class="line">LocateElem(L,e)</span><br><span class="line">GetElem(L,i)</span><br><span class="line">ListInsert(&amp;L,i,e)</span><br><span class="line">ListDelete(&amp;L,i,e)</span><br><span class="line">PrintList(L)</span><br><span class="line">Empty(L)</span><br><span class="line">DestroyList(L)</span><br></pre></td></tr></table></figure>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>线性表的顺序存储就是线性表，用地址连续的存储单元依次存储数据元素，使逻辑上相邻的两个元素在物理位置上也相邻，位置称为位序，从1开始。</p>
<p>特点是逻辑顺序和物理顺序相同。是一种随机存取的存储结构，一般用数组表述，空间可以静态分配也可以动态分配。</p>
<blockquote>
<p>静态/动态分配空间指的是分配内存的大小是否能变化，本质上还是顺序存储。</p>
</blockquote>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//静态分配</span><br><span class="line">#define MaxSize 50</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    int length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//动态分配，一旦数据空间占满，就申请一块更大的空间替换现有空间。</span><br><span class="line">#define InitSize 50</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType *data;</span><br><span class="line">    int length;</span><br><span class="line">&#125;SqList;</span><br><span class="line">SqList L;</span><br><span class="line">L.data = (ElemType*)malloc(sizeof(ElemType) * InitSize);</span><br><span class="line">/*L.data = new ElemType[InitSize];*/</span><br></pre></td></tr></table></figure>
<h3 id="ListInsert"><a href="#ListInsert" class="headerlink" title="ListInsert"></a>ListInsert</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ListInsert(SqList &amp;L, int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    if(i&lt;1 || i&gt;L.Length+1);</span><br><span class="line">        return false;</span><br><span class="line">    if(L.length &gt; MaxSize)</span><br><span class="line">        return false;</span><br><span class="line">    for(int j = L.length; j&gt;=i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[j] = L.data[j-1];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i] = e;</span><br><span class="line">    L.Length++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度<em>n/2</em>;</p>
<h3 id="ListDelete"><a href="#ListDelete" class="headerlink" title="ListDelete"></a>ListDelete</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ListDelete(SqList &amp;L, int i, ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    if(i&lt;1 || i&gt;L.Length+1);</span><br><span class="line">        return false;</span><br><span class="line">    e = L.data[i-1];</span><br><span class="line">    for(int j = i; j &lt; L.length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[j-1] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度(<em>n-1</em>)<em>/2</em>。</p>
<h3 id="LocateElem"><a href="#LocateElem" class="headerlink" title="LocateElem"></a>LocateElem</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocateElem(SqList L, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0;i&lt;L.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L.data[i] == e)</span><br><span class="line">            return i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度(<em>n+1</em>)<em>/2</em>。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>线性表的链式存储叫单链表，通过一组任意的存储单元来存储线性表中的数据元素，在每个结点存放指向后继的指针。</p>
<p>由于物理地址不相邻，所以插入删除元素不用进行移动，但同时也不能随机存取了。</p>
<p>使用头指针来标识一个单链表，头指针为NULL则表空。还可以在第一个结点之前增加一个头结点，优点是：1）方便处理第一个元素，统一所有元素的增删操作；2）方便处理空表，因为头结点非空，只要判断指针域即可，统一空表和非空表的。</p>
<h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct LNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<h3 id="头插法建表"><a href="#头插法建表" class="headerlink" title="头插法建表"></a>头插法建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注意这里用了引用传递的特性，下面会将参数解释成一个指向该类型的const指针，且指针指向的链表可以被修改，避免值传递的复制行为。</span><br><span class="line">//一般对于基本数据类型用值传递就可以，但是对于复杂的结构体，对象，最好使用引用传递。</span><br><span class="line">LinkList List_HeadInsert(LinkList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    LNode *s; //临时结点</span><br><span class="line">    int x;    //临时值</span><br><span class="line">    L = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">    L-&gt;next = NULL;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    while(x != -1)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (LNode*)malloc(sizeof(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="尾插法建表"><a href="#尾插法建表" class="headerlink" title="尾插法建表"></a>尾插法建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkList List_TailInsert(LinkList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    L = (LinkList)malloc(sizeof(LNode));</span><br><span class="line">    LNode *s = L;</span><br><span class="line">    LNode *r = L;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    while(x != -1)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = NULL;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GetElem"><a href="#GetElem" class="headerlink" title="GetElem"></a>GetElem</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LNode* GetElem(LinkList L, int i)</span><br><span class="line">&#123;</span><br><span class="line">    int j = 1;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    if(i==0)</span><br><span class="line">    &#123;</span><br><span class="line">        return L;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&lt;1)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p != NULL &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LocateElem-1"><a href="#LocateElem-1" class="headerlink" title="LocateElem"></a>LocateElem</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LNode* LocateElem(LinkList L, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    while(p != NULL &amp;&amp; p-&gt;data != e)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ListInsert-1"><a href="#ListInsert-1" class="headerlink" title="ListInsert"></a>ListInsert</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ListInsert(LinkList L, int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    if(i&lt;1 || i&gt;Length(L)+1)</span><br><span class="line">        return false;</span><br><span class="line">    LNode* s = (LNode*)malloc(sizeof(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    LNode* p = GetElem(L,i-1);</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ListDelete-1"><a href="#ListDelete-1" class="headerlink" title="ListDelete"></a>ListDelete</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ListDelete(LinkList L, int i)</span><br><span class="line">&#123;</span><br><span class="line">    if(i &lt; 1 || i &gt; Length(L))</span><br><span class="line">        return false;</span><br><span class="line">    LNode* p = GetElem(L, i-1);</span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    free(q);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Length"><a href="#Length" class="headerlink" title="Length"></a>Length</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Length(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    int l = 0;</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        l++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>相比于单链表，双链表设置两个指针分别指向结点的前驱和后继，这样在寻找结点前驱的时候就不用从头开始遍历。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct DNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct DNode* prior, * next;</span><br><span class="line">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure></p>
<h3 id="ListInsert-2"><a href="#ListInsert-2" class="headerlink" title="ListInsert"></a>ListInsert</h3><p>在p指向的结点后插入元素。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ListInsert(DLinkList L, DNode* p, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    if(p == NULL)</span><br><span class="line">        return false;</span><br><span class="line">    DNode* s = (DNode*)malloc(sizeof(DNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    if(p-&gt;next == NULL)        </span><br><span class="line">    &#123;    </span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        s-&gt;prior = p;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ListDelete-2"><a href="#ListDelete-2" class="headerlink" title="ListDelete"></a>ListDelete</h3><p>删除p指向的结点的后继。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ListDelete(DLinkList L, DNode* p)</span><br><span class="line">&#123;</span><br><span class="line">    if(p == NULL || P-&gt;next == NULL)</span><br><span class="line">        return false;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;next-&gt;prior = p;</span><br><span class="line">    free(p-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><p>单链表的尾结点后继指针指向头结点。表中没有为NULL的指针，通过判断头结点后继是否是头结点判断表空。而且因为已经成环，所以不用判断表尾，在每个位置上的插入删除都是等价的。</p>
<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p>同理将双链表的尾结点后继指向头结点，头结点前驱指针也指向尾结点，就构成了循环双链表。</p>
<p>有时对单链表所做的操作通常在表头表尾，这时可以通过仅设置尾指针来优化，这样对头尾结点的操作都是统一的，且时间复杂度都是常数级。</p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>借助数组来表述线性表的链式存储结构，结点也有数据域data和指针域next，不过这里的指针是相对地址，称为游标。需要预先分配一块连续的内存空间。<br><img src="/2022/08/02/DA-1/1.jpg" alt="场景"><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    int next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure><br>以next为-1结束链表，通常使用在不支持指针的语言中。</p>
<h1 id="顺序表和链表比较"><a href="#顺序表和链表比较" class="headerlink" title="顺序表和链表比较"></a>顺序表和链表比较</h1><h2 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h2><p>顺序表可以顺序存取，也可以随机存取；链表只能顺序存取；</p>
<h2 id="逻辑结构和物理结构"><a href="#逻辑结构和物理结构" class="headerlink" title="逻辑结构和物理结构"></a>逻辑结构和物理结构</h2><p>顺序存储时逻辑地址相邻的元素物理地址也相邻，链式存储时逻辑地址相邻的元素物理地址不一定相邻。</p>
<h2 id="查找、插入、删除操作"><a href="#查找、插入、删除操作" class="headerlink" title="查找、插入、删除操作"></a>查找、插入、删除操作</h2><p>按值查找，顺序表和链表时间复杂度都为<em>O</em>(<em>n</em>)，顺序表如果有序可以用折半查找降低；<br>按序查找，顺序表随机访问<em>O</em>(<em>n</em>)，链表<em>O</em>(<em>n</em>)；<br>插入，删除操作，顺序表要移动一定表长的元素，而链表只需要修改对应指针；</p>
<h2 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h2><p>顺序存储，如果采用静态存储分配，不灵活，可能会溢出；采用动态分配，又需要移动大量元素，而且可能分配失败；<br>链式存储，只在需要的时候申请分配，比较灵活高效。</p>
<h2 id="存储结构的选择"><a href="#存储结构的选择" class="headerlink" title="存储结构的选择"></a>存储结构的选择</h2><p>存储上，如果线性表规模难以估计，用链式存储；<br>运算上，对于访问元素，按序访问使用顺序存储，按值访问区别不大；对于插入删除，表比较大的时候使用顺序存储很不方便，要移动的规模太大了，链表虽然要查找，但是操作更方便。<br>环境上，顺序表更容易实现，链表需要指针支持。</p>
<p>通常，稳定的线性表使用顺序存储，频繁插入删除使用链式存储。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法复习（3）栈、数组和队列</title>
    <url>/2022/08/03/DA-2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章介绍三种逻辑结构，栈和队列都是操作受限的线性表，而数组则是线性表的推广。栈和队列的操作以及特征是重点，而且要掌握特殊形式和常见应用方式。<br><img src="/2022/08/03/DA-2/14.jpg" alt="场景"><br><span id="more"></span></p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>首先栈是一种线性表，但只允许在一端进行插入和删除，即栈是插入删除等操作受限的线性表（逻辑结构）。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>栈顶，线性表允许进行插入删除的一端；<br>栈底，不允许进行插入和删除的一端；<br>空栈，不含任何元素的空表；<br>特点：后进先出（LIFO）；<br><img src="/2022/08/03/DA-2/1.jpg" alt="场景"></p>
<h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>采用顺序存储的栈称为顺序栈，用一组地址连续的存储单元存放元素，同时用一个指针保存当前栈顶元素的位置。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    int top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><br>栈空：top==-1；<br>栈满：top==MaxSize-1；<br>栈长：top+1；<br>栈顶元素：S.data[S.top];</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//栈初始化</span><br><span class="line">void InitStack(SqStack &amp;S)</span><br><span class="line">&#123;</span><br><span class="line">    S.top = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判栈空</span><br><span class="line">bool StackEmpty(SqStack &amp;S)</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top == -1)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">//判栈满操作相似</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//进栈</span><br><span class="line">bool Push(SqStack &amp;S, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top == MaxSize - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top] = x;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//出栈</span><br><span class="line">bool Pop(SqStack &amp;S, ElemType &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top == -1)</span><br><span class="line">        return false;</span><br><span class="line">    X = S.data[S.top];</span><br><span class="line">    S.top--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//读栈顶元素</span><br><span class="line">bool GetTop(SqStack S, ElemType &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top == -1)</span><br><span class="line">        return false;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p>将两个栈共享在同一个数组空间，栈底设置在两端，两个栈向中间延伸。<br><img src="/2022/08/03/DA-2/2.jpg" alt="场景"></p>
<h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>采用链式存储的栈叫链栈，优点是便于多个栈共享存储空间和提高效率，不存在栈满上溢的情况。</p>
<p>一般用单链表实现，头结点同样会有影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trpedef struct LinkNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct LinkNode *next;</span><br><span class="line">&#125;*LinkStack;</span><br></pre></td></tr></table></figure>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>也是一种操作受限的线性表，只允许在表的一端插入，另一端删除，特点是先进先出（FIFO）。</p>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>队头，允许删除的一端；<br>队尾，允许插入的一端；<br>空队列，不含任何元素的空表。</p>
<h2 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h2><h3 id="普通顺序存储"><a href="#普通顺序存储" class="headerlink" title="普通顺序存储"></a>普通顺序存储</h3><p>分配一块连续的存储单元存放队列元素，同时用队头指针指向队头元素，队尾指针指向队尾元素。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxSize 50</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    int front, rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化</span><br><span class="line">bool InitQueue(SqQueue &amp;Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q.front = 0;</span><br><span class="line">    Q.rear = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是由于顺序队列有一个缺点，在计算过程中会发生假上溢：<br><img src="/2022/08/03/DA-2/3.jpg" alt="场景"><br>此时判空可以通过队首队尾指针是否相同判断，但是要判满就不能实现了，所以要用循环队列的方式克服。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>将队列想象成环状的空间，当队首计算到MaxSize-1时，再出队则队首变为0，用取余运算实现。<br>初始：Q.front=0;Q.rear=0;<br>队首指针进一：Q.front=(Q.front+1)%MaxSize;<br>队尾指针进一：Q.rear=(Q.rear+1)%MaxSiae;<br>队列长度：(Q.rear + MaxSize - Q.front) % MaxSize;</p>
<p>判空判满：需要单独处理。</p>
<p>1）牺牲一个单元来区分，约定当队头在队尾的下一位置时队满，此时<br>队满：(Q.rear + 1)%MaxSize == Q.front;<br>队空：Q.front == Q.rear;<br>2)增加一个表示元素个数的数据成员，用来保存个数判断；<br>3）增加tag数据成员，tag=0，若因为删除导致Q.front == Q.rear，则是队空；tag=1，如果因为插入导致Q.front == Q.rear，则为队满。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判空</span><br><span class="line">bool isEmpty(SqQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.rear == Q.front)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//入队</span><br><span class="line">bool EnQueue(SqQueue &amp;Q, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    if((Q.rear + 1) % MaxSize == Q.front)</span><br><span class="line">        return false;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + 1) % MaxSize;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//出队</span><br><span class="line">bool DeQueue(SqQueue &amp;Q, ElemType &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.rear == Q.front)</span><br><span class="line">        return false;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + 1) % MaxSize;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h2><p>队列的链式存储叫做链队列，实际上就是同时有头指针和尾指针的单链表。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct LinkNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct LinkNode *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    LinkNode *front, *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化</span><br><span class="line">void InitQueue(LinkQueue &amp;Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));</span><br><span class="line">    Q.front-&gt;next = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判空</span><br><span class="line">bool IsEmpty(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.front == Q.rear)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">         return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//入队</span><br><span class="line">void EnQueue(LinkQueue &amp;Q, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = NULL;</span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//出队</span><br><span class="line">bool DeQueue(LinkQueue &amp;Q, ElemType &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.front == Q.rear)</span><br><span class="line">        return false;</span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;next;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    if(Q.rear == p)</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    &#125;</span><br><span class="line">    free(p);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列允许队列两端都能进行入队和出队操作，将两端称为前端和后端。</p>
<p>输出受限的双端队列是只允许一端进行入队出队，另一端入队操作。</p>
<p>输入受限的双端队列是只允许一端进行入队出队，另一端出队操作。</p>
<h1 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h1><p>栈和队列不仅仅有这些应用，下面是一些例子，要掌握规律。</p>
<h2 id="栈——括号匹配"><a href="#栈——括号匹配" class="headerlink" title="栈——括号匹配"></a>栈——括号匹配</h2><p>括号匹配问题是要求将一个表达式中相同但方向相反的括号进行匹配，例如读到（后一定会出现），否则表达式错误。</p>
<p><img src="/2022/08/03/DA-2/4.jpg" alt="场景"></p>
<p>该过程和栈的思想吻合，设置如下：<br>空栈顺序读入括号；<br>读入左括号入栈，直到等待下一个同类型右括号才能出栈；<br>读入右括号入栈，如果和栈顶不一致，那么就是非法的。</p>
<h2 id="栈——表达式求值"><a href="#栈——表达式求值" class="headerlink" title="栈——表达式求值"></a>栈——表达式求值</h2><p>表达式求值涉及到中缀后缀表达式的转换，感兴趣还可以看看表达式树。总之，栈可以用来计算后缀表达式的值。</p>
<p><img src="/2022/08/03/DA-2/5.jpg" alt="场景"></p>
<p>具体流程是，按顺序读入表达式，如果读入的是值，则入栈；如果读入的是操作符，则进行两次出栈操作并将两个值的运算结果重新入栈，直到栈中只有一个值。</p>
<h2 id="栈——递归"><a href="#栈——递归" class="headerlink" title="栈——递归"></a>栈——递归</h2><p><img src="/2022/08/03/DA-2/6.jpg" alt="场景"><br>将递归转换为非递归算法，通常需要用栈实现。</p>
<h2 id="队列——层次遍历"><a href="#队列——层次遍历" class="headerlink" title="队列——层次遍历"></a>队列——层次遍历</h2><p><img src="/2022/08/03/DA-2/7.jpg" alt="场景"><br><img src="/2022/08/03/DA-2/8.jpg" alt="场景"></p>
<h2 id="队列在计算机系统中应用"><a href="#队列在计算机系统中应用" class="headerlink" title="队列在计算机系统中应用"></a>队列在计算机系统中应用</h2><p>队列在计算机中应用非常广泛，可以解决外设和计算机速度不匹配的问题，另外还可以解决多用户引起的资源竞争问题。</p>
<h1 id="数组和特殊矩阵"><a href="#数组和特殊矩阵" class="headerlink" title="数组和特殊矩阵"></a>数组和特殊矩阵</h1><p>着重研究怎么更有效地存储矩阵，并提取元素。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数组，由n个相同类型的数据元素构成的有限序列，数组元素的下标取址范围称为数组的维界。</p>
<p>数组是线性表的推广，一维数组可以视为线性表，二维数组可以视为元素是线性表的线性表。</p>
<p>数组的维数和维界确定后就不能修改。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>采用数组数据类型进行存储，一个数组的所有元素在内存中占用一端连续的存储空间。</p>
<p>对于多维数组可以采用行优先和列优先的方法存储。</p>
<h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><p>压缩存储，为多个相同值的元素分配同一个存储空间，对零元素不分配空间，从而节省存储空间。</p>
<p>特殊矩阵，由许多元素相同，并且分布有一定规律性，如对称矩阵，三角矩阵，对角矩阵等。</p>
<p>特殊矩阵的压缩存储：找到值相同元素的分布规律，压缩存储到一个存储空间中。</p>
<h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p><img src="/2022/08/03/DA-2/9.jpg" alt="场景"><br><img src="/2022/08/03/DA-2/10.jpg" alt="场景"><br>第<em>i</em>行有<em>j-1</em>个元素，依次类推。</p>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>三角矩阵指上三角或下三角矩阵值相同的特殊矩阵，存储方法和对称矩阵类似，不过存储主对角线、非常量三角区后再存放常量一次。<br><img src="/2022/08/03/DA-2/11.jpg" alt="场景"></p>
<h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p>普通对角矩阵直接存储对角线元素即可，这里以三对角矩阵为例，所有非零元素集中在以主对角线为中心的三条对角线上。<br><img src="/2022/08/03/DA-2/12.jpg" alt="场景"><br><em>k=2i+j-3</em></p>
<h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><p>矩阵中非零元素很少，仅存储非零元素。<br>将非零元素以及其行列构成一个三元组，稀疏矩阵压缩后失去了随机存取特点。<br><img src="/2022/08/03/DA-2/13.jpg" alt="场景"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法复习（5）树与二叉树</title>
    <url>/2022/08/05/DA-4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章介绍树这种数据结构。重点内容是树和二叉树的性质，遍历操作，转换，存储结构等；满二叉树，完全二叉树，线索二叉树，哈夫曼树；二叉排序树，二叉平衡树。<br><img src="/2022/08/05/DA-4/13.jpg" alt="场景"><br><span id="more"></span></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>树是n个结点的有限集。n=0时称为空树。树有以下性质：</p>
<ul>
<li>只有一个称为根的结点；</li>
<li>n&gt;1时，结点可以分为若干互不相交的有限集，也就是子树；</li>
<li>根结点没有前驱；其他结点都只有一个前驱；</li>
<li>所有结点可以有任意个后继；<br>可以看出,树是一种递归定义的结构，适合表示有层次结构的数据，并且n个结点的树含有n-1条边。<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2>祖先，从根结点到目标结点上的任意结点都是目标结点的祖先；<br>双亲，目标结点的前驱；<br>孩子，目标结点的后继；<br>兄弟，具有相同双亲的结点；<br>堂兄弟，具有同一层次的结点；<br>度，目标结点孩子的个数；树中最大的度称为树的度；<br>分支结点，度大于0的结点；<br>叶子结点，度等于0的结点；<br>层次，从第一层根结点累计增加；<br>深度，从根结点逐层积累的层次；<br>高度，从叶子结点逐层积累的层次；<br>树高，树中结点的最大高度；<br>有序树，各子树从左到右有次序；<br>无序树，各子树从左到右没有次序；<br>路径，两个结点之间在树中的路径序列；<br>路径长度，路径序列的结点数；<br>森林，m棵互不相交的树的集合。</li>
</ul>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><img src="/2022/08/05/DA-4/1.jpg" alt="场景"></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>二叉树是n个结点的有限集，每个结点至多有两个子树，且子树左右不能颠倒，左子树和右子树分别是一棵二叉树；</p>
<p>二叉树不同于度为2的有序树：1）度为2的有序树最少需要三个结点，否则度小于2；2）度为2的有序树如果某个结点只有一个孩子，则不需要区分左右，但是二叉树仍然需要。</p>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>一棵高度为h，且含有2的h次方-1个结点的二叉树称为满二叉树，每层结点都是满的，除叶子结点外。</p>
<p>编号：自上而下，从左到右。对于编号为i的结点，其双亲编号为i/2向下取整，左孩子2i，右孩子2i+1。<br><img src="/2022/08/05/DA-4/2.jpg" alt="场景"></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>高度为h，有n个结点的二叉树，当且仅当每个结点都与满二叉树对应时称为完全二叉树。<br>满足以下性质：</p>
<ul>
<li>i&lt;=n/2向下取整，则结点i为分支结点；否则为叶子结点；</li>
<li>叶子结点只在最大的两层中出现，且最大层次中的叶子结点都在该层左边的位置上；</li>
<li>如果有度为1的结点，那么只有一个，且只有左孩子；</li>
<li>出现结点i为叶子结点，或者只有左孩子，那么编号大于i的结点全部为叶子结点；</li>
<li>奇数分支结点度都为2；偶数分支结点中最大的只有左孩子，其他都有；</li>
</ul>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>左子树所有结点关键字小于根，右子树所有结点关键字大于根，且左右子树依然是二叉排序树；</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树，树上任意结点的左子树和右子树的深度差不超过1；</p>
<h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><ul>
<li>非空二叉树上叶子结点数等于度为2的结点数加1，n0 = n2 + 1；</li>
<li>非空二叉树第i层至多有2的i-1次方个结点；</li>
<li>高度为h的非空二叉树至多有2的h次方-1个结点（等比数列）；</li>
<li>完全二叉树，结点i的双亲为i/2向下取整；i为偶数，是左孩子；i为奇数，是右孩子；2i&lt;=n，i的左孩子编号为2i，否则没有左孩子；2i+1&lt;=n，右孩子编号为2i+1，否则没有右孩子；结点i的深度为log(i)向下取整加1；</li>
<li>具有n个结点的完全二叉树高度为log(n+1)向上取整或log(n)向下取整加1；</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>用一组连续地址的存储单元从上往下，从左到右存储结点。</p>
<p>完全二叉树和满二叉树采用顺序存储比较合适，可以直接通过特殊关系映射到序号上；一般二叉树只能添加空结点从而与完全二叉树对照。</p>
<blockquote>
<p>如果数组下标从0开始，不满足完全二叉树的编号计算性质，所以最好从1开始。</p>
</blockquote>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>顺序存储空间利用率比较低，所以一般采用链式存储，结点至少有数据域，左指针域和右指针域。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct BiTNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><br>含有n个结点的二叉链表，含有n+1个空链域。</p>
<h1 id="二叉树的遍历和线索二叉树"><a href="#二叉树的遍历和线索二叉树" class="headerlink" title="二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h1><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>二叉树的遍历是指按照某条路径访问树中的每个结点，让所有结点都被访问一次。</p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PreOrder(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    if(T != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InOrder(BiTree)</span><br><span class="line">&#123;</span><br><span class="line">    if(T != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PostOrder(BiTree)</span><br><span class="line">&#123;</span><br><span class="line">    if(T != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrder(lchild);</span><br><span class="line">        PostOrder(rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里给出一个例子：<br><img src="/2022/08/05/DA-4/4.jpg" alt="场景"><br>前序：abdexc<br>中序：debxac<br>后续：edxbca</p>
<h3 id="递归和非递归"><a href="#递归和非递归" class="headerlink" title="递归和非递归"></a>递归和非递归</h3><p>上面三种遍历方式都是递归的，时间复杂度均为O(n)。要实现递归方法到非递归方法的转变，可以借助栈来实现。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PreOrder1(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    while(p != NULL || IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        if(p != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            Push(S,p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Pop(S,p);</span><br><span class="line">            p = p-&gt;rchild;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InOrder1(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    while(p != NULL || IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        if(p != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(S,p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Pop(S,p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;rchild;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前序遍历和中序遍历思想差不多，都是在寻找左子树的同时用栈记录走过的路径，并在左子树为空的时候利用出栈操作找到双亲结点接着记录。所以后序遍历就难以实现，因为后序遍历的根结点在最后才进行访问。</p>
<p>所以，后序遍历的非递归应该是，搜索到左子树为空后依然不能将双亲结点其出栈访问，而是取栈顶并访问右子树，做相同操作，直到右子树为空，或者右子树确定被访问完毕，才能出栈并访问。非递归后序遍历利用了后续遍历的关键性质，一个已经返回的节点，它的左右子树也必定返回过，且上一个返回的节点就是它的右子树。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || s.<span class="built_in">empty</span>() == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先找左孩子</span></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出非空左孩子</span></span><br><span class="line">            root = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断是否能返回</span></span><br><span class="line">            <span class="keyword">if</span>(root -&gt; right == <span class="literal">nullptr</span> || prev == root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>在线性表一章提到过，要实现层次遍历可以利用队列实现。入队顺序按照根结点、左子树、右子树的顺序，并在出队的时候进行访问，就实现了层次遍历。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void LevelOrder(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    EnQueue(Q,T);</span><br><span class="line">    while(!IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(Q,p);</span><br><span class="line">        visit(p);</span><br><span class="line">        if(p-&gt;lchild != NULL)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        if(p-&gt;rchild != NULL)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h3><p>这个问题本身不算是严格的算法，只是该类题型比较多，因此重点记录。</p>
<p>中序遍历+前序遍历可以确定二叉树；<br>中序遍历+后续遍历可以确定二叉树；<br>中序遍历+层次遍历可以确定二叉树；<br>前序遍历+后续遍历不能确定；</p>
<p>确定的方法就是找根结点的位置，对比两种序列的相同根节点，最后就能确定了。</p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>以一定的规则将二叉树中的结点排列成一个线性序列。这个规则可以是前中后序的遍历，节点的前驱后继通过遍历后的序列唯一确定。</p>
<p>前面有结论，n个结点的二叉树有n+1个空指针（链式存储），为了加快查找结点前驱和后继的速度，利用这些空指针来存储指向结点前驱和后继的指针。</p>
<p>因此直接做规定：结点没有左子树，则lchild指向前驱；没有右子树，lchild指向后继。除此之外，为了表示左右指针指向孩子还是前驱后继，要额外引入两个标记值来记录。<br><img src="/2022/08/05/DA-4/3.jpg" alt="场景"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct ThreadNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct ThreadNode *lchild, *rchild;</span><br><span class="line">    int ltag, rtag;</span><br><span class="line">&#125;ThreadNode, *ThreadTree</span><br></pre></td></tr></table></figure>
<h3 id="中序线索二叉树的构造"><a href="#中序线索二叉树的构造" class="headerlink" title="中序线索二叉树的构造"></a>中序线索二叉树的构造</h3><p>二叉树线索化就是将空指针改为前驱后继，因此实际上是要遍历一遍二叉树。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InThread(ThreadTree &amp;p, ThreadTree &amp;pre)</span><br><span class="line">&#123;</span><br><span class="line">    if(p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        InTread(p-&gt;lchild, pre);</span><br><span class="line">        if(p-&gt;lchild == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre != NULL &amp;&amp; pre-&gt;rchild == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThread(p-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>判断左指针是否指向前驱的时候，因为用pre保存了p的前驱，所以比较方便，p的左指针为空就用pre赋值；但是判断右指针是否指向后继的时候比较麻烦，因为p的后继没有访问到，所以只能访问pre的后继p，判断pre的右指针从而决定要不要赋值。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CreateInTread(ThreadTree T)</span><br><span class="line">&#123;</span><br><span class="line">    ThreadTree pre = NULL;</span><br><span class="line">    if(T != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        InThread(T,pre);</span><br><span class="line">        pre-&gt;rchild = NULL;//处理最后一个结点的后继</span><br><span class="line">        pre-&gt;rtag = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="中序线索二叉树的遍历"><a href="#中序线索二叉树的遍历" class="headerlink" title="中序线索二叉树的遍历"></a>中序线索二叉树的遍历</h3><p>由于已经保存了后继信息，所以从第一个结点开始依次访问其后继。定义一个结点的后继是，如果右标志为1，则直接访问后继线索；否则目标结点右子树中第一个中序遍历访问的结点为其后继。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//先找到中序遍历的首结点</span><br><span class="line">ThreadNode *FirstNode(Thread *p)</span><br><span class="line">&#123;</span><br><span class="line">    while(p-ltag == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//然后找目标结点后继</span><br><span class="line">ThreadNode *NextNode(ThreadNode *p)</span><br><span class="line">&#123;</span><br><span class="line">    if(p-&gt;rtag == 0)</span><br><span class="line">        return FirstNode(p-&gt;rchild)</span><br><span class="line">    else</span><br><span class="line">        return p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//不含头结点的中序线索二叉树遍历算法</span><br><span class="line">void InOrderThread(ThreadNode *T)</span><br><span class="line">&#123;</span><br><span class="line">    for(ThreadNode *p = FirstNode(T); p != NULL; p = NextNode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前序和后序线索二叉树"><a href="#前序和后序线索二叉树" class="headerlink" title="前序和后序线索二叉树"></a>前序和后序线索二叉树</h3><p>前序和后序进行线索化的过程类似，只是按照遍历顺序不同结点前驱后继有所改变。<br>总之，按照对应的线索化序列遍历，结点前面就是前驱，后面就是后继，没有就置空，然后修改空指针即可。</p>
<h1 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h1><h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><p>树的存储方式有多种，要求能唯一反应结点的逻辑关系。</p>
<h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>顺序存储，同时为每个结点增加一个伪指针，指向双亲。其中根结点下标为0，伪指针为-1。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAX_SIZE 100</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    int parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    PTNode nodes[MAX_SIZE];</span><br><span class="line">    int n;//结点数</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><br><img src="/2022/08/05/DA-4/5.jpg" alt="场景"><br>求双亲直接，求孩子需要遍历。</p>
<blockquote>
<p>区别于二叉树的顺序存储，因为限制了二叉树的形状是完全二叉树，所以下标既表示结点也能表示关系；而树的顺序存储因为不知道形状，所以不能确定，要用数组中的额外内容确定关系。</p>
</blockquote>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>将每个结点的孩子结点都用单链表连接起来形成线性结构，n个结点就有n个孩子链表。<br><img src="/2022/08/05/DA-4/6.jpg" alt="场景"><br>求孩子直接，求双亲要遍历。</p>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>以二叉链表作为树的存储结构，每个结点包括三部分：结点值，指向结点第一个孩子结点的指针，指向结点下一个兄弟结点的指针，从而表示所有结点关系。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct CSNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct CSNode *fitstchild, *nextsibling;</span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure><br><img src="/2022/08/05/DA-4/7.jpg" alt="场景"><br>优点是容易转换树为二叉树，查找孩子结点；缺点是难查找双亲结点。</p>
<h2 id="树、二叉树、森林的转换"><a href="#树、二叉树、森林的转换" class="headerlink" title="树、二叉树、森林的转换"></a>树、二叉树、森林的转换</h2><p>树-&gt;二叉树：左孩子右兄弟，即使用二叉链表来存储树；<br>兄弟之间加连线；每个结点只保留和第一个孩子的连线，删掉其他连线；以树根为中心顺时针旋转45度。</p>
<p>森林-&gt;二叉树：将森林每棵树转化为二叉树，然后按照右子树依次连接；<br>每棵树转化成二叉树后，在每棵树的根之间加连线，以第一颗树的根为中心顺时针旋转45度。</p>
<p>二叉树-&gt;森林（树）：断开右子树，直到得到一棵没有右子树的二叉树；对每棵二叉树再转化成树（拆开的二叉树没有右子树，根节点连着的都是孩子结点），就得到了森林。<br><img src="/2022/08/05/DA-4/8.jpg" alt="场景"></p>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><p>树：</p>
<ul>
<li>先根遍历：先访问根节点，再依次访问结点的每棵子树；（类似前序遍历）</li>
<li>后根遍历：先遍历每棵子树，再访问根节点；（类似中序遍历）</li>
<li>层次遍历：与前面介绍的相同；</li>
</ul>
<p>森林：</p>
<ul>
<li>先序遍历森林：先序遍历第一颗子树，再遍历剩下的森林；</li>
<li>中序遍历森林：中序遍历第一颗子树，再遍历剩下的森林；</li>
</ul>
<p>森林的先序和中序遍历为其对应二叉树的先序和中序遍历。<br><img src="/2022/08/05/DA-4/9.jpg" alt="场景"></p>
<h1 id="树和二叉树的应用"><a href="#树和二叉树的应用" class="headerlink" title="树和二叉树的应用"></a>树和二叉树的应用</h1><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>带权路径长度，从树根到任意结点的路径长度与该结点权值的乘积。树中所有叶子结点的带权路径长度之和称为树的带权路径长度。</p>
<p>在一棵含有n个带权叶子结点的二叉树中，按照不同方式构造，带权路径长度最小的二叉树称为哈夫曼树。</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>给定n个带权叶子结点，构造哈夫曼树：</p>
<ul>
<li>每个结点作为一个二叉树，构成森林；</li>
<li>选出权值最小的两个结点作为左右子树，根结点权重为两结点之和；</li>
<li>新得到的二叉树放入森林，并删除刚才选出的两个结点；</li>
<li>重复上面的步骤，直到森林中只剩下一棵树；<br><img src="/2022/08/05/DA-4/10.jpg" alt="场景"></li>
</ul>
<p>可以看到，权值越小的结点离根结点越远；n个叶子结点构造的哈夫曼树共有2n-1个结点；不存在度为1的结点。</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>数据通信中，哈夫曼编码是一种数据压缩编码，也是可变长度编码，给出现频率高的字符以较短编码，出现频率低的字符以较长编码。</p>
<p>另外，没有字符的编码是另一个字符编码的前缀，这种编码方式称为前缀编码。哈夫曼编码也是前缀编码。</p>
<p>在哈夫曼树中，将每个字符当作一个独立的叶子结点，权值为出现的频度，构造出哈夫曼树，使得较高频率的字符离树根较近。<br><img src="/2022/08/05/DA-4/11.jpg" alt="场景"><br>将编码与边进行映射，0表示转向左孩子，1表示转向右孩子。这时哈夫曼树的带权路径长度WP(Weighted Path Length)可以视为得到的字符串二进制编码长度，哈夫曼树可以设计出总长度最短的二进制前缀编码。哈夫曼树并不唯一，但相同层的结点应该相同，只是顺序不同（代表着WPL相同）。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种简单的集合表示，支持三种操作，主要用来处理不相交集合的合并和查询。<br><img src="/2022/08/05/DA-4/12.jpg" alt="场景"><br>一般用树的双亲表示作为并查集的存储结构，初始时每个子集用一棵树表示，所有子集构成森林，将他们的双亲存储在数组内（此时没有双亲就是自己），此时还没有集合进行过合并；让数组元素下标代表元素名，数组内容代表双亲；</p>
<blockquote>
<p>408书中说这里如果一个结点是根结点，那么就把他的双亲数组内容设置为负数；否则设置为他的双亲。但是我看其他地方没有这个规定，只要把它的双亲按照初始化设置为自己就行了，这样在后面查找的时候一直查找双亲就能找到根结点，不过需要改一下查找循环的判断条件。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define SIZE 100</span><br><span class="line">int UFsets[SIZE];</span><br><span class="line">//初始化</span><br><span class="line">void Initial(int S[])</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; SIZE; i++)&#123;</span><br><span class="line">        S[i] = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//查找</span><br><span class="line">int Find(int S[], int x)</span><br><span class="line">&#123;</span><br><span class="line">    while(S[x] &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        x = S[x];</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">//合并Root2到Root1中</span><br><span class="line">void Union(int S[], int Root1, int Root2)</span><br><span class="line">&#123;</span><br><span class="line">    S[Root2] = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法复习（4）串</title>
    <url>/2022/08/04/DA-3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要是掌握字符串模式匹配，KMP匹配算法原理以及next数组推理过程。了解nextval数组求解的方法。<br><img src="/2022/08/04/DA-3/11.jpg" alt="场景"><br><span id="more"></span><br>王道书中讲解next数组代码求法部分写的不太清晰，建议先看这篇<a href="https://www.zhihu.com/question/21923021">知乎文章</a>理解。这是一个链接</p>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p>串就是字符串的简称，下面先介绍存储结构和基本操作。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>串，由零个或多个字符组成的有限序列，一般记为：<br><img src="/2022/08/04/DA-3/1.jpg" alt="场景"><br>长度n为0时，称为空串。</p>
<p>子串，任意多个连续的字符组成的子序列称为该串的子串；</p>
<p>主串，包含子串的串；</p>
<p>位置，字符在串中的序号；</p>
<p>相等，两个串长度和对应位置的字符都相同；</p>
<p>空格串，由一个或多个空格组成的串；</p>
<p>串对比线性表，只是数据类型限定为字符集；线性表操作以元素为主，串的操作以子串为主。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h3><p>用一组地址连续的存储单元存储字符，即定长数组。超过预定长度的串值会被截断，串长可以由额外的变量来存放，也可以在串尾加上不及长度的标记字符，隐含串长。</p>
<h3 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h3><p>仍然用一组地址连续的存储单元存放，但是存储空间动态分配，malloc为每个新串在自由存储区“堆”内分配空间。</p>
<h3 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h3><p>类似线性表的链式存储结构，每个结点称为块，可以存放一个或多个字符，整个链表称为块链结构。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="/2022/08/04/DA-3/2.jpg" alt="场景"></p>
<p>其中串赋值，比较，串长，连接，子串五种操作为基本操作，其他操作可以通过这五种实现。</p>
<h1 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h1><p>串的模式匹配就是子串的定位操作，即求子串（模式串）在主串中的位置。</p>
<h2 id="简单模式匹配算法"><a href="#简单模式匹配算法" class="headerlink" title="简单模式匹配算法"></a>简单模式匹配算法</h2><p>暴力匹配算法：<br>遍历主串和子串的每一个字符，用两个指针标识比较的字符位置，当两个字符相同，那么两个指针加1继续比较下一个字符；如果字符不同，那么主串指针从主串的下一个字符位置开始重新匹配，子串指针从头开始匹配。遍历完成后，如果子串的指针超过了子串长度，那么说明匹配成功，返回主串指针回退子串长度个单位的值；否则匹配失败返回0。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.Length() - <span class="number">1</span> &amp;&amp; j &lt;= T.Length() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == T.Length())</span><br><span class="line">        <span class="keyword">return</span> i - T.Length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为O(mn)。</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>王道这部分讲得一般，前面手推还好，后面代码实现基本无法理解，也可能是我没智商吧。</p>
<p>前缀：除最后一个字符外所有子串；<br>后缀：除第一个字符外所有子串；<br>部分匹配值：前后缀的最长相等前后缀长度；</p>
<p>KMP算法利用公式“移动位数 = 已匹配字符数 - 对应部分匹配值”改进暴力算法，缩短子串指针的回退长度，每次发生不匹配的时候，通过公式算出下一次移动的位数，重新匹配，而非简单地进1，具体做法后面说。</p>
<p>其中对应部分匹配值通过查询PM表获得。</p>
<p><img src="/2022/08/04/DA-3/4.jpg" alt="场景"></p>
<p>从左到右提取子串，长度依次加一：</p>
<ul>
<li>‘a’的前后缀都为空，所以部分匹配值为0；</li>
<li>‘ab’的前缀为{a}，后缀{b}，交集为空，匹配值为0；</li>
<li>‘abc’的前缀{a,ab}，后缀{c,bc}，交集为空，匹配值为0；</li>
<li>‘abca’的前缀{a,ab,abc}，后缀{a,ca,bca}，交集为{a}，匹配值为1；</li>
<li>‘abcac’的前缀{a,ab,abc,abca}，后缀{c,ac,cac,bcac}，交集为空，匹配值为0；</li>
</ul>
<p>通过这样的方式就得到了PM表(Partial Match)。它记录了前i个字符组成的串中前后重复的字符个数，下面看看如何使用它。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/2022/08/04/DA-3/3.jpg" alt="场景"></p>
<p>KMP公式中“已匹配字符数”表示如果最后一个匹配字符的部分匹配值为0的时候，子串应该在主串上移动的距离，因为这部分串已经和模式串不同了，需要直接移动模式串到主串的下一位并从头开始比较，而且部分匹配值为0说明此时头部和尾部没有相同的部分，没必要比较。这等价于主串指针进一的情况下，将子串的指针退回到0。</p>
<p>如果匹配的最后一个字符的部分匹配值不为0，说明子串的这个地方首尾会发生重复，本例中就是’a’发生重复，既是最后一个匹配的字符，同时也是子串开头，下一次移动的时候应该把子串移动到这里，使得子串开头的’a’同主串的’a’对齐，并且从这里继续匹配，从而防止跳过而发生遗漏。</p>
<p>总的来说，“已匹配字符数 - 对应部分匹配值”表示用不重复的情况下应该移动的距离，减去重复的字符个数，就能计算出实际要移动的距离了。上图中已匹配字符数为4，但是重复了一个字符，所以只能移动三下。逐个比较i，j指向的字符，不论是否成功都让i++，j根据下面的比较结果计算。</p>
<p>右移步数Move = (j-1) - PM[j-1];</p>
<p>直接使用PM表时，由于要指针减1找到最后匹配的字符，所以不妨直接将PM表的值右移，得到next数组：</p>
<p><img src="/2022/08/04/DA-3/5.jpg" alt="场景"></p>
<p>右移步数Move = (j-1) - next[j];</p>
<ul>
<li>右移空缺用-1填补，第一个元素不匹配通过公式也可以算出要移动到下一位；</li>
<li>溢出的元素舍去，因为没有需要使用这个匹配值的元素了；</li>
</ul>
<p>前面说了，右移的操作等价于将模式串(子串)的指针j回退，j计算为：<br>j = j - Move = next[j] + 1;</p>
<p>有时为了简洁，还将next数组整体加1，就省去了上面公式的加1，从而直接移动即可。</p>
<p><img src="/2022/08/04/DA-3/6.jpg" alt="场景"></p>
<p>这样将公式化简为：<br>j = next[j];<br>含义为：在子串的第j个字符发生不匹配时，跳到子串的next[j]位置重新与主串当前位置匹配。例如4.4图中在编号为5时匹配失败了，但是i++，j更新为next[5]=2，c和c又对齐了，继续比较。</p>
<h3 id="next数组的一般公式"><a href="#next数组的一般公式" class="headerlink" title="next数组的一般公式"></a>next数组的一般公式</h3><p>上面推导next公式用代码表示其实比较繁琐，我们需要不断比较前后缀并找到最长的相同前后缀。有没有更一般的方法？</p>
<p>通过对模式串的遍历，我们可以快速求出next数组。定义left指向当前长度下，最长相同前缀的后一个元素，由于数组从0开始，它的值还代表了达到当前长度时，相同前后缀的最长长度。right指向最长后缀的后一个元素，我们用它遍历整个模式串。</p>
<p>代码如下。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//特例返回</span></span><br><span class="line">    <span class="keyword">if</span>(needle.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//next数组，大小和模式串相同</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历求next数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>; right &lt; needle.<span class="built_in">size</span>(); right++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配失败，回溯到前一个匹配的</span></span><br><span class="line">        <span class="keyword">while</span>(left &gt; <span class="number">0</span> &amp;&amp; needle[left] != needle[right])</span><br><span class="line">        &#123;</span><br><span class="line">            left = next[left<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配成功，left++</span></span><br><span class="line">        <span class="keyword">if</span>(needle[left] == needle[right])</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//left的值代表当前长度下，最长相同前缀的后一个元素</span></span><br><span class="line">        <span class="comment">//由于数组从0开始，它的值还代表了达到当前长度时，相同前后缀的最长长度</span></span><br><span class="line">        next[right] =  left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配主串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配失败，寻找回溯值</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配成功，模式串指针++</span></span><br><span class="line">        <span class="keyword">if</span>(haystack[i] == needle[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果j已经匹配完成，返回主串中的起始地址</span></span><br><span class="line">        <span class="keyword">if</span>(j == needle.<span class="built_in">size</span>()) <span class="keyword">return</span> i - needle.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>下面再解释一下如何求next数组，先理解left和right。</p>
<p>通过前面公式我们定义next[0] = 0，现在要求next[j+1]。我们先看abcab这个模式串。根据left和right的初始化，我们知道刚开始它们分别指向a和b，由于不相等，我们让b的next值为next[j-1]=0，也就是a的next值。一直重复，直到迭代到第二个a，发现有重复了，那么我们就让left和right同时进1，看看后面还有没有进一步的重复，让第二个a的next值为1。</p>
<p>然后发现同时进1后left和right指向的b也是相同的，那么b对应的next值就是c的下标，它就是left在匹配成功之后进1的值。所以说left就是最长相同前后缀的长度，指向最长相同前缀的后一个位置。right和left在匹配成功后会同步地进1，right指向的是最长相同后缀的后一个位置。</p>
<p>然后理解left = next[left-1]。</p>
<p>在下面的例子中，left在前缀中达到了d，right在后缀中达到了c，它们前面的部分都是匹配的，此时应该寻找有没有短一些的相同前后缀，所以让指向d的left回溯到前一个位置上next的状态，也就是b对应的2。</p>
<p><img src="/2022/08/04/DA-3/8.jpg" alt="场景"></p>
<p>这个值说明什么？说明在right指向的c前面，已经有两个字符是相同的前后缀(下图中的ab)，我们不用比较它们，得让left为2，也就是前缀中第三个字符和当前字符比较，发现是相同的，那么我们相同前后缀长度就又可以+1了，下面图中的？就应该是2+1=3。</p>
<p><img src="/2022/08/04/DA-3/9.jpg" alt="场景"></p>
<p>如果不相同，那么就会一直回溯直到left为0，此时没有相同的前后缀，left不会移动，right++，比较下一个字符和第一个字符。</p>
<h2 id="KMP算法的优化"><a href="#KMP算法的优化" class="headerlink" title="KMP算法的优化"></a>KMP算法的优化</h2><p>形如aaabaaaab的主串匹配aaaab模式串时，KMP算法会对前面几个a一一比对，显然没有必要。关键在于出现了T[j]=T[next[j]]，因此如果出现这种情况，则再进行一次递归：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//另一种求next的写法，除了改进的部分过程是一样的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nextval</span><span class="params">(String T, <span class="type">int</span> nextval[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = , j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.<span class="built_in">Length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i] != T.ch[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">                <span class="comment">//如果不相等则正常加1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j]; </span><br><span class="line">                <span class="comment">//相等则递归一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2022/08/04/DA-3/10.jpg" alt="场景"></p>
<blockquote>
<p>只需要递归一次，相同的值就会传递下去，这样修正了next数组。</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法复习（7）查找</title>
    <url>/2022/08/15/DA-6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面几章基本介绍完主要的数据结构，本章着重查找算法，以及一些排序算法用到的数据结构，在前面的基础上延伸。重点是顺序、折半、分块查找，二叉排序、二叉平衡树，红黑树，B树，B+树，散列表。<br><img src="/2022/08/15/DA-6/1.jpg" alt="场景"><br><span id="more"></span></p>
<h1 id="查找基本概念"><a href="#查找基本概念" class="headerlink" title="查找基本概念"></a>查找基本概念</h1><ul>
<li>查找：在数据集合中寻找某种满足条件的元素的过程；</li>
<li>查找表（查找结构）：用于查找的数据集合，一般有四种操作，1）查询特定元素；2）检索特定元素属性；3）插入数据；4）删除数据；</li>
<li>静态查找表：没有插入删除操作的查找表；</li>
<li>动态查找表：需要动态插入删除操作的查找表；</li>
<li>关键字：数据元素中唯一标识元素的某个数据项的值；</li>
<li>平均查找长度(Average Search Length)：所有查找过程中进行关键字的比较次数的平均值；<br><img src="/2022/08/15/DA-6/2.jpg" alt="场景"></li>
</ul>
<h1 id="顺序和折半查找"><a href="#顺序和折半查找" class="headerlink" title="顺序和折半查找"></a>顺序和折半查找</h1><h2 id="顺序查找O-n"><a href="#顺序查找O-n" class="headerlink" title="顺序查找O(n)"></a>顺序查找O(n)</h2><p>又称线性查找，遍历每个元素进行查找。下面分为对一般无序线性表的查找和对关键字有序的线性表查找。</p>
<h3 id="一般无序"><a href="#一般无序" class="headerlink" title="一般无序"></a>一般无序</h3><p>从线性表的一端开始，逐个检查关键字是否满足条件；如果查找到表的另一端还没有找到，那么查找失败。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType *elem;//下标0的元素留空</span><br><span class="line">    int TableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line">int Search_Seq(SSTable ST, ElemType key)</span><br><span class="line">&#123;</span><br><span class="line">    ST.elem[0] = key;</span><br><span class="line">    for(int i = ST.TableLen; ST.elem[i] != key; i--);</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要说明的是，为了防止查找时数组越界，将查找表的0号下标元素留空，用来存放要查找的关键字值，并从后往前遍历查找表，这样当查找到0号元素时循环就会结束，此时i的值为0，表示查找失败。这里的ST.elem[0]被称为“哨兵”，很多时候可以避免不必要的判断语句，提高效率。</p>
<blockquote>
<p>笔者个人认为这里做适当处理即可，不一定采取这样的措施，因为查找表的长度已知，可以添加判断条件。不过采用“哨兵”的方法确实能避免添加的判断条件。</p>
</blockquote>
<p>所有元素查找成功概率相等，要查找的元素为第i个时，平均查找长度为：<br><img src="/2022/08/15/DA-6/3.jpg" alt="场景"><br>其中<em>p</em>值为<em>1/n</em>。</p>
<p>查找失败时，平均查找长度为：<br><img src="/2022/08/15/DA-6/4.jpg" alt="场景"></p>
<h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><p>假设有一个线性表的关键字从小到大排列，查找顺序从前往后，关键字值为key，只要当key的值介于两个元素关键字值之间，就可以判定查找失败。用下图理解查找过程：<br><img src="/2022/08/15/DA-6/5.jpg" alt="场景"><br>圆形内的是查找表的数据元素，矩形内是查找失败结点（n个结点对应n+1个失败结点），如果要匹配的关键字在任何一个矩形范围内，就说明匹配失败。</p>
<p>查找成功时平均查找长度：<br><img src="/2022/08/15/DA-6/3.jpg" alt="场景"></p>
<p>查找失败平均查找长度：<br><img src="/2022/08/15/DA-6/6.jpg" alt="场景"><br><em>q</em>是到第j个失败结点的概率，相等情况下为<em>1/n+1</em>；<em>l</em>是第j个失败结点所在的层数（注意这里的层数从2开始，在某层失败就要查找层数-1次；第7层有两个失败结点，因为最后一层只要不相等都查找失败），注意理解。</p>
<h2 id="折半查找-O-log-2-n"><a href="#折半查找-O-log-2-n" class="headerlink" title="折半查找$O(log_2(n))$"></a>折半查找$O(log_2(n))$</h2><p>又称二分查找，用于查找有序线性表。基本思想是，将关键字key与中间元素关键字比较，相等则查找成功；不相等根据大小关系决定在中间值的左半边还是右半边比较，重复步骤直到查找成功或没有元素可以查找。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Binary_Search(SeqList L, ElemType key)</span><br><span class="line">&#123;</span><br><span class="line">    int low = 0, high = L.TableLem-1, mid;</span><br><span class="line">    while(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high)/2;</span><br><span class="line">        if(L.elem[mid] == key)</span><br><span class="line">            return mid;</span><br><span class="line">        else if(L.elem[mid] &gt; key)</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        else</span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>折半查找过程可以用判定树描述：<br><img src="/2022/08/15/DA-6/7.jpg" alt="场景"><br>可以看出这是一棵平衡二叉树。查找成功的ASL就等于目标结点的层数；查找失败的ASL就等于目标失败结点的层数-1。</p>
<p>查找成功平均查找长度：<br><img src="/2022/08/15/DA-6/8.jpg" alt="场景"><br>其中h是树的高度，n是结点数。1/n表示概率相等。就是结点的层数乘以该层结点数的和，然后乘以概率。</p>
<p>查找失败平均查找长度：<br>暂时没有公式，其实也是失败结点层数乘以该层失败结点数的和，然后乘以概率。</p>
<p>折半查找需要线性表能够随机存取且关键字有序，因此不适合链式存储。</p>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>又称索引顺序查找，基本思想是将查找表分为若干块，块内元素无序，块有序，建立一个索引表，每个元素包括块的最大关键字和块第一个元素的地址，然后按照关键字排列这个索引表。</p>
<p>查找时，先通过顺序或折半查找索引表，得到目标块，然后在块内顺序查找。<br><img src="/2022/08/15/DA-6/9.jpg" alt="场景"></p>
<p>分块查找的平均查找长度为索引查找和块内查找之和，如果都采用顺序查找O(n)：<br><img src="/2022/08/15/DA-6/10.jpg" alt="场景"><br>长度为n的线性表被分为b块，每块有s个记录。如果索引表采用折半查找$O(log_2(n))$：<br><img src="/2022/08/15/DA-6/11.jpg" alt="场景"></p>
<h1 id="树型查找"><a href="#树型查找" class="headerlink" title="树型查找"></a>树型查找</h1><h2 id="二叉排序树BST-O-log-2-n-O-n"><a href="#二叉排序树BST-O-log-2-n-O-n" class="headerlink" title="二叉排序树BST$O(log_2(n))-O(n)$"></a>二叉排序树BST$O(log_2(n))-O(n)$</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>左子树上所有结点的值均小于根结点；右子树上所有结点的值均大于根结点；左右子树各是一棵二叉排序树。（可以是空树）</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从根结点开始，如果小于根结点关键字，在左子树上查找；否则在右子树上查找，直到查找成功或查找了所有结点。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//非递归算法</span><br><span class="line">BSTNode *BST_Search(BiTree T, ElemType key)</span><br><span class="line">&#123;</span><br><span class="line">    while(T != NULL &amp;&amp; key != T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        if(key &lt; T-&gt;data)</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        else</span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line">//递归算法</span><br><span class="line">BSTNode *BST_Search(BiTree T, ElemType key)</span><br><span class="line">&#123;</span><br><span class="line">    if(T == NULL)</span><br><span class="line">        return false;</span><br><span class="line">    </span><br><span class="line">    if(key == T-&gt;data)</span><br><span class="line">        return T;</span><br><span class="line">    else if (key &lt; T-&gt;data)</span><br><span class="line">        return BST_Search(T-&gt;lchild, key);</span><br><span class="line">    else</span><br><span class="line">        return BST_Search(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>如果树空，直接插入结点；非空，关键字k小于根结点，插入到左子树；否则插入到右子树。<strong>插入的结点一定是叶子结点</strong>。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int BST_Insert(BiTree &amp;T, KeyType k)</span><br><span class="line">&#123;</span><br><span class="line">    if(T == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        T = (BiTree)malloc(sizeof(BSTNode));</span><br><span class="line">        T-&gt;data = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = NULL;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(T-&gt;data == k)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;//不能有相同值存在</span><br><span class="line">    &#125;</span><br><span class="line">    else if(T -&gt;data &gt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        return BST_Insert(T-&gt;lchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return BST_Insert(T-&gt;rchild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>给定一个数组，用其中的元素构成一个二叉排序树。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Create_BST(BiTree &amp;T, KeyType str[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    T = NULL;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        BST(Insert(T, str[i]));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>如果删除的结点不会破坏排序二叉树性质，则直接删除；如果删除的结点只有一棵左子树或右子树，则让子树根结点代替删除结点；如果有两棵子树，让结点中序遍历（<strong>BST的中序遍历是一个升序数组</strong>）的直接后继（或前驱）替代结点，然后直接删除这个重复的直接后继（或前驱），这是因为直接后继（或前驱）一定是前面两种情况之一。</p>
<p>或者说用目标右子树中的最小值代替。</p>
<p><img src="/2022/08/15/DA-6/12.jpg" alt="场景"><br>（图中是用后继代替的情况)</p>
<h3 id="平均查找长度"><a href="#平均查找长度" class="headerlink" title="平均查找长度"></a>平均查找长度</h3><p>取决于树的形状，如果是平衡二叉树（左右子树高度相差最大为1），平均查找长度为O(log(n))，如果是倾斜的单支树，就和一般线性查找表没有区别，平均查找长度为O(n)。这取决于输入的元素序列。<br><img src="/2022/08/15/DA-6/13.jpg" alt="场景"></p>
<p>当有序表是静态，选择顺序表进行存储并采用折半查找；当有序表是动态，选择BST作为逻辑结构。</p>
<h2 id="平衡二叉树-O-log-2-n"><a href="#平衡二叉树-O-log-2-n" class="headerlink" title="平衡二叉树$O(log_2(n))$"></a>平衡二叉树$O(log_2(n))$</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>任意结点的<strong>左右子树高度相差不超过1</strong>，简称平衡树。左右子树的高度差为结点的<strong>平衡因子</strong>。平衡二叉树可以为空。</p>
<p>平衡二叉树就是左右子树都是平衡二叉树，且左右子树平衡因子的绝对值不超过1。</p>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>每次插入结点时，检查是否导致不平衡，如果导致不平衡，找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，调整以A结点为根的子树（最小不平衡子树），在保证二叉排序树的前提下调整子树结点位置关系。<br><img src="/2022/08/15/DA-6/14.jpg" alt="场景"><br>位置调整可以归纳成四种操作：</p>
<ul>
<li><p>LL：在左孩子的左子树上插入新结点，断开A与左孩子B的连接，将B的右子树作为A的左子树，A作为B的右子树。右旋转。<br><img src="/2022/08/15/DA-6/15.jpg" alt="场景"></p>
</li>
<li><p>RR：在右孩子的右子树上插入新结点，断开A与右孩子B的连接，将B的左子树作为A的右孩子，A作为B的左子树。左旋转。<br><img src="/2022/08/15/DA-6/16.jpg" alt="场景"></p>
</li>
<li><p>LR：在左孩子的右子树上插入新结点，先对A的左孩子B进行左旋转；然后再对C进行右旋转；<br><img src="/2022/08/15/DA-6/17.jpg" alt="场景"></p>
</li>
<li><p>RL：在右孩子的左子树上插入新结点，先对A的右孩子B进行右旋转；然后再对C进行左旋转；<br><img src="/2022/08/15/DA-6/18.jpg" alt="场景"></p>
</li>
</ul>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>找到要删除的结点，向上回溯同样找到最小不平衡子树，设根结点为z，y是z两个孩子结点中高度最高的结点，x是结点y两个孩子结点中高度最高的结点。</p>
<p>根据不平衡节点w和最高高度儿子y，最高高度孙子x的关系，可以分为四种类型：</p>
<p><img src="/2022/08/15/DA-6/19.jpg" alt="场景"><br>（对x进行操作)<br>与插入不同的是，插入的调整只需要进行依一次，但是删除后检查原父结点是否失衡，调整后还要进一步回溯到父结点的父结点重新检查调整。</p>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>和排序二叉树相同，平均查找长度O(log(n))。</p>
<p>n个结点的平衡二叉树最大深度为O(log(n))。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>由于AVL要频繁调整拓扑结构，所以引入红黑树，定义为满足一定红黑性质的二叉排序树：每个结点分为红色和黑色。其中根结点和叶结点是黑色，而且不会存在两个相邻的红色结点（红色结点的双亲和孩子都是黑色）；对每个结点，从该结点到任意叶结点的简单路径上，所含黑色结点的数量相同。</p>
<p>从任意结点出发，到一个叶结点的任一简单路径上黑结点的总数称为该结点的黑高；根结点的黑高就是红黑树的黑高。</p>
<ul>
<li>从根结点到叶结点的最长路径不大于最短路径的两倍。当根到叶子的路径最短，必然都由黑结点构成；路径最长，路径必然由红黑结点相间构成，红黑结点数量相同。</li>
<li>有n个内部结点的红黑树高度h&lt;=2log(n+1)。因为由上一条结论，从根到叶子结点至少有一半是黑结点，所以树的黑高至少为h/2，考虑结点最少的情况，就是结点全黑，那么高度就是黑高，所以结点数n&gt;=2^(h/2)-1（二叉树定理）。</li>
</ul>
<p>红黑树放宽了平衡的定义，只要求任意结点的左右子树高度差不超过两倍，从而降低调整频率。</p>
<h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><p>按照排序二叉树的方式插入后，进行调整。</p>
<p>新插入的结点，初始着色为红色，防止破坏黑高相等的性质。</p>
<p>如果新结点的双亲是黑色的，无需调整。<br>如果新结点是作为根结点插入，将z调整为黑色。<br>如果新结点的双亲是红色的，分三种情况：1）(LRB)新结点z是右孩子，z的叔结点（双亲的兄弟结点）y是黑色的，对z先左旋，再右旋；2）(LLB)新结点z是左孩子，z的叔结点（双亲的兄弟结点）y是黑色的，对z的双亲结点右旋，交换z原双亲结点和爷结点的颜色；</p>
<p><img src="/2022/08/15/DA-6/20.jpg" alt="场景"></p>
<p>上面说的都是z的双亲为爷结点左孩子的情况，如果z的双亲是爷结点的右孩子，那么就是对称的情况：先右旋再左旋(RLB)和左单旋(RRB)。</p>
<p>3）z的叔结点是红色。爷结点着色为红色，双亲和叔结点着色为黑色，然后将爷结点作为新的z来重复，也就是上移了两层。(LRR, LLR)</p>
<p><img src="/2022/08/15/DA-6/21.jpg" alt="场景"></p>
<p>如果双亲结点是右孩子，同样还有两种对称情况。</p>
<p><img src="/2022/08/15/DA-6/22.jpg" alt="场景"></p>
<h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p>按照二叉排序树的方法进行删除，设替代删除结点的是x，其兄弟结点为w，下面是在已经删除好的结点上做调整的过程。</p>
<blockquote>
<p>如果待删除结点有两个孩子，不管是红色还是黑色，那么需要替换后（颜色也要替换）删除替换结点，该结点要么是叶子结点，要么只有一个孩子；如果待删除结点只有一个孩子，直接删除后用它的孩子替换（颜色变为和删除结点一致）。<br><img src="/2022/08/15/DA-6/23.jpg" alt="场景"></p>
</blockquote>
<p>如果待删除结点没有孩子，需要分颜色讨论；</p>
<blockquote>
<p>如果待删除结点是红色，可以直接删除；</p>
<p>如果待删除结点是黑色，那么设待删除结点为y，x是用来替代它的结点，w是x的兄弟结点。进行删除后，为了保证所有路径上黑色结点数量相同，先将x着色为双重的黑色，问题就转化成将x变成正常结点。下面有四种情况。</p>
<blockquote>
<p>w是红色的。由于红黑树的性质，w的双亲和孩子一定是红色的，所以交换w和双亲结点的颜色，并对w做左旋，转换为其他情况；<br><img src="/2022/08/15/DA-6/24.jpg" alt="场景"><br>w是黑色，且w的左孩子是红色，右孩子是黑色。交换w和左孩子的颜色，对w的左孩子做右旋，作为新的w，转换为下一种情况；<br><img src="/2022/08/15/DA-6/25.jpg" alt="场景"><br>w是黑色的，w的右孩子是红色的。交换w和父结点的颜色，w的右孩子变为黑色，对w做左旋，并将x着色为单重黑色。<br><img src="/2022/08/15/DA-6/26.jpg" alt="场景"><br>w是黑色，且w两个孩子都是黑色。将x和w都去掉一层黑色，x由双重黑色变为黑色，w由黑色变为白色，在他们的双亲结点上加上一层黑色，并将这个双亲结点作为新的x循环；而且如果这个双亲结点是红色（情况一转化后变为这种情况），着一层黑色就变为黑色即可，终止循环。<br><img src="/2022/08/15/DA-6/27.jpg" alt="场景"></p>
<blockquote>
<p>以上仍然是x作为左孩子的情况，作为右孩子时也有对称的四种情况</p>
</blockquote>
</blockquote>
</blockquote>
<p>上面框中的四种情况，只有情况四可能一直重复最多log(n)次（每次上升一层），前面三种情况最多三次旋转后就会停止。因为情况四是唯一能够将任务推给双亲结点的情况，其他三种情况因为w或者w的孩子中有红色，只能在以双亲为根的子树中调整。</p>
<p><img src="/2022/08/15/DA-6/28.jpg" alt="场景"></p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>多路平衡查找树，定义为满足如下特性的m叉树：</p>
<ul>
<li>每个结点至多有m棵子树，至多有m-1个关键字；</li>
<li>如果根结点不是终端结点，至少有两棵子树；</li>
<li>除根结点外的所有非叶子结点，至少有m/2取上界的子树，至少有m/2取上界-1的关键字；</li>
<li>非叶子结点的结构如下：<br><img src="/2022/08/15/DA-6/29.jpg" alt="场景"><br>其中k是结点的关键字，按升序排列；p为指向子树根结点的指针，p[i-1]指向子树的关键字均小于k[i]；n是结点中关键字的个数。</li>
<li>所有叶子结点在同一层次上，而且不带信息；</li>
</ul>
<p>B树是所有结点平衡因子都是0的多路平衡查找树。</p>
<p><img src="/2022/08/15/DA-6/30.jpg" alt="场景"><br>上面的五阶B树有以下性质：</p>
<ul>
<li>结点孩子数等于关键字数+1；</li>
<li>根结点没有关键字，树空；有关键字，子树必定大于等于两棵；</li>
<li>除根结点外的非终端结点，至少有5(m)/2向上取整=3棵子树，至多有五棵子树；</li>
<li>所有叶子结点都在第四层，代表查找失败结点。（虚构不存在）</li>
</ul>
<h3 id="B树高度"><a href="#B树高度" class="headerlink" title="B树高度"></a>B树高度</h3><p>B树高度不包括叶子结点一层。设一棵B树包含n个关键字，高度为h，阶数为m：</p>
<ul>
<li>每个结点最多有m棵子树，m-1个关键字，所以关键字个数n应该满足上界：<br><img src="/2022/08/15/DA-6/31.jpg" alt="场景"></li>
<li>让每个结点的关键字数最少，可以找到关键字个数n的下界，第一层至少一个结点，第二次至少两个结点，除根结点外的每个非终端结点至少有m/2取上界棵子树，所以第三层至少2*(m/2)取上界个结点，第h+1层（叶子结点层）至少有结点数：<br>  <img src="/2022/08/15/DA-6/32.jpg" alt="场景"><br>  又因为查找不成功结点（叶子结点数）等于n+1，所以有：<br>  <img src="/2022/08/15/DA-6/33.jpg" alt="场景"><br>  得到h的上界。</li>
</ul>
<h3 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h3><p>与二叉查找树类似，只是子树有多路分支。B树存储在硬盘中，先找到目标结点读取到内存，然后在结点内使用顺序查找或者折半查找内存中的有序表，如果没找到，则去对应指针信息指向的子树中查找，直到找到失败结点。</p>
<h3 id="插入-3"><a href="#插入-3" class="headerlink" title="插入"></a>插入</h3><p>1）定位，用前面查找的办法，会找到待插入结点对应的叶子结点（失败结点）和其对应的上一层，最底层非叶子结点；<br>2）插入，检查待插入结点的关键字个数，如果插入后关键字个数大于m-1，需要进行分裂；否则可以直接插入；<br>3）分裂，取一个新的结点，在插入关键字的后的原结点，从中间m/2取上界位置，分为两部分，左边部分放在原结点中，右边包含新关键字的部分放到新结点中，m/2取上界位置的结点插入原结点的父亲结点上，多出来的指针指向新结点作为原结点的兄弟存在；如果插入父亲结点又使得父亲结点关键字个数超过上限，则对父亲结点进行相同的分裂操作；<br>    <img src="/2022/08/15/DA-6/34.jpg" alt="场景"></p>
<h3 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h3><p>与插入操作类似，不过要使得删除后的结点关键字个数大于下界，要采用合并操作。</p>
<p>如果被删除关键字k不在终端结点（最底层非叶子结点），用k的前驱k’替代k，然后删除k’，因为k’一定在某个终端结点中，所以就转化成了删除k在终端结点中的情况；</p>
<p>如果被删除关键字k在终端结点中，分三种情况：</p>
<ul>
<li><p>如果k所在结点关键字个数删除后仍然满足，可以直接删除；<br><img src="/2022/08/15/DA-6/36.jpg" alt="场景"></p>
</li>
<li><p>如果k所在结点关键字个数删除后不满足，但兄弟结点的的关键字个数足够，那么将父亲结点中相邻大小的关键字和兄弟结点相邻大小的关键字进行替换，父亲结点替换下来的关键字送给删除后不足够的结点；</p>
</li>
<li>如果k所在结点关键字个数删除后不满足，而且兄弟结点也能借走，就将关键字删除后与相邻兄弟结点以及双亲结点的关键字进行合并，让双亲结点的关键字移动到下层，和删除后剩下的关键字，以及兄弟结点的关键字，组成满足定义的新的结点。如果双亲结点是根结点，关键字个数合并后减1，变成0，直接删除，让合并后的新结点替代根结点的位置；如果双亲结点不是根结点，关键字个数又减少到不满足定义，就重复上面的合并操作，直到满足定义；<br><img src="/2022/08/15/DA-6/35.jpg" alt="场景"></li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树的要求比较低，掌握原理即可。B+树是一种B树的变形，满足以下条件：<br><img src="/2022/08/15/DA-6/37.jpg" alt="场景"><br><img src="/2022/08/15/DA-6/38.jpg" alt="场景"><br><img src="/2022/08/15/DA-6/39.jpg" alt="场景"></p>
<p>由于B+树一个指针头指向关键字有序序列，可以用顺序查找（链表不方便用折半查找）；另一个指针头指向根结点，可以使用多路查找（类似B树）。B+树的插入删除也类似B树，但是在非叶子结点中找到记录时，还要继续下降到叶子结点中，所以每次查找都是一条从树根到叶子的路径。</p>
<p>对比B树，B+树的优点是：</p>
<ul>
<li>层级更少，查询快速；</li>
<li>非叶子节点仅做索引，关键字全部在叶子节点中，使得查询速度稳定；</li>
<li>叶子节点顺序保存了所有关键字，方便查询，数据紧密性高；</li>
<li>遍历全部数据只需要遍历叶子节点，有利于数据库全盘扫描。</li>
</ul>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>散列函数，把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr；<br>当散列函数把不同关键字映射到同一个地址，就是发生了冲突。</p>
<p>散列表，根据关键字直接进行访问的数据结构，建立关键字和存储地址之间的一种直接映射关系；理想情况下散列表查找任何元素都是随机存取，即常数级时间复杂度。</p>
<h2 id="散列函数的构造"><a href="#散列函数的构造" class="headerlink" title="散列函数的构造"></a>散列函数的构造</h2><p>散列函数的构造遵循几个规则：</p>
<ul>
<li>散列函数的定义域要包括全部关键字，值域取决于散列表大小；</li>
<li>散列函数计算的地址应该尽可能均匀分布在空间中，减少冲突；</li>
<li>散列函数应该尽量设计地简单计算；</li>
</ul>
<h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>直接取关键字的某个线性函数值为地址，散列函数形式为：<br><img src="/2022/08/15/DA-6/40.jpg" alt="场景"><br>适合关键字分布基本连续的情况，如果不连续会造成空间浪费。<strong>适合查找表较小</strong>且连续的情况。</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>散列表表长m，取一个不大于m但接近m的质数p，防止因为关键字可能得到相同的地址从而造成冲突。通过取模运算得到地址：<br><img src="/2022/08/15/DA-6/41.jpg" alt="场景"></p>
<h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>设关键字是r进制，r个数码在各位上出现的频率不一定相同，选择其中的r个数字作为地址，关键字改变，要重新构造。<strong>适合</strong>处理知道<strong>关键字分布</strong>，且关键字<strong>位数比较大的情况</strong>。</p>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>取关键字平方的中间某几位作为散列地址，视情况而定。<strong>适合</strong>于<strong>不知道关键字的分布</strong>，而<strong>位数又不是很大</strong>的情况。</p>
<h2 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h2><p>发生冲突时，应该考虑为冲突的关键字寻找到一个空的地址，用Hi表示处理冲突中第i次探测得到的散列地址，每次冲突就让i+1，寻找下一个不冲突的地址。</p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p><img src="/2022/08/15/DA-6/42.jpg" alt="场景"><br>增量序列有四种取法：<br>1）线性探测法，d从0开始依次+1，冲突发生的时候顺序查看表中下一个地址单元，当探测到表尾地址m-1，下一个地址单元是0，直到找到一个空闲的地址。这样可能使得关键字聚集在某个地方，降低查找效率。</p>
<p>2）平方探测法，d取值如下：<br><img src="/2022/08/15/DA-6/43.jpg" alt="场景"><br>其中k&lt;=m/2，有<a href="http://vlado.fmf.uni-lj.si/vlado/papers/QuadHash.pdf">定理</a>表明，散列表长度m能表示成4k+3的素数时，可以探测到所有单元。这样可以避免堆积的问题，但是如果不满足定理条件，则不能探测到所有散列表上的单元。</p>
<p>3）双散列法，使用两个散列函数，第一个函数得到的地址冲突，再利用第二个函数计算地址增量。最多经过m-1次就会遍历整个表。<br><img src="/2022/08/15/DA-6/44.jpg" alt="场景"></p>
<p>4）伪随机序列法，d取值伪随机序列。</p>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>把所有冲突的关键字存储到一个线性链表中，链表由散列地址唯一标识。<br><img src="/2022/08/15/DA-6/45.jpg" alt="场景"><br>适用于经常插入和删除表的情况。</p>
<h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><p>查找方式就是根据关键字和函数映射，计算出散列地址Addr。<br>访问Addr，检查是否有记录，没有记录则查找失败；有记录则比较关键字是否相等，相等时查找成功，不相等可能是发生冲突被移动了，转到下一步。</p>
<p>用给定的冲突处理方法找到下一个散列地址，转入上一步。</p>
<h2 id="平均查找长度-1"><a href="#平均查找长度-1" class="headerlink" title="平均查找长度"></a>平均查找长度</h2><p>比较次数就是平均查找长度，不同的冲突处理方法得到的散列表不同，平均查找长度也不同。<br>以下面12个元素，线性探测和模13构造的散列表为例：<br><img src="/2022/08/15/DA-6/46.jpg" alt="场景"><br>查找84的过程为先计算散列地址84%13=6，查找地址6存储的元素19不等于84，找下一个线性探测的位置，m=16，(6+1)%16=7，7存储的元素20不等于84，找到下一个位置(6+2)%16=8，相等，查找成功，总共进行了3次比较。</p>
<p>采用上面这样的方式得到下面各个关键字的比较次数：<br><img src="/2022/08/15/DA-6/47.jpg" alt="场景"><br>总共12个关键字，设查找每个关键字概率相等，统计所有比较此时并乘以访问概率：<br><img src="/2022/08/15/DA-6/48.jpg" alt="场景"></p>
<h2 id="散列表总结"><a href="#散列表总结" class="headerlink" title="散列表总结"></a>散列表总结</h2><p>1）虽然存储位置和关键字能之间映射，但是仍然要通过比较的方式解决冲突问题，所以要以ASL为准；<br>2）散列表的查找效率取决于散列函数、处理冲突方法和装填因子。其中装填因子α=元素数n/散列表长度m。而散列表的ASL依赖于α，不直接依赖于n或m，α越大，越容易发生冲突，反之越不容易冲突。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法复习（6）图</title>
    <url>/2022/08/07/DA-5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章介绍图这种数据结构。图相关的算法重点是深度优先搜索(DFS)和广度优先搜索(BFS)；对图本身要掌握基本概念和性质，以及存储结构及其转化，在存储结构上的操作。重在掌握思想方法。<br><img src="/2022/08/07/DA-5/26.jpg" alt="场景"><br><span id="more"></span></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>图<em>G</em>由顶点集<em>V</em>和边集<em>E</em>组成，记为<em>G = (V,E)</em>，其中<em>V(G)</em>表示图G中顶点的有限非空集；<em>E(G)</em>表示图G中顶点之间的关系集合。<br><em>|V|，|E|</em>分别表示顶点数和边数。</p>
<blockquote>
<p>线性表和树都可以是空的，但是图不能为空，即顶点集非空，边集可以为空。</p>
</blockquote>
<ul>
<li>有向图：<em>E</em>是有向边的集合，图就是有向图。其中有向边是顶点有序对<em><v,w></v,w></em>，<em>v</em>是弧头，<em>w</em>是弧尾。</li>
<li>无向图：<em>E</em>是无向边的集合，图就是无向图。其中无向边是顶点无序对<em>(v,w)</em>，两者可以调换位置。</li>
<li>简单图：如果图没有重复边，没有顶点自环，那么就是简单图；</li>
<li>多重图：如果两个顶点边数大于1条，且允许顶点自环，图就是多重图；</li>
<li>完全图：在任意两个顶点之间都存在边；对无向图共有<em>n(n-1)/2</em>条边；有向图共有<em>n(n-1)</em>条边；</li>
<li>子图：设有两个图<em>G(V,E)</em>和<em>G1(V1,E1)</em>，如果其中一个图的边集和顶点集都分别是另一个图边集和顶点集的子集，该图就是另一个图的子图；</li>
<li>连通：无向图中如果从顶点<em>v</em>到顶点<em>w</em>有路径存在，那么<em>v</em>和<em>w</em>就是连通的；</li>
<li>连通图：无向图中任意两个顶点都是连通的，就是连通图；</li>
<li>连通分量：无向图中的极大连通子图称为连通分量；下图中左图一共有三个连通分量；<blockquote>
<p>一个非连通图有n个顶点，最多有n-1条边；加入任意一条边就变成连通图</p>
</blockquote>
</li>
</ul>
<p><img src="/2022/08/07/DA-5/1.jpg" alt="场景"></p>
<ul>
<li>强连通：在有向图中，如果从顶点<em>v</em>到顶点<em>w</em>和从<em>w</em>到<em>v</em>都有路径存在，这两个点就是强连通的；</li>
<li>强连通图：有向图中任意顶点都是强连通的，图就是强连通图；</li>
<li><p>强连通分量：有向图中的极大强连通子图就是强连通分量；</p>
<blockquote>
<p>一个有向连通图最少需要n条边，构成一个环路；</p>
</blockquote>
</li>
<li><p>生成树：连通图的生成树是包含图中全部顶点的极小连通子图；顶点数为n的生成树含有n-1条边，少一条变成非连通图，多一条变成一个回路；</p>
</li>
<li>生成森林：在非连通图中，连通分量的生成树构成了非连通图的森林；</li>
<li>度：顶点<em>v</em>的度指顶点连接的边数<em>TD(v)</em>。无向图的顶点度之和等于边数的两倍；</li>
<li>入度和出度：有向图中入度是以顶点为终点的有向边数目；出度是以顶点为起点的有向边数目；度等于入度和出度之和；有向图的入度和出度相等，并且等于边数。</li>
<li>边权：图上每条边的权值叫做边权；带权图也称为网；</li>
<li>稠密图和稀疏图：边数很少就是稀疏图(一般|E|&lt;|V|log|V|)；边数很多就是稠密图；</li>
<li>路径：从顶点<em>v</em>到顶点<em>w</em>之间的的路径序列；</li>
<li>路径长度：路径上边的数目；</li>
<li>回路：第一个顶点和最后一个顶点相同的路径就是回路（环）；</li>
<li>简单路径：路径序列中顶点不重复；</li>
<li>简单回路：除第一个和最后一个顶点外其余顶点不重复的回路；</li>
<li>距离：两个顶点之间最短路径的长度；若不存在则是无穷；</li>
<li>有向树：图中一个顶点入度为0，其他入度均为1的有向图。</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>对于非带权图：<br><img src="/2022/08/07/DA-5/2.jpg" alt="场景"></p>
<p>对于带权图：<br><img src="/2022/08/07/DA-5/3.jpg" alt="场景"></p>
<p>邻接矩阵和图的关系可以用下图表示：<br><img src="/2022/08/07/DA-5/4.jpg" alt="场景">：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxVertexNum 100</span><br><span class="line">typedef char VertexType;</span><br><span class="line">typedef int EdgeType;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    VertexType Vex[MaxVertexNum];</span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    int vexnum, arcnum;//当前顶点数和弧数；</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
<p>邻接矩阵有以下特点：</p>
<ul>
<li>无向图的邻接矩阵是对称矩阵；</li>
<li>对无向图，第i行非零元素个数就是顶点i的度；</li>
<li>对有向图，第i行非零元素个数是出度，第i列非零元素个数是入度；</li>
<li>邻接矩阵只适合稠密图；</li>
<li>邻接矩阵的n次幂的元素等于从顶点i到顶点j的长度为n的路径数；</li>
<li>求两个顶点有没有连边容易，求顶点有多少邻边效率低。</li>
</ul>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>给每个顶点建立一个单链表，结点表示顶点连接的边（有向图中是以顶点为起始的边），也就是顶点i的边表。边表的头指针和顶点的数据信息采用顺序存储。所以邻接表中有顶点表结点和边表结点。<br><img src="/2022/08/07/DA-5/5.jpg" alt="场景"><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MaxVertexNum 100</span><br><span class="line">//边表结点</span><br><span class="line">typedef struct ArcNode&#123;</span><br><span class="line">    int adjvex;</span><br><span class="line">    struct ArcNode *next;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line">//顶点表结点</span><br><span class="line">typedef struct VNode&#123;</span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *first;</span><br><span class="line">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class="line">//邻接表</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure></p>
<p>邻接表有以下特点：</p>
<ul>
<li>无向图中每条边在邻接表中出现了两次；有向图中每条边只出现一次；</li>
<li>邻接表能节省稀疏图的存储空间；</li>
<li>求顶点出度可以计算邻接表的结点数，求入度需要遍历整个表；</li>
<li>邻接表不唯一，因为边表结点顺序不确定；</li>
<li>求顶点邻边容易，求两点连边效率低。</li>
</ul>
<h3 id="十字边表"><a href="#十字边表" class="headerlink" title="十字边表"></a>十字边表</h3><p>存储有向图的链式结构，每条弧和每个顶点都建立一个结点：<br><img src="/2022/08/07/DA-5/6.jpg" alt="场景"></p>
<p>其中对弧结点，尾指针和头指针分别指向弧尾和弧头两个顶点的位置；hlink指向弧头相同的下一条弧；tlink指向弧尾相同的下一条弧；info存储弧的信息；这样存储弧头相同和弧尾相同的弧分别在一个链表上。</p>
<p>对顶点结点，data存放顶点数据信息，firstin和firstout分别指向以该顶点为弧头和弧尾的第一个弧结点（第一个没有定义，图中是按照序号定义）。<br><img src="/2022/08/07/DA-5/7.jpg" alt="场景"></p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>存储无向图的链式结构，边和顶点的结点结构如下：<br><img src="/2022/08/07/DA-5/8.jpg" alt="场景"><br><img src="/2022/08/07/DA-5/9.jpg" alt="场景"></p>
<p>mark为标志域，标记边是否被搜索过；ivex和jvex是边连接的顶点的位置；ilink指向下一条顶点ivex连接的边；jlink指向下一条顶点jvex连接的边；info存储边信息；</p>
<p>data存储顶点信息；firstegde指向第一条顶点连接的边；</p>
<p><img src="/2022/08/07/DA-5/10.jpg" alt="场景"></p>
<p>对无向图，邻接多重表和多重表区别只在于邻接表中同一条边用两个结点表示；而多重表只用一个结点，但该结点同时在边连接的两个顶点的链表中。</p>
<h2 id="图基本操作"><a href="#图基本操作" class="headerlink" title="图基本操作"></a>图基本操作</h2><p><img src="/2022/08/07/DA-5/11.jpg" alt="场景"></p>
<ul>
<li>遍历：DFS, BFS。</li>
</ul>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>BFS(Breadth-First-Search)，访问起始顶点<em>v</em>，然后依次访问它的所有邻接顶点，再进而访问邻接顶点的临界顶点，直到图中所有顶点都访问过；如果有不连接的顶点，则再选择一个进行重复。也就是依次访问距离起始顶点距离为1，2，……的所有顶点。</p>
<p>类似树层序遍历，要借助队列完成。访问一个节点的同时，将它所有的邻居入队，并且从根节点开始访问，这样就可以借助队列先进先出的特点按顺序访问邻居，然后再访问邻居的邻居。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br><span class="line">void BFSTraverse(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = FLASE;</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    for (int i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            BFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS(Graph G, int v)</span><br><span class="line">&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visit[v] = TRUE;</span><br><span class="line">    EnQueue(Q,v);</span><br><span class="line">    while(!isEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(Q,v);</span><br><span class="line">        for(w = FirstNeighbor(G,v); w&gt;=0; w = NextNeighbor(G,v,w))</span><br><span class="line">        &#123;</span><br><span class="line">            if(!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                visit(w);</span><br><span class="line">                visited[w] = TRUE;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>图的BFS遍历可以看作二叉树层序遍历的推广。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>空间复杂度：队列最大需要存储所有顶点编号，所以是O(|v|)；<br>时间复杂度：采用邻接矩阵，遍历一遍顶点且遍历顶点对应的行/列，所以是O(|V|^2)；采用邻接表，要遍历顶点结点和对应边表，所以是O(|V|+|E|)；</p>
<h3 id="BFS求单源最短路径"><a href="#BFS求单源最短路径" class="headerlink" title="BFS求单源最短路径"></a>BFS求单源最短路径</h3><p>下面是一个对非带权图的算法：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void BFS_min_distance(Graph G, int u)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; G.vernum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i] = Inf;//d[i]是从u到i的最短路径</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = TRUE;</span><br><span class="line">    d[u] = 0;</span><br><span class="line">    EQueue(Q,u);</span><br><span class="line">    while(!isEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(Q,u);</span><br><span class="line">        for (w = FirstNeighbor(G,u); w &gt;= 0; w = NextNeighbor(G,u,w))</span><br><span class="line">        &#123;</span><br><span class="line">            if(!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                visited[w] = TRUE;</span><br><span class="line">                d[w] = d[u] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        EnQueue(Q,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h3><p>广度遍历得到的生成树。邻接矩阵表示的图有唯一广度优先生成树；邻接表表示的图不唯一。</p>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>DFS(Depth-First-Search)，首先访问一个起始顶点<em>v</em>，然后访问其任意邻居，重复，直到目标顶点没有还未访问的邻居，然后退回到最近的上一个顶点再重复，直到所有顶点完成访问。代码上我们借助递归来实现，从根节点开始访问邻居节点，直到节点没有邻居再返回函数值。</p>
<p>当然前面学习树的遍历时我们知道，递归也可以用栈来实现，每次访问时将节点入栈，如果节点没有邻居，那么取栈顶元素继续访问，直到节点全部都被访问过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//递归形式</span><br><span class="line">bool visited[MAX_VERTEX_NUM]；</span><br><span class="line">void DFSTraverse(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    for (int v = 0; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[v] = FLASE;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int v = 0; v &lt; G.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[v])</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(G,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(Graph G, int v)</span><br><span class="line">&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    for (int w = FirstNeighbor(G,v); w &gt;= 0; w = NextNeighbot(G,v,w))</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[w])</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样对于同样一个图，邻接矩阵的遍历序列唯一，但是邻接表不唯一。</p>
<h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>空间复杂度：递归非递归都要借助栈，所以空间复杂度为O(|V|)；<br>时间复杂度：与BFS相同。</p>
<h3 id="深度优先的生成树和生成森林"><a href="#深度优先的生成树和生成森林" class="headerlink" title="深度优先的生成树和生成森林"></a>深度优先的生成树和生成森林</h3><p>同BFS，DFS后也会产生一个深度优先生成树，但是只有对连通图调用DFS才能产生生成树，否则会是森林。如下所示：<br><img src="/2022/08/07/DA-5/12.jpg" alt="场景"></p>
<h2 id="图遍历判断连通性"><a href="#图遍历判断连通性" class="headerlink" title="图遍历判断连通性"></a>图遍历判断连通性</h2><p>对无向图，连通的时候遍历一次就能访问到所有顶点；非连通的时候只能遍历该顶点所在的连通分量。对有向图也是一样的道理。</p>
<p>因此，调用BFS或者DFS的次数就是该图的连通分量数。</p>
<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>图G的所有生成树中，边权和最小的生成树就是最小生成树MST(Minimum-Spanning-Tree)。</p>
<ul>
<li>最小生成树不唯一，只有当生成树的边权和都不相等，才是唯一的；</li>
<li>无向图的边数比顶点数少1，那么G就是他本身的最小生成树；</li>
<li>最小生成树的边数为顶点数减一；</li>
</ul>
<p>最小生成树的算法一般都利用这个性质：<em>U</em>是<em>V</em>的一个非空顶点子集，如果有<em>U</em>中顶点u，<em>V-U</em>中顶点v，且(u,v)是一条具有最小边权的边，那么一定存在一棵包含(u,v)的最小生成树。</p>
<p>首先介绍一个通用的算法：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GENERIC_MST(G)</span><br><span class="line">&#123;</span><br><span class="line">    T = NULL;</span><br><span class="line">    while(not_Tree(T))</span><br><span class="line">    &#123;</span><br><span class="line">        find(最小代价边且加入T后不产生回路);</span><br><span class="line">        T = add(T,(u,v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>初始从图中任取顶点加入树T，然后找到距离顶点集合最近(边权最小)的邻居，将边和点都加入T；直到图中所有顶点都加入了T。此时T中必然有n-1条边。<br><img src="/2022/08/07/DA-5/14.jpg" alt="场景"><br>时间复杂度O(V^2)，与边数无关，所以适合求稠密图的最小生成树。</p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>该算法通过并查集检查环完成，初始时T中只有顶点集没有边集，每个顶点都是单独的连通分量，也就是初始化的并查集；然后按照边权的大小排序所有边，依次权值最小的边，如果这条边连接的顶点在不同连通分量中（加入后不构成回路），也就是并查集find找到root不一致，则将这条边加入T，直到T中所有顶点在一个连通分量中，或者边集有n-1条边。<br><img src="/2022/08/07/DA-5/15.jpg" alt="场景"><br>算法中存放边权通常使用堆，所以找到最小边权的边时间只需要O(log(E))；其它排序方法也可以。此外，生成树T中的所有边可以视为一个等价类，采用并查集描述T，构造T需要O(E*log(E))。时间复杂度与顶点数无关，所以适合处理边稀疏多顶点的图。</p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>无向图路径长度视为路径上的边数；有向图路径长度视为路径上的边权和。从顶点<em>v1</em>到顶点<em>v2</em>的具有最短路径长度的路径就是两点之间的最短路径。</p>
<p>最短路径算法一般使用这个性质：两点之间的最短路径由其他点之间的最短路径构成。Dijkstra算法用来求单源最短路径；Floyd算法用来求每对顶点之间的最短路径。</p>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>设置一个集合S记录求得最短路径的顶点，初始时将起始顶点<em>v</em>加入S，然后在<em>v</em>的所以邻居中，选择距离最近的顶点加入S，并修改记录从<em>v</em>到其他顶点<em>i</em>最短路径长度的数组dist[i]，如果加入的顶点j使得dist[j]+arcs[j][k]&lt;dist[k]，就更新dist[k]；以及记录从<em>v</em>到其他顶点<em>i</em>最短路径的前驱数组path[i]。重复以上操作，直到S中包含了所有顶点。<br><img src="/2022/08/07/DA-5/16.jpg" alt="场景"></p>
<p>时间复杂度：邻接矩阵和邻接表都是O(V^2)；</p>
<p>当边上带有负权值的时候，算法不适用，因为算法的贪心策略认定，在某次选择最小路径长度的时候，目标顶点已经加入了集合S，就已经找到了对应该顶点的最短路径，接下来显然也不会再更新这个点的最短路径，负边的存在却有可能让这个路径变短。如下所示：</p>
<p><img src="/2022/08/07/DA-5/17.jpg" alt="场景"></p>
<p>这种情况下算法先将2加入集合S，1作为最后一个添加的顶点并不会影响2的最短路径。</p>
<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>该算法是一个迭代的过程，定义一个最短路径邻接矩阵，初始时就是图的邻接矩阵，每次迭代时增加一个顶点考虑最短路径，直到所有顶点都考虑过。原理就是矩阵每迭代一次，最短路径都已经更新到考虑某个顶点为中介时的情况，下次迭代就可以在这个基础上进一步考虑另一个顶点做中介的情况，而且还保留了上一个顶点做中介时最短路径长度。</p>
<p>从这一点考虑，Floyd算法实际上采用了动态规划的思想，最短路径邻接矩阵就是一个动态规划数组，且数组之间的关系也明了（取经过中介k和不经过中介的最小路径），初始值也具备（初始邻接矩阵），可以用历史值推出新的矩阵。<br><img src="/2022/08/07/DA-5/18.jpg" alt="场景"><br><img src="/2022/08/07/DA-5/19.jpg" alt="场景"><br>表中有下划线的数字代表更新过的最短路径。</p>
<p>时间复杂度：O(V^3)；</p>
<p>同时Floyd算法也允许带负权的边，但不允许有包含负权边的回路。Dijkstra也可以用来求每对顶点之间的最短路径，对每个顶点都运行一次算法即可，时间复杂度变得和Floyd相同。</p>
<h2 id="有向无环图描述表达式"><a href="#有向无环图描述表达式" class="headerlink" title="有向无环图描述表达式"></a>有向无环图描述表达式</h2><p>有向无环图，有向图中不存在环的图，简称DAG图。这种图可以用来描述含有公共子式的表达式，例如：<br><img src="/2022/08/07/DA-5/20.jpg" alt="场景"><br>相同子式为(c+d)和(c+d)*e，二叉树也可以表示这个式子，但是有向无环图能节省存储空间。<br><img src="/2022/08/07/DA-5/21.jpg" alt="场景"></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>AOV网，用DAG图表示一个工程，顶点表示活动，且规定<v1,v2>有向边表示活动1必须在活动2之前进行，这种图就是顶点表示活动的网络(Activity On Vertex Network)。其中v1是v2的直接前驱，v2是v1的直接后继。任何活动不能作为自己的前驱后继。</v1,v2></p>
<p>拓扑排序，由一个有向无环图顶点组成的序列，如果每个顶点仅出现一次，且当顶点A在序列中排在顶点B前面时图中就不存在从B到A的顶点，这个序列就是图的一个拓扑排序。每个AOV网都有一个或多个拓扑排序。</p>
<p>下面是常用的一种拓扑排序算法：<br>找到AOV网中所有（可能有多个顶点入度为0）没有前驱的顶点并输出，删除这个顶点和以他为起点的有向边，重复前面的步骤直到AOV为空或者网络中不存在无前驱的顶点。后面一种情况说明图中有环存在。<br><img src="/2022/08/07/DA-5/22.jpg" alt="场景"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool TopologicalSort(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    for (int i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(indegree[i] == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(S,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(IsEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        Pop(S,i);</span><br><span class="line">        print[count++] = i;</span><br><span class="line">        for (p = G.vertices[i].firstarc; p; p = p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            v = p-&gt;adjvex;</span><br><span class="line">            if((--indegree[v]) == 0)</span><br><span class="line">                Push(S,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(count&lt;G.vexnum)//有回路失败</span><br><span class="line">        return false;</span><br><span class="line">    else</span><br><span class="line">        return true;//排序成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：邻接表O(V+E)，邻接矩阵O(V^2)；</p>
<ul>
<li>入度为0的顶点，在AOV网中代表活动可以从这里开始，不需要前置活动；</li>
<li>一个顶点有多个直接后继，则拓扑排序结果通常不唯一；每个顶点有唯一的前驱后继时，结果是唯一的；</li>
<li>可以按照拓扑排序的结果重新给AOV网编号，生成邻接矩阵，这种矩阵可以是三角矩阵；但对于一般的图，如果邻接矩阵是三角矩阵，那么一定存在拓扑排序（三角矩阵的有向图肯定没有环）；存在拓扑排序，邻接矩阵不一定是三角矩阵。（注意这里不是有序拓扑排列，有序拓扑排列这两者互为充分必要条件）</li>
</ul>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>AOE网，顶点表示事件，边表示活动，边权代表活动时间开销，称为边表示活动网络(Activity On Edge)。只有在某顶点表示的事件发生后，该顶点出发的有向边活动才能开始；而只有进入某顶点的有向边活动都结束时，该顶点的事件才能发生。</p>
<p>因此，网络中只有一个入度为0的源点，代表工程开始；只有一个出度为0的汇点，代表工程结束。</p>
<p>从源点到汇点的所有路径中，具有最大路径长度的称为关键路径。关键路径的长度就是完成工程的最短时间，这是因为关键活动影响了整个工程的时间，只要找到关键活动，就找到了关键路径。例如有两条边指向同一个顶点，两条边代表的活动要全部完成才能进行顶点代表的事件，所以要找相对长的那一条边作为关键路径。<br><img src="/2022/08/07/DA-5/23.jpg" alt="场景"></p>
<p>关键路径算法设计了五个参数：</p>
<ul>
<li>事件最早发生时间<em>ve(k)</em>：从源点到顶点k的最长路径长度，<strong>决定所有从顶点k开始的活动最早能开始的时间</strong>。计算时可以在拓扑排序的基础上完成，初始时<em>ve</em>的值为0，输出一个入度为0的顶点j时，计算所有直接后继顶点k的最早发生时间，如果j的最早发生时间加上j到其后继边权的长度比k记录的最早发生时间长，那么就更新<em>ve(k)</em>。</li>
</ul>
<blockquote>
<p>人话：找到达每个点最长的路径的边权和</p>
</blockquote>
<ul>
<li>事件最迟发生时间<em>vl(k)</em>：从后往前，<strong>不推迟工程完成时间的前提下，事件发生的最迟时间</strong>。计算在逆拓扑排序的基础上进行，增加一个栈记录拓扑序列，拓扑排序结束后从栈顶到栈底就是逆拓扑排列序列。初始时<em>vl</em>的值和计算后的<em>ve</em>相同，排序完成后直接出栈顶点j，计算其前驱顶点k的最迟发生时间，如果j的最迟发生时间减去j前驱边的边权比k的最迟发生长度小，那么就更新<em>vl(k)</em>。</li>
</ul>
<blockquote>
<p>人话：从最后一个点往前看，找这个点为起点的边，取其中终点的ve(i)减去边权为最小值的</p>
</blockquote>
<ul>
<li>活动最早开始时间<em>e(i)</em>：活动弧的<strong>起点事件的最早发生时间</strong>；</li>
</ul>
<blockquote>
<p>人话：边的起点的ve(i)</p>
</blockquote>
<ul>
<li>活动最迟开始时间<em>l(i)</em>：活动弧的<strong>终点事件的最迟发生时间与该活动所需时间之差</strong>；</li>
</ul>
<blockquote>
<p>人话：边的终点的vl(i)减去这条边的权重</p>
</blockquote>
<ul>
<li>活动最迟开始时间和最早开始时间的差额<em>d(i)</em>：活动完成的余量时间，为零说明活动必须如期完成；所以<em>d(i)</em>为零的活动就是关键活动。</li>
</ul>
<p>算法步骤：<br><img src="/2022/08/07/DA-5/24.jpg" alt="场景"></p>
<p><img src="/2022/08/07/DA-5/25.jpg" alt="场景"></p>
<blockquote>
<p>缩短关键活动可以加快工期，但是缩短到关键活动与其他活动进度相同时，就不能再缩短了；网络中的关键路径也不是唯一的，对于多条关键路径的网络，缩短只在一条路径上的关键活动不能缩短整个工期，只有缩短包含在全部关键路径中的关键活动才能达到目的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GNN的不同聚合方案带来的改进</title>
    <url>/2022/10/04/GNN-improve/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <em>《图嵌入和图神经网络》</em> 一文中，介绍了图表示的三类基本方法，GNN作为GCN延伸的神经网络，是其中十分重要的一类方法，通常将其中介绍的那种GNN称为GCN，不过严格定义的GCN在聚合邻居特征的时候公式上略有不同，结果是一致的。在本文中，受到 <em>Representation Learning on Graphs with Jumping Knowledge Networks</em> 一文的启发，将进一步介绍一些先进GNN的做法，有人将这种做法称为“多跳”邻居的聚合方案。<br><span id="more"></span></p>
<h1 id="GNN的局限"><a href="#GNN的局限" class="headerlink" title="GNN的局限"></a>GNN的局限</h1><h2 id="GNN存在什么问题？"><a href="#GNN存在什么问题？" class="headerlink" title="GNN存在什么问题？"></a>GNN存在什么问题？</h2><p>GNN也并不是一开始就能在所有数据上表现出良好性能的，实际上在一些真实网络上GNN的表现要比传统方法更差。有一个很明显的问题已经被人们注意到了，深度学习往往通过利用深度的网络达到更好的拟合效果，但是GNN在深层网络的效果缺远不如浅层网络，这是非常值得分析的。</p>
<p>实际上，GNN中结点对邻居信息的汇聚意味着重复的“平均”，经过深层迭代以后，所有结点的特征都包含了整个图的特征，这样一来留给结点自己的信息就会越来越少，导致网络完全无法利用这部分信息做出有效的预测。因此，这个空白需要进行填补，这就是JK-net一文中着重介绍的部分，用RandomWalk对比GCN的聚合过程，系统地阐释“平均”效果产生的原因。</p>
<h2 id="Random-Walk与GCN"><a href="#Random-Walk与GCN" class="headerlink" title="Random Walk与GCN"></a>Random Walk与GCN</h2><p>可以考虑这样一件事情，Random Walk从网络中一个结点出发，经过一定步数k后，将有可能给影响到某个范围内的所有结点，这就是距离出发结点k跳的所有结点，假设对所有邻居的访问概率完全相同，那么RW经过一定次数迭代后会收敛，访问所有结点的概率将确定到某个值，将访问不同点的概率定义为Walk Distribution。而GCN聚合同样可以这样考虑，一个结点想要聚合到距离它两跳的结点的信息，同样需要两次聚合，因为只有到第二次聚合的时候，该结点的邻居结点才会带有距离他两跳的结点的信息。进行可视化以后，得到这样的效果：<br><img src="/2022/10/04/GNN-improve/1.jpg" alt="场景"><br>GCN中一层汇聚就相当于RW中走一步，文中用雅可比矩阵定义了Influence Distribution，表示结点y的输入特征对结点x输出特征的影响程度，记为Ix(y)，并证明这个值和Walk Distribution相等，上面的图中方块表示出发点，其他深颜色的点表示值越高的点。</p>
<p>这样，我们可以重新直观地看待“平均”效果，GCN中每层layer都加大了某个点影响与被其他点影响的分布，不管使用的是加权和还是平均等聚合方法，每个结点本身的特征会越来越少，表示全局特征的信息会越来越多，6层的GCN汇聚就涵盖了如此多的点，显然自身信息很难得到保留。</p>
<h2 id="“平均”的坏处？"><a href="#“平均”的坏处？" class="headerlink" title="“平均”的坏处？"></a>“平均”的坏处？</h2><p>前面说，“平均”让GCN难以分辨不同结点的特征，比较笼统，现在我们接着这部分理论完整分析一下， 到底是什么样的结点不需要这种平均。首先，我们将结点分成两种来分析，位于边缘的和位于中心的。<br><img src="/2022/10/04/GNN-improve/2.jpg" alt="场景"><br>中心结点的Influence Distribution扩散很快，而边缘结点刚开始扩散很慢，但是到达中心结点后又快速扩散到周围了。如果这两个点都经过四层的GCN，得到的信息将非常不一致，用前人的数学方法分析，中心结点的RW收敛很快，带有丰富的全局信息和有限的局部信息；而边缘结点的RW收敛很慢，带有有限的全局信息和丰富的局部信息。因此，中心点过快的“平均”会导致信息丢失，但是边缘点却又需要足够的邻居来得到不那么局部的信息。只有在这两者中做出权衡，才有可能达到更好的表示效果，要进一步探索能不能让每个结点选择自己合适的层数。</p>
<h1 id="JK-net"><a href="#JK-net" class="headerlink" title="JK-net"></a>JK-net</h1><p>现在，正式提出JK-net，它能够解决上面的问题，这将从两个方面入手分析。第一，需要记录不同层的信息供结点自己选择；第二，结点如何选择最适合自己的层。</p>
<h2 id="不同层之间的Jump-Connections"><a href="#不同层之间的Jump-Connections" class="headerlink" title="不同层之间的Jump-Connections"></a>不同层之间的Jump-Connections</h2><p>文中提出三种方法记录不同层的特征，分别是concatenation、max-pooling，和LSTM-attention。这里着重介绍max-pooling，因为作者证明了这种聚合能同时解决第二个问题，另外两个暂时不明朗，不过concatenation的做法和DGCNN十分类似，可以作为参考。</p>
<p>Max-pooling通过下面的式子对不同层的特征进行选择：<br><img src="/2022/10/04/GNN-improve/3.jpg" alt="场景"><br>这就是说，对结点v，每个通道选择不同层中最大的特征作为v的特征表示。</p>
<p><img src="/2022/10/04/GNN-improve/4.jpg" alt="场景"></p>
<h2 id="结点如何自动选择"><a href="#结点如何自动选择" class="headerlink" title="结点如何自动选择"></a>结点如何自动选择</h2><p>Max-pooling已经选择了最大的特征作为最合适的表示，在文中作者用中心点来解释。JK-net使用max-pooling，通过自动学习，对非中心点总是将大部分影响尽可能施加在当前结点上，其余影响传播出去(限制在局部上防止丢失信息)；对中心点总是将影响扩散到一个合理的范围(中心点连接的结点多，有可能其中包含另外的中心点)。<br><img src="/2022/10/04/GNN-improve/5.jpg" alt="场景"><br>在本人看来，从网络结构上，其实如何自动选择还是依靠可训练参数矩阵实现的，只不过max-pooling的存在让GNN进一步细化了优化目标实现的方式，多层次信息的存在可以让不同层之间的可训练参数进一步提升自己的表达，而不用为了只得到最后一层的表达进行一定程度的妥协。也就是说，JK-net中不同层之间的参数矩阵完全独立，每个结点的每个特征总是选择最合适的一层进行优化，从而实现了很好的效果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文章指出了GNN存在的关键问题，结合一些已有的优化GNN的做法，系统地分析了原因，并提出了一般的解决方案。下一步的工作是对不同层之间的聚合方式(拼接，最大池化，LSTM等)，不同结点之间的聚合方式(最大，平均，加权和等)，以及这两种方案的不同组合，在不同结构的网络上进一步探索。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Deep Learning</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>GNN</tag>
        <tag>JK—net</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法复习（8）排序</title>
    <url>/2022/08/19/DA-7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章着重排序算法，重点是排序算法，插入排序，交换排序，选择排序，归并排序，基数排序，熟悉排序过程，掌握时间复杂度、稳定性、适用性、初态影响，从而选择最好的排序算法。<br><img src="/2022/08/19/DA-7/1.jpg" alt="场景"><br><span id="more"></span></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li>排序，重新排列表中的元素，使关键字有序的过程；</li>
<li>算法的稳定性，表中有两个元素a1和a2的关键字相同，且a1在a2的前面，如果使用某个排序算法后，a1仍然在a2前面，则该算法是稳定的；否则算法是不稳定的；</li>
<li>内部排序，在排序期间元素全部存放在内存中的排序；</li>
<li>外部排序，在排序期间元素不能全部存放在内存中，必须要在内存和外存之间移动的排序。</li>
</ul>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>基本思想是，每次将一个待排序的记录按照关键字大小插入前面已经排好的子序列中，找到全部记录完成排序。</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InsertSort(ElemType A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(A[i] &lt; A[i-1])</span><br><span class="line">        &#123;</span><br><span class="line">            A[0] = A[i];</span><br><span class="line">            for (j = i-1; A[0] &lt; A[j]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                A[j+1] = A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            A[j+1] = A[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最简单的插入排序，以升序为例，从头往后遍历，如果当前元素小于前一个元素，就将当前元素保存到哨兵A[0]中，并再次遍历前面排序完成的部分，从当前元素的位置-1往前遍历，如果该位置大于要插入的元素，就把这个位置的元素后移，直到找到要插入元素的位置，插入即可。<br><img src="/2022/08/19/DA-7/2.jpg" alt="场景"><br><img src="/2022/08/19/DA-7/3.jpg" alt="场景"><br>括号中的是有序序列。</p>
<p>空间效率：O(1)；<br>时间效率：最好情况O(n)，平均O(n^2)；<br>稳定性：稳定（如上图中的49）；<br>适用性：顺序存储和链式存储的线性表，链式存储要求能从后往前查找元素。</p>
<h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void InsertSort(ElemType A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, low, high, mid;</span><br><span class="line">    for (i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[0] = A[i];</span><br><span class="line">        low = 1; high = i-1;</span><br><span class="line">        while(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / 2;</span><br><span class="line">            if(A[mid] &gt; A[0]) high = mid - 1;</span><br><span class="line">            else low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (j = i - 1; j &gt;= high; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            A[j+1] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        A[high+1] = A[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先折半查找元素的待插入位置，然后统一移动待插入位置之后的所有元素。折半查找的时候，high总是指向待插入位置的前一个位置，low和mid总是指向待插入位置，所以high+1，low，mid都是待插入位置。</p>
<p>空间效率：O(1)；<br>时间效率：O(n^2)，减少了比较的次数；<br>稳定性：稳定；<br>适用性：顺序存储的线性表，链式存储无法进行折半查找。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>每累计d个位置的增量取一个元素，将表分成d个子表，每个子表分别进行直接插入排序，然后逐步减小d，直到d等于1，对整体进行插入排序。<br><img src="/2022/08/19/DA-7/4.jpg" alt="场景"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//升序排列</span><br><span class="line">void ShellSort(ElemType A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int dk = n/2; dk &gt;= 1; dk = dk/2)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = dk + 1; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(A[i] &lt; A[i-dk])</span><br><span class="line">            &#123;</span><br><span class="line">                A[0] = A[i];</span><br><span class="line">                for (int j = i - dk; j &gt; 0 &amp;&amp; A[0] &lt; A[j]; j = j - dk)</span><br><span class="line">                &#123;</span><br><span class="line">                    A[j + dk] = A[j];</span><br><span class="line">                &#125;</span><br><span class="line">                A[j + dk] = A[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间效率：O(1)；<br>时间效率：最坏O(n^2)；<br>稳定性：不稳定（如图中49）；<br>适用性：顺序存储的线性表。</p>
<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p>根据序列中两个关键字的大小进行对换。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从头遍历元素，比较相邻两个元素的大小，如果不满足排序要求，就交换。这样经过第一次遍历后，最大或者最小（取决于排序要求）会被排到最前或者最后面，此时确定这个元素的位置，对剩下的元素进行下一趟排序，n个元素最多经过n-1次排序就能排好。<br><img src="/2022/08/19/DA-7/5.jpg" alt="场景"><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//升序排列</span><br><span class="line">void BubbleSort(ElemType A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; n-1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = false;</span><br><span class="line">        for (int j = n - 1; j &gt; 1; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(A[j-1] &gt; A[j])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(A[j-1], A[j]);</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag == false)//如果一次排序中没有发生交换，说明已经有序。</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>空间效率：O(1)；<br>时间效率：最坏O(n^2)， 最好O(n)；<br>稳定性：稳定，元素相等时不交换；<br>适用性：顺序存储和链式存储的线性表；</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>在待排序表中取一个基准元素（一般取首元素），让小于该元素的所有元素排在基准元素左边，大于该元素的所有元素排在基准元素右边，然后递归地对两边的子表进行相同操作，直到每个子表只有一个元素。</p>
<p>设置两个指针i，j来标记，i从左边开始搜索，j从右边开始搜索，也就是说i负责管理小于基准的元素，j负责管理大于基准的元素，如果j先开始搜索，找到一个小于基准的元素，就要先把他放到i指向的位置（在第一轮中，i初始时指向基准元素，基准元素被中间值保存，直接替换），空出j此时的位置；i开始从作左半边寻找填补空白的元素，搜索到的元素大于基准元素，就应该将这个元素交换到j指向的空位。一直重复这样的操作，直到i和j相等，当然还是空位，所以将之前中间值存放的基准元素填补到这里，就完成了一轮操作。<br><img src="/2022/08/19/DA-7/6.jpg" alt="场景"><br><img src="/2022/08/19/DA-7/7.jpg" alt="场景"><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//递归方法</span><br><span class="line">void QSort(ElemType A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    if(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        int pivotpos = Partition(A, low, high);</span><br><span class="line">        QSort(A,low,pivotpos-1);</span><br><span class="line">        QSort(A,pivotpos+1,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//划分操作以第一个元素作为基准，升序排列</span><br><span class="line">int Partition(ElemType A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    ElemType pivot = A[low];</span><br><span class="line">    while(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        while(low &lt; high &amp;&amp; A[high] &gt;= pivot) high--;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        while(low &lt; high &amp;&amp; A[low] &lt;= pivot) low++;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    return low;//返回存放基准位置的地方</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>空间效率：平均O(log(n))，最坏O(n)，借助了栈；<br>时间效率：最坏O(n^2)，基准选择好，理想情况O(n*log(n))；一般情况下都和理想情况比较接近，快排是内部排序算法中性能最好的算法；<br>稳定性：不稳定；<br>适用性：顺序存储的线性表。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>遍历待排序元素，每次找到最小或最大的元素，然后依次存放，直到遍历了n-1次。</p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SelectSort(ElemType A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; n-1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        for (int j = i+1; j &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(A[j] &lt; A[min])</span><br><span class="line">            &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            if(min != i)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(A[i], A[min]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间效率：O(1)；<br>时间效率：始终是O(n^2)；<br>稳定性：不稳定；<br>适用性：顺序存储。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>遍历找到最值不方便，采用堆来维护。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>如果n个关键字序列满足：<br><img src="/2022/08/19/DA-7/8.jpg" alt="场景"><br>上述关系是完全二叉树的位置关系，满足第一个条件的是大顶堆（根结点最大），满足第二个条件是小顶堆（根结点最小）。不同于排序二叉树，堆不要求左右子树区分大小，只要求根结点大于子树结点。</p>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>元素不必实际存入二叉树，可以根据下标进行调整。从最后一个叶子结点开始，以它的双亲结点开始，如果结点小于孩子，就同孩子中较大的值进行交换，使这个根结点构成的子树称为一个堆，然后慢慢往前重复，直到找到整个树的根结点。<br><img src="/2022/08/19/DA-7/9.jpg" alt="场景"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void BuildMaxHeap(ElemType A[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = len / 2; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出元素后调整"><a href="#输出元素后调整" class="headerlink" title="输出元素后调整"></a>输出元素后调整</h4><p>选择排序取走堆顶后，需要继续调整。将最后一个元素和堆顶交换，显然最后一个元素很小，所以要从堆顶开始，交换成孩子中的较大值，交换后破坏了被交换孩子的堆性质，再次重复，直到完成调整。<br><img src="/2022/08/19/DA-7/10.jpg" alt="场景"><br>上面的堆输出87后调整过程如上图。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void HeadAdjust(ElemType A[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    for(i = 2*k; i &lt;= len; i = i*2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i &lt; len &amp;&amp; A[i+1]) i++;</span><br><span class="line">        if(A[0] &gt;= A[i]) break;</span><br><span class="line">        else&#123;</span><br><span class="line">            A[k] = A[i];</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void HeapSort(ElemType A[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    BuildMaxHeap(A, len);</span><br><span class="line">    for(int i = len; i &gt; 1; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(A[i], A[1]);</span><br><span class="line">        HeapAdjust(A, 1, i-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排序在堆的基础上进行，构建好堆以后，从堆顶开始输出最大的元素，输出后交换堆顶（空）和最后一个元素，调整剩下的i-1个元素，重复操作直到堆中只剩下一个元素，输出，就完成了堆排序。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>堆还支持插入的操作，新增最后一个结点，然后往上调整即可。<br><img src="/2022/08/19/DA-7/11.jpg" alt="场景"></p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>堆也支持修改元素值的操作，根据修改元素位置的不同，操作方法也不同。如果是修改叶子结点，那么按照插入一个值的方法进行相同调整，从下往上；如果修改内部结点，可以按照排序的方法重新排序，也可以根据修改结点大小与其双亲和孩子结点的大小关系，在大顶堆中，小于孩子就往下调整，大于双亲就往上调整，否则不调整。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>空间效率：O(1)；<br>时间效率：均为O(n*log(n))；<br>稳定性：不稳定；<br>适用性：顺序存储的线性表。</p>
<h1 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并指的是将两个或两个以上的有序表合并成一个有序表，对于n个元素的序列，可以视为n个有序的子表，然后两两合并，直到合并成一个长度为n的有序表为止，也就是二路归并排序。<br><img src="/2022/08/19/DA-7/12.jpg" alt="场景"><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//合并两个相邻的有序子表，在数组中标记为low-mid，mid+1-high</span><br><span class="line">ElemType *B = (ElemType *)malloc(siezof(ElemType) * (n+1));</span><br><span class="line"></span><br><span class="line">void Merge(ElemType A[], int low, int mid, int high)</span><br><span class="line">&#123;</span><br><span class="line">    //辅助数组复制</span><br><span class="line">    for(int k = low; k &lt;= high; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        B[k] = A[k];    </span><br><span class="line">    &#125;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    for(i = low, j = mid + 1, k = i; i &lt;= mid &amp;&amp; j &lt;=&gt;= high; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        //比较两个子表的元素大小，进行复制</span><br><span class="line">        if(B[i] &lt;= B[j])</span><br><span class="line">        &#123;</span><br><span class="line">            A[k] = B[i];</span><br><span class="line">            //复制完成后要记得将指针位置移动到被复制数组的下一个位置</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            A[k] = B[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt;= mid) A[k++] = B[i++];</span><br><span class="line">    while(j &lt;= high) A[k++] = B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用辅助数组记录两个数组，每次从两个子表中分别取出一个关键字，比较大小，将较小的关键字放到原数组中子表开始的位置，然后被取出数组指向下一个位置的关键字继续比较，重复直到比较完一个表，然后根据此时指针指示的位置，检查另一个表是否有剩余关键字，如果有，就将他们按顺序全部复制到原来的表中。</p>
<p>上面的算法将被用来对整个数组进行二路归并排序。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void MergeSort(ElemType A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    if(low &lt; high)//至少子表有两个元素时，进行下面的操作</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        MergeSort(A,low,mid);//左子表递归归并</span><br><span class="line">        MergeSort(A,mid+1,high);//右子表递归归并</span><br><span class="line">        Merge(A,low,mid,high);//左右子表合并</span><br><span class="line">    &#125;</span><br><span class="line">    //return 返回上一层递归调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2022/08/19/DA-7/13.jpg" alt="场景"></p>
<p>空间效率：O(n)；<br>时间效率：O(n*log(n))；合并一次时间复杂度为O(n)，一共要合并log(n)取上界次；<br>稳定性：稳定；<br>适用性：顺序存储。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基于关键字的大小进行排序，借助多关键字逻辑对单逻辑关键字进行排序的方法。</p>
<p>假设线性表中每个元素关键字由一个d元组构成，这个d元组左边是高位，右边是低位，且高位一定大于低位，不论该位上实际的大小情况；即d元组中左边的一定大于右边的。称最高位关键字是最主位关键字，最低为关键字是最次位关键字。基数r指的是d元组中每个关键字可能出现的情况种数。例如，d元组是一个十进制三维数，即d=3，r=10，百位就是最主位关键字，个位就是最次位关键字，每个位最多有r=10中情况，0~9。</p>
<p>另外，多关键字排序有两种方法，最高位优先(MSD)按关键字权重递减划分子序列，最低位优先(LSD)按关键字递增划分子序列。</p>
<h3 id="LSD"><a href="#LSD" class="headerlink" title="LSD"></a>LSD</h3><p>构建r个队列，分别对每个关键字的d元组的每个位进行一次分配，从最低位开始，如果该位等于某个小于r的值，就把他放进对应的队列中；分配完成后进行收集，将所有队列中的结点首尾相连，得到新的序列，组成新的线性表，就完成了第一次排序。<br><img src="/2022/08/19/DA-7/14.jpg" alt="场景"><br>之后重复这项操作，直到查看完最主位关键字。<br><img src="/2022/08/19/DA-7/15.jpg" alt="场景"><br><img src="/2022/08/19/DA-7/16.jpg" alt="场景"></p>
<p>空间效率：O(r)；需要r个指向队列的头指针和r个尾指针；<br>时间效率：O(d(n+r))；d次排序，每次需要O(n)的分配和O(r)的收集，和初始状态无关；<br>稳定性：稳定；<br>适用性：链式存储的线性表。</p>
<h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><p>外部排序在算法设计上比较复杂，不过可能会考相关概念方法。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>前面的排序方法都是在内存中进行，称为内部排序。而对于许多大文件，需要在排序时一部分一部分地将记录调入内存，需要进行内存和外存之间的交换，所以叫外部排序。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>由于访问外存的速度远远小于访问内存，所以访问磁盘次数为主要的时间代价。</p>
<p>通常采用归并排序，根据内存缓冲区大小，将外存的文件分为许多子文件，依次读入内存并采用内部排序方法排序，然后重新写回外存。这些有序子文件称为<strong>归并段</strong>或<strong>顺串</strong>。完成后对归并段进行归并，并使归并段逐渐从小到大，直到获得有序文件。</p>
<p><img src="/2022/08/19/DA-7/17.jpg" alt="场景"><br>如图，缓冲区被分为输入和输出两块，输入区分别读取一段记录，归并后结果不断存放到输出区中，输出区写满就按顺序转移到输出归并段中，然后清空输出缓存继续存放。</p>
<p>但是由于不可能一次读取完两个有序段同时保存排序结果，所以要不断和外存交换。<br><img src="/2022/08/19/DA-7/18.jpg" alt="场景"><br>外存信息读写时间远大于两外两项，所以要尽力减少读写次数。<br><img src="/2022/08/19/DA-7/19.jpg" alt="场景"></p>
<h3 id="多路平衡归并与败者树"><a href="#多路平衡归并与败者树" class="headerlink" title="多路平衡归并与败者树"></a>多路平衡归并与败者树</h3><p>根据前面分析，S趟归并，内部排序采用选择排序（k个记录找最小要比较k-1次，每趟n个元素需要(n-1)(k-1)次比较），内部排序总共需要的比较次数是：<br><img src="/2022/08/19/DA-7/20.jpg" alt="场景"><br>如果为例提高外部排序速度增大k，内部排序会变慢，从上面的比较次数可以看出，会导致整个次数增加，因而不能适用普通的内部排序，引入败者树。</p>
<p>败者树可以视为一棵完全二叉树，叶子结点存放归并段，规定两个数中大的为失败者，小的为胜利者，内部结点记录左右子树中的“失败者”序号，胜者继续往上比较，最后根结点就是最小的数。<br><img src="/2022/08/19/DA-7/21.jpg" alt="场景"></p>
<p>败者树深度为log(k)向上取整，即k个记录中选择最小值的比较次数就是败者树的深度，上面的内部排序总比较次数变成下面的大小。<br><img src="/2022/08/19/DA-7/23.jpg" alt="场景"><br>所以采用败者树以后k就不会影响内部排序比较次数了，也就是说，在内存足够的情况下，增大k能减小归并树高度，让每次I/O尽可能多地读取，从而减少归并趟数而不改变内部排序比较次数，同时减少I/O次数（意味着归并趟数和I/O次数相关），提高外部排序速度。</p>
<p>但是k也不是越大越好，增加k就要同时增加缓冲区个数，如果内存不够，就要减小每个缓冲区容量，所以k过大的时候虽然减少了归并趟数，但同时又增加了外存读写次数。</p>
<h3 id="置换—选择排序"><a href="#置换—选择排序" class="headerlink" title="置换—选择排序"></a>置换—选择排序</h3><p>除了优化k以外，减小r也可以减少归并趟数S，所以要采用新的方法找到更长的初始归并段。<br><img src="/2022/08/19/DA-7/24.jpg" alt="场景"><br><img src="/2022/08/19/DA-7/25.jpg" alt="场景"><br><img src="/2022/08/19/DA-7/26.jpg" alt="场景"></p>
<p>上面的过程中，选择MINIMAX要借助败者树完成。</p>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p>采用置换选择排序后，得到的是不同长度的归并段，所以要再找方法组织不同长度的归并段，使得I/O次数最少。</p>
<p>假设置换-选择排序得到下面的初始段，并画出三路归并的归并树：<br><img src="/2022/08/19/DA-7/27.jpg" alt="场景"><br>其中叶子结点标识初始归并段，其余结点的权值表示子树片段的长度和。叶子结点到根的路径长度（也就是前面的深度-1）表示参加归并的趟数，根结点表示最终生成的归并段。</p>
<p>树的带权路径长度WPL就是归并过程的读取次数了，上面的树WPL为242，则I/O次数为两倍，484。所以可以用哈夫曼树推广到m叉树来优化，让记录数少的初始归并段最先归并，记录数多的初始归并段最后归并，让WPL达到最小，这棵树就称为最佳归并树。上面例子的最佳归并树如下：<br><img src="/2022/08/19/DA-7/28.jpg" alt="场景"></p>
<p>步骤：如果初始段不能像上面一样构成一棵严格的k叉树（不能保证除叶子结点外的每个结点出度为k），需要添加长度为0的“虚段”，而且权为0的叶子应该离树根最远。将上面例子中长度为30的段删除，再次构建最佳归并树如下：<br><img src="/2022/08/19/DA-7/29.jpg" alt="场景"></p>
<p>虚段数目的确定：<br>假设度为0的结点有n0个，度为k的结点有nk个，严格二叉树中应该有n0==(k-1)nk + 1，即nk==(n0-1)/(k-1)。</p>
<ul>
<li>如果(n0-1)%(k-1)==0，说明是严格二叉树；</li>
<li>如果(n0-1)%(k-1)==u，说明对于n0个叶子结点，其中u个是多余的，所以应该增加一个内部结点。内部结点在归并树中占据了一个叶子结点的位置，此时有u+1个叶子结点在外部没有被接纳，所以还需要k-(u+1)个空归并段同u+1个（不存在u+1=k的情况，因为取余的时候u取值最大就是k-2）多余的叶子结点作为兄弟，存储在归并树中。</li>
</ul>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul>
<li>直接插入排序，冒泡排序，简单选择排序是基本排序方法，用于元素个数不是特别大的情况(n&lt;10000)。<blockquote>
<p>直接插入排序复杂度和初始序列有关，线性表有序，n-1次比较就完成排序，最差和平均情况是O(n^2)；<br>冒泡排序情况和直接插入排序相同；<br>简单选择排序复杂度中，比较次数和初始序列无关，比较次数总是O(n^2)，但元素移动次数和初始序列有关，最好情况不移动，最坏不超过3(n-1)次。</p>
</blockquote>
</li>
<li>希尔排序，用于元素个数处于中等规模的情况(n&lt;=1000)。<blockquote>
<p>随着希尔排序对每个组的处理，记录的比较和移动越来越少，其总比较次数要比直接插入排序少得多，而且不需要额外内存，缺点是希尔排序并不稳定。</p>
</blockquote>
</li>
<li><p>快排，堆排，基数排序，可以用于n特别大的情况，快排和堆排都是不稳定的，归并和基数排序是稳定的。</p>
<blockquote>
<p>快排是最通用的高效内部排序算法，平均情况时间复杂度O(nlog(n))，空间复杂度O(log(n))，最坏情况（元素已经有序）时间复杂度O(n^2)和空间复杂度O(n)，但是已经有了优化的办法，即“三者取中”；<br>堆排序也是重要的高效排序算法，时间复杂度是O(nlog(n))，一般不会产生最坏情况，也不需要额外空间，但是一般比快排慢；<br>归并排序也是重要的高效排序算法，性能与输入元素序列无关，时间复杂度总是O(nlog(n))，缺点是空间复杂度O(n)；<br>基数排序相对特殊，虽然时间复杂度O(d(n+r))线性增长，但是并不会比快排好很多，而且d元组的关键字抽取很多时候不方便，适应性比较差，况且还需要基数规模的一系列桶和与待排序元素规模相同的存储空间。</p>
</blockquote>
</li>
<li><p>混合使用使用不同的排序算法，达到更好的性能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>C#的语言集成查询LINQ</title>
    <url>/2024/05/24/LINQ/</url>
    <content><![CDATA[<p>LINQ是一种很方便的查询工具，是一系列直接将查询功能集成到C#语言的技术统称。开发中常用的查询如果使用LINQ编写，能够大幅度节省代码，但性能上会略有影响，本编博客记录LINQ在开发场景下的主要应用。</p>
<span id="more"></span>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>了解LINQ语句之前首先解释如何实现，C#通过扩展方法在不新建派生类型的情况下为现有类型添加方法。LINQ是最常见的扩展方法，将查询功能添加到<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable">System.Collections.IEnumerable</a>和<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.ienumerable-1">System.Collections.Generic.IEnumerable&lt;T&gt;</a>中，这些查询方法通常使用Lamda表达式作为参数。</p>
<p>扩展方法形式上通过非嵌套、非泛型的静态类内静态方法实现，例如下面是对string类型定义的扩展方法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ExtensionMethods</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">WordCount</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str.Split(<span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;?&#x27;</span> &#125;,</span><br><span class="line">                             StringSplitOptions.RemoveEmptyEntries).Length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数需要用this修饰，后面是需要扩展的类型和名称，虽然是静态方法，但是可以通过实例进行调用，编译器的中间语言会将代码转换为对该静态方法的调用。</p>
<h2 id="LINQ的查询操作"><a href="#LINQ的查询操作" class="headerlink" title="LINQ的查询操作"></a>LINQ的查询操作</h2><p>LINQ的查询操作可以通过三个步骤完成：</p>
<ul>
<li>获取数据源</li>
<li>创建查询</li>
<li>执行查询</li>
</ul>
<p>其中，数据源是支持IEnumrable\<T\>接口的数据类型如数组、列表等，foreach语句同样需要类型支持该接口才能遍历，被称为可查询类型。使用C#查询关键字可以方便地进行查询，语法类似数据库查询操作：</T\></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">子句</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/from-clause">from</a></td>
<td style="text-align:left">指定数据源和范围变量（类似于迭代变量）。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/where-clause">where</a></td>
<td style="text-align:left">基于由逻辑 AND 和 OR 运算符分隔的一个或多个布尔表达式筛选源元素。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/select-clause">select</a></td>
<td style="text-align:left">指定执行查询时，所返回序列中元素的类型和形状。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/group-clause">group</a></td>
<td style="text-align:left">根据指定的密钥值对查询结果分组。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/into">into</a></td>
<td style="text-align:left">提供可作为对 join、group 或 select 子句结果引用的标识符。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/orderby-clause">orderby</a></td>
<td style="text-align:left">根据元素类型的默认比较器对查询结果进行升序或降序排序。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/join-clause">join</a></td>
<td style="text-align:left">基于两个指定匹配条件间的相等比较而联接两个数据源。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/let-clause">let</a></td>
<td style="text-align:left">引入范围变量，在查询表达式中存储子表达式结果。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/in">in</a></td>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/join-clause">join</a> 子句中的上下文关键字。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/on">on</a></td>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/join-clause">join</a> 子句中的上下文关键字。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/equals">equals</a></td>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/join-clause">join</a> 子句中的上下文关键字。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/by">by</a></td>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/group-clause">group</a> 子句中的上下文关键字。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ascending">ascending</a></td>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/orderby-clause">orderby</a> 子句中的上下文关键字。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/descending">descending</a></td>
<td style="text-align:left"><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/orderby-clause">orderby</a> 子句中的上下文关键字。</td>
</tr>
</tbody>
</table>
</div>
<p>最主要的是from、where、select三个子句，from指定数据源，where指定筛选器，select指定返回的元素类型，举例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program.cs</span></span><br><span class="line"><span class="comment">// The Main() method</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">Suits</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;clubs&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;diamonds&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;hearts&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;spades&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">Ranks</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;four&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;five&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;six&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;seven&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;eight&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;nine&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;ten&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;queen&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;king&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;ace&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> startingDeck = <span class="function"><span class="keyword">from</span> s <span class="keyword">in</span> <span class="title">Suits</span>()</span></span><br><span class="line"><span class="function">                       <span class="keyword">from</span> r <span class="keyword">in</span> <span class="title">Ranks</span>()</span></span><br><span class="line"><span class="function">                       <span class="keyword">select</span> <span class="keyword">new</span></span> &#123; Suit = s, Rank = r &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> c <span class="keyword">in</span> startingDeck)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码将suits中的s和ranks中的r一一配对，生成含有52个元素的IEnumerable类型。查询本身不会做任何数据操作，而是延迟执行在foreach对查询变量枚举时，因此每次对延迟执行的数据源查询都可能会得到不同结果，如果需要强制执行可以使用ToList或者ToArray方法。因此和普通的语法查询相比，使用LINQ需要注意对查询变量及时保存，除非确有延迟查询的需要。</p>
<h2 id="自定义查询扩展方法"><a href="#自定义查询扩展方法" class="headerlink" title="自定义查询扩展方法"></a>自定义查询扩展方法</h2><p>LINQ的查询不满足对自定义类型的查询要求，需要重新定义扩展方法。继续上面代码的例子，现在我们对这副扑克牌进行洗牌操作，也就是52张牌分成上下两半，然后交替重叠到一起。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">InterleaveSequenceWith</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">    (<span class="params"><span class="keyword">this</span> IEnumerable&lt;T&gt; first, IEnumerable&lt;T&gt; second</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> firstIter = first.GetEnumerator();</span><br><span class="line">    <span class="keyword">var</span> secondIter = second.GetEnumerator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (firstIter.MoveNext() &amp;&amp; secondIter.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> firstIter.Current;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> secondIter.Current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是迭代器方法，所以可以使用yield return来返回单个元素。最后在Main方法中调用这个洗牌方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> startingDeck = <span class="function"><span class="keyword">from</span> s <span class="keyword">in</span> <span class="title">Suits</span>()</span></span><br><span class="line"><span class="function">                       <span class="keyword">from</span> r <span class="keyword">in</span> <span class="title">Ranks</span>()</span></span><br><span class="line"><span class="function">                       <span class="keyword">select</span> <span class="keyword">new</span></span> &#123; Suit = s, Rank = r &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> c <span class="keyword">in</span> startingDeck)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> top = startingDeck.Take(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">var</span> bottom = startingDeck.Skip(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">var</span> shuffle = top.InterleaveSequenceWith(bottom);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> c <span class="keyword">in</span> shuffle)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多次执行洗牌操作，会发现LINQ性能上的问题，我们看下面的代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program.cs</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Query for building the deck</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shuffling using InterleaveSequenceWith&lt;T&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// We can re-use the shuffle variable from earlier, or you can make a new one</span></span><br><span class="line">    shuffle = startingDeck;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        shuffle = shuffle.Take(<span class="number">26</span>).InterleaveSequenceWith(shuffle.Skip(<span class="number">26</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> card <span class="keyword">in</span> shuffle)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(card);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        times++;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (!startingDeck.SequenceEquals(shuffle));</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于延迟查询，每次洗牌过程中首先Take方法和Skip方法各对纸牌进行了查询，然后foreach处又需要查询一次，那么一次洗牌实际上花费三次LINQ查询。上面的代码统计几次洗牌后牌序会和原本一致，那么每执行一次洗牌，都会因为LINQ语句在shuffle被引用的时候进行多余查询，导致性能严重下降。</p>
<h2 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h2><p>下面代码使用LINQ的扩展方法ToDictionary将字典的value全部设置为false，字典的key是一个自定义的枚举类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">qualityChooseStateDic = qualityChooseStateDic.ToDictionary(pair =&gt; pair.Key, pair =&gt; <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>该扩展方法将IEnumrable类型转换为字典，接受两个lamda表达式作为参数，实际上类型是Func&lt;Tsource, Tkey&gt;和Func&lt;Tsource, Tvalue&gt;。使用这类方法可以节省代码，不然对字典的赋值需要编写循环方法。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程总结</title>
    <url>/2023/02/24/SE/</url>
    <content><![CDATA[<p>软件工程期末复习总结<br><img src="/2023/02/24/SE/1.png" alt="场景"><br><img src="/2023/02/24/SE/2.png" alt="场景"><br><img src="/2023/02/24/SE/3.png" alt="场景"><br><span id="more"></span></p>
<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="软件的定义"><a href="#软件的定义" class="headerlink" title="软件的定义"></a>软件的定义</h2><p>软件是一系列按照特定顺序组织的计算机数据和指令的集合，包括程序相关的文档。简单地说，软件就是程序加文档的集合体。软件是逻辑和物理的系统, 软件由程序、文档、数据和其它相关元素构成，是一个过程的抽象表示。</p>
<h2 id="软件的特点"><a href="#软件的特点" class="headerlink" title="软件的特点"></a>软件的特点</h2><ul>
<li>软件是开发出来的或者说是工程化的，并不是制造出来的。</li>
<li>软件开发环境对产品影响较大。</li>
<li>软件开发的时间和工作量难以估算。</li>
<li>用户往往不能一次性提出完整的需求，因此在经历了许多次修改后，软件才能令人满意。</li>
<li>几乎没有任何客观的标准或措施来评估软件的开发进度。</li>
<li>软件测试是非常困难的，测试所有路径的代价是极其昂贵的。</li>
<li>软件不会“耗尽”。</li>
<li>硬件可使用物理模型评价。软件设计的评价取决于判断和直觉。</li>
<li>硬件和软件项目管理之间存在很大区别。</li>
</ul>
<h2 id="软件的双重作用"><a href="#软件的双重作用" class="headerlink" title="软件的双重作用"></a>软件的双重作用</h2><p>一方面，软件是一种产品，可以提供计算能力；另一方面，软件是开发其它软件产品的工具。</p>
<h2 id="软件危机、软件工程的概念"><a href="#软件危机、软件工程的概念" class="headerlink" title="软件危机、软件工程的概念"></a>软件危机、软件工程的概念</h2><p>软件工程过程是指生产一个最终能满足需求且达到工程目标的软件产品所需要的步骤。</p>
<p>软件危机描述计算机能力和其能解决的问题复杂度迅速变化带来的影响。</p>
<h2 id="软件工程的目标与原则"><a href="#软件工程的目标与原则" class="headerlink" title="软件工程的目标与原则"></a>软件工程的目标与原则</h2><p>目标：<br>在给定的时间和预算内，按照用户的需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件。</p>
<p>原则：</p>
<ul>
<li>使用阶段性生命周期计划的管理</li>
<li>进行连续的验证</li>
<li>保持严格的产品控制</li>
<li>使用现代编程工具/工程实践</li>
<li>保持清晰的责任分配</li>
<li>用更好更少的人</li>
<li>保持过程改进</li>
</ul>
<h2 id="软件工程中的一些误解"><a href="#软件工程中的一些误解" class="headerlink" title="软件工程中的一些误解"></a>软件工程中的一些误解</h2><ul>
<li>管理者：加人赶进度，外包便轻松 | 延迟了的软件项目中加入新的开发人员只会让它延迟更多，管理方不懂得如何从内部管理和控制软件项目，即使将项目外包也无济于事；</li>
<li>客户：不正确的期望，需求要详细；</li>
<li>开发者：写好就完了，不运行不能评估，交接仅仅是程序，文档太麻烦 | 写完了要对接客户，评估通过技术报告，还有其他部分要交接，文档很重要。<h1 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h1>开发和维护软件及其相关产品所涉及的一系列活动。<h2 id="软件过程模型的定义"><a href="#软件过程模型的定义" class="headerlink" title="软件过程模型的定义"></a>软件过程模型的定义</h2>软件过程模型是软件开发全部过程、活动和任务的结构框架。<h2 id="软件工程的中心和三要素"><a href="#软件工程的中心和三要素" class="headerlink" title="软件工程的中心和三要素"></a>软件工程的中心和三要素</h2>以质量为中心，过程，方法，工具为三要素。</li>
</ul>
<h2 id="软件生存期模型及其优缺点、适用场合"><a href="#软件生存期模型及其优缺点、适用场合" class="headerlink" title="软件生存期模型及其优缺点、适用场合"></a>软件生存期模型及其优缺点、适用场合</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p><img src="/2023/02/24/SE/4.png" alt="场景"><br>优点：</p>
<ul>
<li>简单，过程透明，可管理性高；</li>
<li>推迟实现，写软件之前要分析设计；</li>
<li>以阶段评审和文档控制为手段进行质量控制，从而改进到预期质量；</li>
</ul>
<p>缺点：</p>
<ul>
<li>模型灵活性差，不好调整；</li>
<li>风险控制能力差；</li>
<li>过多文档增加工作量，而且完全用文档评估项目进度不准确；</li>
</ul>
<p>适用场合：<br>瀑布模型适用于系统需求明确，技术成熟，工程管理较严格的场合。</p>
<h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p><img src="/2023/02/24/SE/5.png" alt="场景"></p>
<p>优点：</p>
<ul>
<li>强调用户参与和决策，加强沟通；</li>
<li>可以加快需求的确定，减少不确定性和风险；</li>
<li>简化了项目管理，缩短了开发时间，降低了风险和成本。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不适合开发大型系统；</li>
<li>软件可维护性差；</li>
<li>用户合作要求高，合作不好反而拖慢进度。</li>
</ul>
<p>适用场合：<br>原型模型适用于客户不清楚系统具体输入输出，定义一个总体目标集；或者不确定算法效率、软件兼容性、如何交互的方式。</p>
<h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p><img src="/2023/02/24/SE/6.png" alt="场景"></p>
<p>优点：</p>
<ul>
<li>不需要完整需求；</li>
<li>初始阶段不用投入太多人力；</li>
<li>增量可以有效管理技术风险；</li>
<li>有利于增强客户信心，提高系统稳定性，可维护性，可靠性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>增量粒度难以选择；</li>
<li>确定所有的基本业务比较困难。</li>
</ul>
<p>适用场合：<br>（1）软件产品可以分批次地进行交付。<br>（2）待开发的软件系统能够被模块化。<br>（3）软件开发人员对应用领域不熟悉，难以一次性地进行系统开发。<br>（4）项目管理人员把握全局的水平较高。<br>（5）具有较大的灵活性，适合软件需求不明确，设计方案有一定风险的软件项目。</p>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p><img src="/2023/02/24/SE/7.png" alt="场景"></p>
<p> 优点：</p>
<ul>
<li>支持需求动态变化；</li>
<li>原型可以看作可执行的需求规格说明书；</li>
<li>强调原型的可扩充性和可修改性；</li>
<li>降低了开发风险；</li>
</ul>
<p>缺点：</p>
<ul>
<li>迭代效率不高会导致成本增加，提交时间延迟；</li>
<li>要求开发队伍水平很高；</li>
</ul>
<p>适用场合：<br>适合需求不明确，特别是大型系统开发。</p>
<h2 id="如何选择过程模型"><a href="#如何选择过程模型" class="headerlink" title="如何选择过程模型"></a>如何选择过程模型</h2><p>软件开发模型是不断发展的，各种模型各有优缺点，选用时不必拘泥于某种模型，可以组合，创建新的模型。</p>
<h2 id="能力成熟度模型及其侧重点"><a href="#能力成熟度模型及其侧重点" class="headerlink" title="能力成熟度模型及其侧重点"></a>能力成熟度模型及其侧重点</h2><ul>
<li>5 优化级：持续的过程改进；</li>
<li>4 量化管理级：量化管理；</li>
<li>3 已定义级：过程标准化；</li>
<li>2 可重复级：基本项目管理；</li>
<li>1 初始级：有能力的人和个人英雄主义<h2 id="过程和产品的关系"><a href="#过程和产品的关系" class="headerlink" title="过程和产品的关系"></a>过程和产品的关系</h2>以过程为中心的软件开发，比以产品为中心的软件开发能得到更好的产品。</li>
</ul>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>软件需求表达了对解决现实世界中某类问题的产品的要求和约束。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="可验证"><a href="#可验证" class="headerlink" title="可验证"></a>可验证</h3><p>验证某个软件的需求非常困难，代价很大，可验证性是测试的依据。</p>
<h3 id="可量化"><a href="#可量化" class="headerlink" title="可量化"></a>可量化</h3><p>需求应尽可能量化表述。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>根据需求紧迫程度和现有资源，安排需求实现的先后顺序。</p>
<h2 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h2><p>F<br>功能需求</p>
<h2 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h2><p>URPS<br>易用性Usability，可靠性Reliability，性能Performance，可支持性Supportability。</p>
<h2 id="需求分析步骤"><a href="#需求分析步骤" class="headerlink" title="需求分析步骤"></a>需求分析步骤</h2><p>需求获取-需求提炼-需求描述-需求验证</p>
<ul>
<li>需求获取<br>软件获取指的是软件需求的来源以及软件工程师收集这些软件需求的方法。</li>
<li>需求提炼<br>产生操作规格参数表，指明与其他系统元件的软件接口，确定软件必须遵循的约束。<br>对应用问题及环境的理解和分析，为问题涉及的信息，功能和系统行为建立模型。</li>
<li>需求描述<br>产生SRS需求规格说明书，包含了描述用户与软件交互的用例的集合，以及非功能性需求。</li>
<li><p>需求验证<br>检查需求的正确性、完整性、非二义性及内部和外部的连贯性。</p>
<h2 id="结构化分析方法的分析策略"><a href="#结构化分析方法的分析策略" class="headerlink" title="结构化分析方法的分析策略"></a>结构化分析方法的分析策略</h2><p>自顶向下逐步求精</p>
<h3 id="模型核心"><a href="#模型核心" class="headerlink" title="模型核心"></a>模型核心</h3><p>数据字典，把三种分析模型粘合在一起，是分析模型的核心。</p>
<h3 id="三种图及其对应的规格说明"><a href="#三种图及其对应的规格说明" class="headerlink" title="三种图及其对应的规格说明"></a>三种图及其对应的规格说明</h3><p>功能建模采用数据流图描述，数据建模采用实体-关系图，行为建模用状态转换图。</p>
<h2 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h2></li>
<li><p>环境图（顶层数据流图）</p>
</li>
<li>一层数据流图</li>
<li>二层数据流图</li>
</ul>
<p><img src="/2023/02/24/SE/35.png" alt="场景"><br><img src="/2023/02/24/SE/36.png" alt="场景"></p>
<h2 id="面向对象的分析建立的三种模型"><a href="#面向对象的分析建立的三种模型" class="headerlink" title="面向对象的分析建立的三种模型"></a>面向对象的分析建立的三种模型</h2><p>用例模型（用例图），对象模型（类图），动态模型（状态图和交互图）</p>
<h2 id="画用例图"><a href="#画用例图" class="headerlink" title="画用例图"></a>画用例图</h2><p>三种元素：</p>
<ul>
<li>用例：系统执行的一系列动作，动作的结果能被参与者察觉到。</li>
<li>参与者：与系统交互的人或物，代表外部实体。</li>
<li>关系：参与者与用例、用例之间的关系（泛化，包含，扩展），参与者之间的关系（泛化）。</li>
</ul>
<h1 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h1><h2 id="软件设计包含的两类活动"><a href="#软件设计包含的两类活动" class="headerlink" title="软件设计包含的两类活动"></a>软件设计包含的两类活动</h2><p>软件架构设计和软件详细设计。</p>
<h2 id="创新设计不属于软件设计"><a href="#创新设计不属于软件设计" class="headerlink" title="创新设计不属于软件设计"></a>创新设计不属于软件设计</h2><p>软件设计主要为分解设计，可以包括系列模式设计，不包括创新设计。</p>
<h2 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h2><p>FURPS</p>
<h2 id="设计技术"><a href="#设计技术" class="headerlink" title="设计技术"></a>设计技术</h2><h3 id="模块化不能无限划分模块"><a href="#模块化不能无限划分模块" class="headerlink" title="模块化不能无限划分模块"></a>模块化不能无限划分模块</h3><p>随着模块数量的增加，开发单个软件模块的总工作量（成本）下降，但是集成所有模块的工作量（成本）随着模块个数的增加而增加，存在一个模块个数 M 将导致理论上最低的开发成本。</p>
<h3 id="信息隐藏原则的定义"><a href="#信息隐藏原则的定义" class="headerlink" title="信息隐藏原则的定义"></a>信息隐藏原则的定义</h3><p>模块应该具有彼此相互隐藏的特性。信息隐蔽原则有利于提高模块的内聚性</p>
<h3 id="重构的定义"><a href="#重构的定义" class="headerlink" title="重构的定义"></a>重构的定义</h3><p>不改变组件功能和行为条件下简化组件设计（或编码）的一种重组技术。</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>忽略具体的信息将不同事物看成相同事物的过程，侧重相关细节忽略不相关细节。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>在给定上下文环境中一类共同问题的共同解决方法。</p>
<h3 id="独立功能（不要求七种内聚其中耦合）"><a href="#独立功能（不要求七种内聚其中耦合）" class="headerlink" title="独立功能（不要求七种内聚其中耦合）"></a>独立功能（不要求七种内聚其中耦合）</h3><p>每个模块只解决需求中特定的子功能并对系统其他模块而言具有具有简单的访问接口。</p>
<h3 id="细化"><a href="#细化" class="headerlink" title="细化"></a>细化</h3><p>逐步求精的过程，与抽象是一组相对的概念，相辅相成。</p>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><ul>
<li>深度：程序结构的层次数</li>
<li>宽度：层次结构中同一层模块的最大模块个数称为结构的宽度</li>
<li>扇入数：调用一个给定模块的模块个数</li>
<li>扇出数：一个模块直接调用的其他模块数目</li>
</ul>
<h2 id="完整的设计规格（四种设计模型）"><a href="#完整的设计规格（四种设计模型）" class="headerlink" title="完整的设计规格（四种设计模型）"></a>完整的设计规格（四种设计模型）</h2><p>包括数据设计、架构设计、接口设计、组件设计</p>
<h2 id="软件体系架构"><a href="#软件体系架构" class="headerlink" title="软件体系架构"></a>软件体系架构</h2><h3 id="五种架构风格"><a href="#五种架构风格" class="headerlink" title="五种架构风格"></a>五种架构风格</h3><ul>
<li>数据中心架构</li>
<li>数据流体系架构</li>
<li>调用和返回架构</li>
<li>面向对象架构</li>
<li>层次架构<h3 id="B-S和C-S架构"><a href="#B-S和C-S架构" class="headerlink" title="B/S和C/S架构"></a>B/S和C/S架构</h3>客户端/服务器：基于资源不对等，为实现共享提出来的，由客户机，服务器，网络组成；<br>浏览器/服务器：三层体系结构的一种实现方式，具体结构为浏览器/web服务器/数据库服务器</li>
</ul>
<h2 id="用户界面设计的三条原则"><a href="#用户界面设计的三条原则" class="headerlink" title="用户界面设计的三条原则"></a>用户界面设计的三条原则</h2><ul>
<li>用户控制系统</li>
<li>减少用户记忆负担</li>
<li>保持界面一致<h2 id="用户界面设计由一系列的分析开始（三种分析的内容）"><a href="#用户界面设计由一系列的分析开始（三种分析的内容）" class="headerlink" title="用户界面设计由一系列的分析开始（三种分析的内容）"></a>用户界面设计由一系列的分析开始（三种分析的内容）</h2></li>
<li>用户特点分析:应用从具体业务和技术资料收集而来的各种信息来定义各种最终用户的属性和配置信息;</li>
<li>用户任务分析:使用结构化设计方法或面向对象方法定义用户任务和相关操作，包括用户用例、任务和目标描述、工作流程分析，充分理解人机交互任务的分层描述;</li>
<li>应用场景分析:确定了用户操作接口的呈现方式约束和布局风格约束;<h2 id="结构化程序设计的概念"><a href="#结构化程序设计的概念" class="headerlink" title="结构化程序设计的概念"></a>结构化程序设计的概念</h2>基于过程设计的理念，限制了算法表示细节的逻辑结构数量和类型，便于设计师编写不复杂的算法，方便阅读、测试和维护。<br>如果一个程序的代码块仅仅通过顺序，选择，循环三种基本控制结构进行连接，并且只有一个入口和一个出口，那么这个程序就是机构化的。<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2></li>
</ul>
<h3 id="流程图及其主要缺点"><a href="#流程图及其主要缺点" class="headerlink" title="流程图及其主要缺点"></a>流程图及其主要缺点</h3><p><img src="/2023/02/24/SE/8.png" alt="场景"><br>缺点：</p>
<ul>
<li>本质上不是逐步求精的好工具，容易过早考虑控制结构而忽略全局结构；</li>
<li>箭头可以随意转移控制流，不顾结构化程序设计的精神；</li>
<li>在表示数据结构方面不足。<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3></li>
</ul>
<h3 id="N-S图"><a href="#N-S图" class="headerlink" title="N-S图"></a>N-S图</h3><p><img src="/2023/02/24/SE/9.png" alt="场景"><br><img src="/2023/02/24/SE/10.png" alt="场景"></p>
<h3 id="PAD图"><a href="#PAD图" class="headerlink" title="PAD图"></a>PAD图</h3><p><img src="/2023/02/24/SE/11.png" alt="场景"><br><img src="/2023/02/24/SE/12.png" alt="场景"><br><img src="/2023/02/24/SE/13.png" alt="场景"></p>
<h1 id="生产率和工作量度量"><a href="#生产率和工作量度量" class="headerlink" title="生产率和工作量度量"></a>生产率和工作量度量</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="基于功能点"><a href="#基于功能点" class="headerlink" title="基于功能点"></a>基于功能点</h3><p>功能点数：从直接度量软件信息域和评估软件复杂性的经验量化关系中获得。<br><img src="/2023/02/24/SE/15.png" alt="场景"><br>复杂性调整值：<br><img src="/2023/02/24/SE/16.png" alt="场景"><br><img src="/2023/02/24/SE/17.png" alt="场景"><br>优点：</p>
<ul>
<li>可用于软件项目开发的初期阶段的项目估算。因为在可行性研究和需求分析阶段已能基本确定输入、输出等各个参量；</li>
<li>与程序设计语言无关。适合于过程或非过程式语言。</li>
</ul>
<p>缺点：</p>
<ul>
<li>某些参考量的收集有一定困难；</li>
<li>度量值的主观因素较多，如Fi取值；</li>
<li>功能点FP本身没有直观的物理意义。<h3 id="基于KLOC"><a href="#基于KLOC" class="headerlink" title="基于KLOC"></a>基于KLOC</h3><img src="/2023/02/24/SE/14.png" alt="场景"><br>优点：</li>
<li>容易计算</li>
<li>许多估算软件都适用LOC和KLOC作为重要输入</li>
<li>有大量关于LOC的文献和数据</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖于适用的语言</li>
<li>不太适用于非过程化语言</li>
<li>设计完成的时候才能计算，完成之前需要细节，难以估算。</li>
</ul>
<h2 id="成本估算方法"><a href="#成本估算方法" class="headerlink" title="成本估算方法"></a>成本估算方法</h2><p>COCOMO模型</p>
<h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ol>
<li>穷尽测试是不可能的</li>
<li>测试无法显示潜伏的软件缺陷</li>
<li>测试活动应尽早进行</li>
<li>软件缺陷具有群聚性</li>
<li>注意杀虫剂现象</li>
<li>应尽量由独立的测试团队进行测试<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2>1) 确认系统满足其预期的使用和用户的需要。<br>2) 确认解决了所需解决的问题（如实现商业规则和使用合适的系统假定）。<br>3) 为测试的过程建立责任和可解释性。<br>4) 便于及早发现软件和系统的异常。<br>5) 及早提供软件和系统的性能的评估。<br>6) 为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险<br>7) 鉴别出程序在功能等方面的异常集聚之处。<h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3>????<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3>测试输入、执行条件，以及预期结果的集合，为特定目的开发。<h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2>项目现有检测结果和应有结果之间的差异（未完成，有错误，画蛇添足，隐含需求没实现，不好用）<h2 id="调试与测试的相同和不同"><a href="#调试与测试的相同和不同" class="headerlink" title="调试与测试的相同和不同"></a>调试与测试的相同和不同</h2>相同：都包含处理软件缺陷和查看代码的过程；<br>不同：测试的目标是发现缺陷所在，调试的目标是修复缺陷。<h2 id="测试与质量保证"><a href="#测试与质量保证" class="headerlink" title="测试与质量保证"></a>测试与质量保证</h2><h3 id="测试人员的目标"><a href="#测试人员的目标" class="headerlink" title="测试人员的目标"></a>测试人员的目标</h3>尽早找出软件缺陷，并确保缺陷得以修复<h3 id="质量保证人员的主要职责"><a href="#质量保证人员的主要职责" class="headerlink" title="质量保证人员的主要职责"></a>质量保证人员的主要职责</h3>创建和执行改进软件开发过程并防止软件缺陷发生的标准和方法<h2 id="评估准则"><a href="#评估准则" class="headerlink" title="评估准则"></a>评估准则</h2></li>
</ol>
<ul>
<li>覆盖率=测试集合T/测试需求集合TR</li>
<li>故障插入</li>
<li>变异分值<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3>忽略系统或组件内部机制，仅关注输入响应和相应执行条件的输出测试，即功能性测试。<h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4>把所有可能的输入划分成若干部分，选择有代表性的数据作为测试用例。需要选择有效等价类和无效等价类。<h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4>选择边界值作为用例测试<br><img src="/2023/02/24/SE/25.png" alt="场景"><br><img src="/2023/02/24/SE/26.png" alt="场景"><h4 id="状态值测试"><a href="#状态值测试" class="headerlink" title="状态值测试"></a>状态值测试</h4>一种基于模型的测试，用状态图来描述时间序列，由此产生测试用例。<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3>考虑系统或自建内部机制（分支，路径，语句测试），即结构性测试。</li>
<li>所有独立的执行路径至少测试一次；</li>
<li>所有逻辑判断，取真和取假都要测试一次；</li>
<li>在循环边界和运行界限内执行循环体；</li>
<li>测试内部数据结构有效性。<h4 id="逻辑覆盖测试"><a href="#逻辑覆盖测试" class="headerlink" title="逻辑覆盖测试"></a>逻辑覆盖测试</h4><img src="/2023/02/24/SE/18.png" alt="场景"><h5 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h5>每一执行语句至少执行一次<br><img src="/2023/02/24/SE/19.png" alt="场景"><h5 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h5>每个判断条件为真或者为假都至少执行一次<br><img src="/2023/02/24/SE/21.png" alt="场景"><h5 id="分支覆盖（判定覆盖）"><a href="#分支覆盖（判定覆盖）" class="headerlink" title="分支覆盖（判定覆盖）"></a>分支覆盖（判定覆盖）</h5>每个判断的真假分支都要执行<br><img src="/2023/02/24/SE/20.png" alt="场景"><h5 id="条件组合覆盖"><a href="#条件组合覆盖" class="headerlink" title="条件组合覆盖"></a>条件组合覆盖</h5>每个判断条件的取值组合执行一次<br><img src="/2023/02/24/SE/22.png" alt="场景"><h4 id="控制流图"><a href="#控制流图" class="headerlink" title="控制流图"></a>控制流图</h4><img src="/2023/02/24/SE/23.png" alt="场景"><h5 id="节点覆盖"><a href="#节点覆盖" class="headerlink" title="节点覆盖"></a>节点覆盖</h5>等价于语句覆盖，对所有节点测试路径集合中至少存在一条测试路径访问该节点<h5 id="边覆盖"><a href="#边覆盖" class="headerlink" title="边覆盖"></a>边覆盖</h5>对于所有边，至少存在一条测试路径访问，包含节点覆盖，可以实现分支覆盖<h5 id="路径覆盖"><a href="#路径覆盖" class="headerlink" title="路径覆盖"></a>路径覆盖</h5>覆盖程序中所有可能路径，但是在某些情况下难以继续，所以采用基本路径测试。</li>
</ul>
<h5 id="基本路径测试"><a href="#基本路径测试" class="headerlink" title="基本路径测试"></a>基本路径测试</h5><p>把覆盖的路径数压缩，循环体最多执行一次。</p>
<p>步骤：</p>
<ol>
<li>程序环路复杂性；</li>
<li>确定线性独立路径的集合；</li>
<li>为基本集合中每条路径生成测试用例。</li>
</ol>
<p>环路复杂性：程序基本路径中独立路径条数，是确保每个可执行语句至少执行一次所必须的测试用例数目的上界。独立路径是，至少包含一条在其他独立路径中从未有过的边的路径。<br>V = e - n + 2<br><img src="/2023/02/24/SE/24.png" alt="场景"></p>
<h3 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h3><p>混合黑白测试。</p>
<h2 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>静态测试的范围很广，软件开发项目中代码、所有的文档以及项目外有价值文档都可以通过人工方式审查。</p>
<h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><p>其目的是从已有的规格说明、已定义的标准乃至项目的计划中发现缺陷和偏差。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>静态测试的基本思想是缺陷的预防，即尽可能早地在缺陷和偏差对将来开发过程产生影响之前发现并修改它们，否则会致代价高昂的返工。</p>
<h3 id="评审类型"><a href="#评审类型" class="headerlink" title="评审类型"></a>评审类型</h3><ul>
<li>同事审查</li>
<li>走查</li>
<li>审查</li>
</ul>
<h1 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h1><h2 id="改进的V模型"><a href="#改进的V模型" class="headerlink" title="改进的V模型"></a>改进的V模型</h2><p><img src="/2023/02/24/SE/27.png" alt="场景"></p>
<p>各个级别测试的目的（依据）：</p>
<ul>
<li>单元测试的主要目的是验证软件模块是否按详细设计的规格说明正确运行（白盒为主，黑盒为辅）；</li>
<li>集成测试主要目的是检查多个模块间是否按概要设计说明的方式协同工作（灰盒）；</li>
<li>系统测试的主要目的是验证整个系统是否满足需求规格说明（黑盒）；</li>
<li>验收测试从用户的角度检查系统是否满足合同中定义的需求，以及以确认产品是否能符合业务上的需要（用户参与）；</li>
</ul>
<h2 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h2><p>定义：<br>回归测试是指有选择地重新测试系统或其组件，以验证对软件的修改没有导致不希望出现的影响，以及系统或组件仍然符合其指定的需求。</p>
<p>回归测试可以在所有的测试级别执行，并应用于功能和非功能测试中。</p>
<p>回归测试应该尽量采用自动化测试。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="桩模块和驱动模块"><a href="#桩模块和驱动模块" class="headerlink" title="桩模块和驱动模块"></a>桩模块和驱动模块</h3><p><img src="/2023/02/24/SE/28.png" alt="场景"><br>桩模块（存根模块）：被测模块中也难免调用其他的模块，桩模块（也称存根模块）就是用以替代被测模块所调用的那些模块。<br>驱动模块：驱动模块用以调用被测模块，使被测的模块得到执行。</p>
<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p><img src="/2023/02/24/SE/29.png" alt="场景"><br>对模块接口的测试保证在测试时进出程序单元的数据流是正确的；对局部数据结构的检查保证临时存储的数据在算法执行的整个过程中都能维持其完整性；对边界条件的测试保证模块在极限或严格的情形下仍然能够正确执行；控制结构中的所有独立路径（基本路径）原则上都应覆盖，以保证在一个模块中的所有语句都能执行至少一次；最后，要对所有出错处理的路径进行测试。</p>
<h3 id="单元测试依据不是代码"><a href="#单元测试依据不是代码" class="headerlink" title="单元测试依据不是代码"></a>单元测试依据不是代码</h3><p>单元测试的主要依据是详细设计，而不是针对代码的测试。因为未测代码可能包含错误和缺陷，如果依照其测试，则可能无法发现一些错误。</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><h3 id="自顶向下的集成方法"><a href="#自顶向下的集成方法" class="headerlink" title="自顶向下的集成方法"></a>自顶向下的集成方法</h3><p>定义：将模块按照系统程序结构，沿控制层自顶向下进行集成，从属于主控模块的按深度优先或广度优先集成到结构中去。<br>优点：</p>
<ul>
<li>较早验证主要控制和判断点</li>
<li>如果按照深度优先，可以实现和验证一个完整的软件功能。<br>缺点：</li>
<li>桩的开发量大</li>
</ul>
<p>广度优先和深度优先<br><img src="/2023/02/24/SE/31.png" alt="场景"><br><img src="/2023/02/24/SE/30.png" alt="场景"></p>
<h3 id="自底向上的集成方法"><a href="#自底向上的集成方法" class="headerlink" title="自底向上的集成方法"></a>自底向上的集成方法</h3><p>从软件结构最底层的模块开始，按照接口依赖关系逐层向上集成，以进行测试。<br>优点：每个底层模块都已经测试，不需要桩；<br>缺点：每个模块都需要编写驱动模块，缺点的隔离和定位不如自顶向下。</p>
<h3 id="SMOKE方法"><a href="#SMOKE方法" class="headerlink" title="SMOKE方法"></a>SMOKE方法</h3><p>对整个系统进行基本测试，验证基本功能；是一种预测试，也叫做可测性测试。<br>优点：节省测试时间，防止构造失败；<br>缺点：覆盖率低。</p>
<h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>从用户角度进行测试，将完成了集成测试的系统在真实环境下测试，用于功能确认和验证。</p>
<p>主要内容：</p>
<ul>
<li>功能性测试</li>
<li>性能测试</li>
<li>压力测试</li>
<li>恢复测试</li>
<li>安全测试</li>
<li>其他系统测试<h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2>验收测试是软件测试部门对经过项目组内部单元测试、集成测试和系统测试后的软件所<br>进行的测试，测试用例采用项目组的系统测试用例子集，或者由验收测试人员自行决定测试<br>内容。</li>
<li>根据合同进行的验收测试</li>
<li>用户验收测试</li>
<li>现场测试<h2 id="α测试和β测试"><a href="#α测试和β测试" class="headerlink" title="α测试和β测试"></a>α测试和β测试</h2>α测试：用户在开发者的场所来进行的，软件在开发者对用户的指导下进行测试，开发者负责记录错误和使用中出现的问题；<br>β测试：软件由不用用户在实际适用过程中测试，反馈错误信息给开发者。</li>
</ul>
<h1 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>软件维护是指由于软件产品出现问题或需要改进而对代码及相关文档的修改，其目的是对现有软件产品进行修改的同时保持其完整性。</p>
<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><ul>
<li>纠错性维护</li>
<li>适应性维护</li>
<li>完善性维护</li>
<li>预防性维护</li>
</ul>
<p>在维护的初期，纠错性维护的工作量较大，随着错误发现率逐渐降低并趋于稳定，适应性维护和完善性维护的工作量逐步增大。</p>
<h2 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h2><p>软件维护的必要性体现在软件维护对软件能持续满足用户的需求有重要的意义。</p>
<p>1) 软件维护能够改正错误。<br>2) 软件维护能够改善设计。<br>3) 软件维护能够实现软件的改进（Implement enhancements）<br>4) 软件维护能够与其他系统进行交互。<br>5) 软件维护能够为使用不同的硬件、软件、系统的新性能以及通讯设备等而对软件进行改进。<br>6) 软件维护能够完成遗留程序的移植。<br>7) 软件退出使用。</p>
<h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><p>？？？？</p>
<h2 id="困难性"><a href="#困难性" class="headerlink" title="困难性"></a>困难性</h2><ul>
<li>配置管理工作不到位</li>
<li>人员变动的影响</li>
<li>软件可读性差</li>
<li>任务紧，时间急的情况下处理维护请求<h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3>纠正软件系统出现的错误和缺陷，以及为满足新要求进行修改，扩充或压缩的容易程度。<h3 id="决定因素"><a href="#决定因素" class="headerlink" title="决定因素"></a>决定因素</h3></li>
<li>可理解性</li>
<li>可使用性</li>
<li>可测试性</li>
<li>可修改性</li>
<li>可移值性</li>
<li>效率</li>
<li>可靠性<h2 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h2><img src="/2023/02/24/SE/32.png" alt="场景"><h2 id="估算工作量的模型"><a href="#估算工作量的模型" class="headerlink" title="估算工作量的模型"></a>估算工作量的模型</h2><img src="/2023/02/24/SE/33.png" alt="场景"><h2 id="软件再工程"><a href="#软件再工程" class="headerlink" title="软件再工程"></a>软件再工程</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3>对现有软件进行仔细审查和改造，对其进行重新构造，使之称为一个新的形式，同时包括随之产生的对新形式的实现。<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><img src="/2023/02/24/SE/34.png" alt="场景"><h3 id="软件逆向工程"><a href="#软件逆向工程" class="headerlink" title="软件逆向工程"></a>软件逆向工程</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4>恢复设计结果的过程，分析程序，在源程序更高的抽象层次上创建出某种描述过程。<h4 id="方面"><a href="#方面" class="headerlink" title="方面"></a>方面</h4></li>
<li>数据的逆向工程</li>
<li>处理的逆向工程</li>
<li>用户界面的逆向工程</li>
</ul>
<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="四大要素（四个P）"><a href="#四大要素（四个P）" class="headerlink" title="四大要素（四个P）"></a>四大要素（四个P）</h2><ul>
<li>People人员</li>
<li>Product产品</li>
<li>Process过程</li>
<li>Project项目</li>
</ul>
<h2 id="团队组织方式"><a href="#团队组织方式" class="headerlink" title="团队组织方式"></a>团队组织方式</h2><ul>
<li>DD（民主分权制）</li>
<li>CD（有控制的分权制）</li>
<li>CC（有控制的集中制）<h2 id="虚拟团队"><a href="#虚拟团队" class="headerlink" title="虚拟团队"></a>虚拟团队</h2></li>
</ul>
<h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>是跨越时间、空间和组织界限，运用通信技术网加强连接的队伍。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：提高生产力，扩大市场机会，知识转移；<br>缺点：沟通不足，缺少领导和管理，不称职的团队成员。</p>
<h2 id="策划项目前应该做的事情"><a href="#策划项目前应该做的事情" class="headerlink" title="策划项目前应该做的事情"></a>策划项目前应该做的事情</h2><h2 id="项目估算的主要方法"><a href="#项目估算的主要方法" class="headerlink" title="项目估算的主要方法"></a>项目估算的主要方法</h2><p>分解技术、经验模型</p>
<h2 id="软件范围"><a href="#软件范围" class="headerlink" title="软件范围"></a>软件范围</h2><p>在技术和管理层面上都是无二义性和可理解的项目范围，是软件开发各阶段的工作依据。</p>
<h2 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h2><p>目的是使项目经理能够对资源、成本及时间进行合理的估算，一般是在项目开始时进行，随着项目进展定期更新。</p>
<h2 id="P-CMM"><a href="#P-CMM" class="headerlink" title="P-CMM"></a>P-CMM</h2><p>人力资源管理成熟度模型</p>
<ul>
<li>初始级</li>
<li>重复级</li>
<li>定义级</li>
<li>定量级</li>
<li>优化级</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>TextMeshPro</title>
    <url>/2024/05/27/TextMeshPro/</url>
    <content><![CDATA[<p>最近项目使用Unity的TextMeshPro插件实现图文混排，借这个机会记录一下该插件的使用。TextMesh是原本Unity使用的文本配置组件，但是该组件功能有限，使用位图呈现文字导致放大后字体模糊，性能消耗也大。于是有人制作了该插件弥补这些缺点，并在2017年被收录进Unity引擎。</p>
<span id="more"></span>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>TextMeshPro的核心是使用纹理来表现文本，插件根据Font文件（字体）生成一个Texture Atlas，通过有符号距离场进行渲染，这里不在展开说明渲染方法。并且注意，该插件有两种，<em>TextMeshPro</em>配合<em>MeshRenderer</em>进行渲染，适用于世界坐标系中的物体；<em>TextMeshProUGUI</em>配合<em>CanvasRenderer</em>进行渲染，适用于屏幕空间的物体。除了配合的插件不同，两种类型的使用方法完全相同。</p>
<p><img src="/2024/05/27/TextMeshPro/gzq\blog\ANKIIMA.github.io\source\_posts\TextMeshPro\1.png" alt></p>
<p>新建一个物体添加该组件，这里组件名称中的UI代表的就是UGUI配合Canvas进行渲染的类型。下面表格说明了各个属性的使用：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Text Input</td>
<td>文本编辑</td>
</tr>
<tr>
<td>Text Style</td>
<td>字体风格（一些预设形式）</td>
</tr>
<tr>
<td>Font Asset</td>
<td>字体资产</td>
</tr>
<tr>
<td>Material Preset</td>
<td>材质预设</td>
</tr>
<tr>
<td>Font Style</td>
<td>字体风格（斜体、粗体、大小写等）</td>
</tr>
<tr>
<td>FontSize</td>
<td>字体大小</td>
</tr>
<tr>
<td>Auto Size</td>
<td>自动设置字体大小（不超过边界）</td>
</tr>
<tr>
<td>Vertex Color</td>
<td>字体颜色</td>
</tr>
<tr>
<td>Color Gradient</td>
<td>颜色过渡</td>
</tr>
<tr>
<td>Override Tags</td>
<td>颜色设置是否重载</td>
</tr>
<tr>
<td>Spacing Options</td>
<td>行距、间距设置</td>
</tr>
<tr>
<td>Alignment</td>
<td>对齐方式</td>
</tr>
<tr>
<td>Wrapping</td>
<td>平铺模式，Enable表示水平超过文本区域时自动换行</td>
</tr>
<tr>
<td>Overflow</td>
<td>溢出模式</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Rich-Text"><a href="#Rich-Text" class="headerlink" title="Rich Text"></a>Rich Text</h1><p>有时我们希望文本中部分字词表现不同，可以使用富文本标记来实现。和HTML语言一样，需要特殊显示的文本采用<>和</>进行标记，例如在文本中单独标记一段斜体，或设置不同颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a &lt;i&gt;good&lt;/i&gt; game.</span><br><span class="line">Have a &lt;color=red&gt;nice&lt;/color&gt; day.</span><br><span class="line">Have a &lt;color=#ff0000ff&gt;nice&lt;/color&gt; day.</span><br></pre></td></tr></table></figure>
<p><img src="/2024/05/27/TextMeshPro/gzq\blog\ANKIIMA.github.io\source\_posts\TextMeshPro\2.png" alt></p>
<p><line-indent=15%>表示行首缩进15%的文本区域。此外还有很多文本标记，最有用的功能是实现超链接和配合Sprite Asset实现图文混排，<a href="http://digitalnativestudios.com/textmeshpro/docs/rich-text/">文档</a>列出了常用标记语言。</line-indent=15%></p>
<h1 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a>Overflow</h1><p>当文字溢出容器边界时，组件提供了几种可控的方式。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Overflow模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Overflow</td>
<td>直接向下连续溢出垂直边界</td>
</tr>
<tr>
<td>Elipsis</td>
<td></td>
</tr>
<tr>
<td>Masking</td>
<td></td>
</tr>
<tr>
<td>Truncate</td>
<td></td>
</tr>
<tr>
<td>ScrollRect</td>
<td></td>
</tr>
<tr>
<td>Page</td>
<td></td>
</tr>
<tr>
<td>Linked</td>
<td>溢出到另一个Text容器中</td>
</tr>
</tbody>
</table>
</div>
<h1 id="实现图文混排"><a href="#实现图文混排" class="headerlink" title="实现图文混排"></a>实现图文混排</h1><p>可以通过右键切好的图集创建一个SpriteAsset，并使用富文本标记来将图片混排在文本中。步骤如下：</p>
<ul>
<li>创建图集对应的SpriteAsset；</li>
</ul>
<p><img src="/2024/05/27/TextMeshPro/gzq\blog\ANKIIMA.github.io\source\_posts\TextMeshPro\3.png" alt></p>
<ul>
<li>设置引用关系，有三种方式，可以全局设置Default Sprite Asset，或者组件中自行绑定，还可以在TMP Settings中根据设置的Sprite Assets路径通过富文本标记访问。</li>
</ul>
<p><img src="/2024/05/27/TextMeshPro/gzq\blog\ANKIIMA.github.io\source\_posts\TextMeshPro\4.png" alt></p>
<p><img src="/2024/05/27/TextMeshPro/gzq\blog\ANKIIMA.github.io\source\_posts\TextMeshPro\5.png" alt></p>
<p>如果组件的SpriteAsset为空，那么将默认使用Default Sprite Asset，在文本中添加标记：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sprite=0&gt;</span><br></pre></td></tr></table></figure>
<p>可以对图集中inde为0的图片进行引用。如果想单独指定使用的图集，在文本中添加标记：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sprite=&quot;图集对应SpriteAsset名称&quot; index=0&gt;</span><br><span class="line">&lt;sprite=&quot;图集对应SpriteAsset名称&quot; name=&quot;图片在图集中名称&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>组件会自动将这类标记转换为图片。图集的各项属性和其中图片的设置可以在Sprite Asset的Inspector中进行编辑，主要是设置偏移量和缩放以符合需要。</p>
]]></content>
      <categories>
        <category>Engine</category>
        <category>Unity</category>
        <category>Plugins</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Unity Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>赋权网络对解决链路预测问题的帮助</title>
    <url>/2022/10/08/WSEAL/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>链路预测作为图的基本问题，应用广泛。问题本身可以从几个方面来考虑，从图表示学习上，这是一个双节点表示问题，可以利用多节点表示的方法解决；从矩阵分解上，这是一个降维恢复的问题，分解得到网络的潜在特征和构成方式可以进一步帮助预测；从机器学习上，这是一个二分类问题，可以用各种已经存在的方法拟合；还有另外一些先验假设方法，计算连接产生的可能性。</p>
<p>现在，我们不考虑时间复杂度的情况，找到一种泛化性足够强的方法，开发一个链路预测框架。<br><span id="more"></span></p>
<h1 id="寻找最好的方法"><a href="#寻找最好的方法" class="headerlink" title="寻找最好的方法"></a>寻找最好的方法</h1><p>以最新的调查为例，可以将上面讲的各种角度延伸出来的方法分成五类，如下图。<br><img src="/2022/10/08/WSEAL/1.jpg" alt="场景"><br>首先，基于相同邻居的方法和基于路径的方法可以统称为启发式方法，也就是预定义一个计算式来对网络中不同的连接进行预测，虽然时间复杂度方面具有优势，但是精度不高；基于统计的方法建立一个统计模型对网络进行预测，引入繁杂的参数，对大型网络不方便实施，而且也不容易解释其中的内核；作为一个二分类问题，机器学习中已有的许多分类器方法都可以直接应用到网络上，例如著名的K近邻算法等。但是，前面的方法都忽略了一个问题，即应该如何应对大型网络。一个大型的网络通常会有几万个结点，需要庞大的邻接矩阵进行描述，不管如何处理这个邻接矩阵都是难以接受的，这导致了空间和时间上的巨大花销，也就催生了图嵌入方法的产生。</p>
<p>图嵌入，或者称为图表示学习，旨在将高维的图用低维的向量表示，并且在向量中尽可能保留图的拓扑信息，实现图的降维。从文章的统计来看，图嵌入已经成为链路预测问题中的主要方法了，部分传统方法得益于其方便的计算，通常作为一种比较方法存在。<br><img src="/2022/10/08/WSEAL/2.jpg" alt="场景"></p>
<p>而图嵌入又可以分为多种方法。首先，矩阵分解将原先的邻接矩阵表示的网络分解为不同的“子”矩阵，可以是一些矩阵的乘积，也可以是一些矩阵的和或差，总之，矩阵分解得到了网络的低维表示，在这些低维的矩阵中，有的表示网络的潜在信息，有的描述了网络潜在信息之间的关联，在不同的分解方式也有不同的意义。但是矩阵分解只能简单利用网络最直接的拓扑结构，完全无法考虑两个结点之间多跳路径的信息，所以比较局限。</p>
<p>随机游走作为另一类嵌入方法，弥补了矩阵分解在上下文方面的不足之处，对每个结点可以生成一个低维向量，包含结点的拓扑信息，两个结点如果多次出现在同一条随机游走序列中，那么他们的结点嵌入表示也应该是相似的。通过得到结点的嵌入表示，然后再利用传统的相似度计算方法，可以完成链路预测任务，不过这种方法一般效果不好，因为他们学习机制比较简单，难以改进，实际的拟合效果也一般，再通过简单的相似性计算显然不能得到精确的结果。</p>
<p>由于图是非欧几里得空间的数据，完全不存在空间上的上下左右关系，而只有连接关系，所以用CNN等方法无法对这种数据完成很好的效果，因为不规整的图往往无法定义结点或边的顺序如何，况且想要让一般的神经网络处理图必须要让图的结构转化成规整的形式。也就是说，解决同构图问题也是对传统神经网络的一大挑战，CNN处理欧几里得空间的数据，具有平移不变性和旋转不变性；而GNN处理图，则需要具有置换不变性，也就是对具有某种特征的结点，标号顺序的不同将不会导致最终表示有所差别。如下图，使用CNN一样的方式对邻接矩阵进行卷积，得到的显然是不同的结果，但是这两个图除了标号外完全一样。<br><img src="/2022/10/08/WSEAL/3.jpg" alt="场景"></p>
<p>GNN除了解决图同构的问题，保证了置换不变性，还可以进一步优化随机游走方法得到的表示。通过邻接矩阵和特征矩阵，GNN汇聚结点的邻居特征信息，可训练参数进行进一步调整，最终得到结点最有用的全局嵌入表示，用这些高质量的信息作为输入，分类器可以达到很好的效果。当然，普通的GNN在一些网络的上表现还不如传统方法，这就要提到GCN另一个问题了。</p>
<p>总之，分析不同的预测方法后，结合实验结果，可以确定GNN是最有前景的一类方法了，但绝不是简单的GNN，还需要对GNN存在的问题再深入解决。</p>
<h1 id="GCN的缺陷：添加Labeling-Trick"><a href="#GCN的缺陷：添加Labeling-Trick" class="headerlink" title="GCN的缺陷：添加Labeling Trick"></a>GCN的缺陷：添加Labeling Trick</h1><p>图具有置换不变性，设计的GCN围绕这一点实现了正确的结构，并不会因为邻接矩阵的不同导致不同的结果。但是，区分同构图仍热是具有挑战的问题。我们之前说，链路预测问题是一个双节点表示问题，前面著名的工作GAE训练得到结点的完整表示后，通过两个点的表示相似性来计算这两个结点产生连接的可能。而另一个著名的工作SEAL同样基于GNN，却实现了非常好的性能，这里有两个不同的地方，一个是SEAL使用了结构标签作为显式特征输入，GAE没有；另一个是GAE对链路连接性的评价方式很简单，聚合两个结点的表示并不能得到这条链路的表示，不足以支撑完成链路预测的任务。</p>
<p>第一个问题就可以通过Labeling Trick的添加完成，对一组同构结点，GCN会给这两个结点以相同的结点表示，而且还不能区分这组结点与其他结点的结构表示，意味着对相同的一个结点，GCN会给这个结点与前面两个同构结点分别连接的链路以相同的链路表示，因为GCN简单地聚合两个结点的表示作为这条链路的表示。Labeling Trick通过对不同的链路附加一个标签，作为特征信息，可以让GCN拥有区分两个同构点对其他不同点的能力。直观表示如下：<br><img src="/2022/10/08/WSEAL/4.jpg" alt="场景"><br>v2和v3同构，但是(v1,v2)与(v1,v3)在GCN中会得到相同的表示；添加Labeling Trick后，v2,v3的表示不同，对两条链路的最终表示也就不同了。</p>
<p>第二个问题可以通过网络自主学习完成，即收集所有结点的信息，用其他网络进行训练即可。</p>
<p>这样一来，GCN既可以区分同构点的相对位置，同时也有办法聚合多个点的信息得到所有链路表示，就完成了预测任务。这就是SEAL。</p>
<h1 id="SEAL的缺陷"><a href="#SEAL的缺陷" class="headerlink" title="SEAL的缺陷"></a>SEAL的缺陷</h1><p>相比于对图进行训练，子图显然信息有限，因为抓取子图以后，子图外面一些motif被断开了，导致在子图中，处于motif结构中的链路和不在motif中的链路表现出相同的拓扑结构，但是实际上处于motif中的链路显然是更重要的。因此，我们应该寻找一个办法探测这些处于motif中的链路，并在汇聚的同时给他们更高的权重。这样，一条motif链路连接的两个点就比其他点具有相对更高的重要性，相互汇聚的信息就会更多。</p>
<p>关于如何探测这种motif链路，有文章提出一种Katz指数计算的方法，即以预测链路为准，目标链路和预测链路总共有四个结点，将这四个结点对应的四个链路的Katz指数求和，作为最终的链路分数，替换邻接矩阵供结点进行汇聚。这样，GCN汇聚的同时就是有偏的了。进一步的，可以尝试其他统计指标，用类似的方式为这些无权的边进行赋权，从而让子图能够对不同的边加以区别，重点要让motif中的边突出，将带来三个好处：</p>
<ul>
<li>GNN聚合过程中，节点可以区别对待联系紧密和不紧密的邻居节点，提高了学习能力；</li>
<li>边权包含了全局信息，提供了子图中没有的信息；</li>
<li>增加了GNN学习的信息，提高表达上限；</li>
</ul>
<h1 id="赋权网络的缺陷"><a href="#赋权网络的缺陷" class="headerlink" title="赋权网络的缺陷"></a>赋权网络的缺陷</h1><p>即便采用了上面的赋权方法，仍然有一个问题难以解决：泛化性。GNN作为泛化解决链路预测问题的范例，从聚合到读出都应该使用机器学习的方法，而使用上面根据某个指标进行赋权的方法显然不能达到泛化的要求，这正是启发式方法的缺点，如果有办法解决这个问题，GNN通过学习子图结构解决链路预测问题的方法应该可以得到提升。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Deep Learning</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>GNN</tag>
        <tag>Link Prediction</tag>
        <tag>Weighted Subgraph</tag>
        <tag>SEAL</tag>
      </tags>
  </entry>
  <entry>
    <title>竞赛常用数据结构和算法</title>
    <url>/2023/03/17/classicDA/</url>
    <content><![CDATA[<p>记录一些常用的竞赛数据结构和算法，当然不包括基本知识，包含的内容是：线段树，并查集，差分数组，期望DP，博弈，数论基础。</p>
<span id="more"></span>
<h1 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h1><p>算法竞赛中经常会因为数据声明不到位而产生误差和错误，要对数据运算有清晰的把握，需要多开的时候完全不用精打细算。</p>
<ul>
<li>int：10^9</li>
<li>long long：10^18</li>
</ul>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>几乎是算法竞赛中最常用的数据结构，用来维护区间信息，能实现对数级别复杂度的区间修改，重点是只能处理满足结合律的问题。</p>
<p>线段树是一个平衡二叉树，每个父亲节点代表区间信息，因此最上面的父节点就代表整个区间的信息；此外，每个节点还对应了一个区间，也就是所谓的线段，线段信息就是节点存储的值。例如一个数组[1,2,3,4,5]的线段树如下，定义区间信息为区间内的数字和：</p>
<p><img src="/2023/03/17/classicDA/11.jpg" alt></p>
<p>下面是具体的模板，一般采用树状数组来实现线段树，学过数据结构可以知道，此时一个节点下标为k，那么它的左儿子下标是2k，右儿子是2k+1，父亲节点下标是floor(k/2)，以这样的规则建立线段树和维护线段树。</p>
<h2 id="建立线段树和维护线段树关系"><a href="#建立线段树和维护线段树关系" class="headerlink" title="建立线段树和维护线段树关系"></a>建立线段树和维护线段树关系</h2><p>首先根据线段树的性质，假设元素个数$n=2^h$(就是说最后一行有$2^h$个元素为全部的元素)，h就是线段树的高度，这里不论n是不是2的幂函数都无所谓，因为最后一行可能不会全部用到，可以先这样假设。因此总共要存储的节点数为$1+2+4+8+…+2^h=2^{h+1}-1=2<em>2^h-1=2n-1$，空间复杂度是$O(2n)$，但是在实际使用中，我们只要找到一个可以满足n需要的h，让$2^{h-1}&lt;=n&lt;=2^h$，那么显然$2^h&lt;=2n$，因此之前计算的复杂度进一步扩充应该是$2</em>2^{h}-1 &lt;= 2*2n-1$，所以开4n的空间，没必要精打细算。</p>
<p>而线段树的维护则是从最下层开始的，因为每个元素更新以后才能逐层往上更新，这就是线段树的维护。这里以区间和跟区间最大值为例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//线段树</span></span><br><span class="line"><span class="type">int</span> tree[n*<span class="number">4</span>];</span><br><span class="line"><span class="comment">//数据</span></span><br><span class="line"><span class="type">int</span> ans[n];</span><br><span class="line"><span class="comment">//取左儿子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取右儿子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//维护区间和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">load_sum</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p] = tree[<span class="built_in">ls</span>(p)] + tree[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//维护区间最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">load_max</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p] = <span class="built_in">max</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归建树</span></span><br><span class="line"><span class="comment">//建树过程涉及前面的全部函数，所以可以从build开始写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这是懒标记初始化，后面会说</span></span><br><span class="line">    mark[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[p] = ans[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//递归到左儿子和右儿子</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p),l,mid);</span><br><span class="line">    	<span class="built_in">build</span>(<span class="built_in">rs</span>(p),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">load_sum</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间修改和“懒”标记"><a href="#区间修改和“懒”标记" class="headerlink" title="区间修改和“懒”标记"></a>区间修改和“懒”标记</h2><p>对于区间修改，朴素的想法是改动叶子的值后像建树一样递归上去，但是通过懒标记可以大大降低这个时间复杂度。懒标记就是给需要修改的所有区间进行一次标记，因此这个懒标记是从上传递到下面的，表示当前区间已经更新过，但是子区间没有更新，以及更新的信息是什么。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给区间[l,r]内的元素全部加上k，当前在p点</span></span><br><span class="line">ll mark[<span class="number">4</span>*n];</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递懒标记到p的下层，并清除当前的懒标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(ll p, ll l, ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//更新左子树</span></span><br><span class="line">    mark[<span class="built_in">ls</span>(p)] += mark[p];</span><br><span class="line">    tree[ls[p]] += mark[p] * (mid - l + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//更新右子树</span></span><br><span class="line">    mark[<span class="built_in">ls</span>(p)] += mark[p];</span><br><span class="line">    tree[p] += mark[p] * (r - mid);</span><br><span class="line">    mark[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新元素值，t代表目标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll tl, ll tr, ll l, ll r, ll p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//要修改的区间包含当前区间则标记当前区间并直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=l &amp;&amp; r &lt;= tr)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[p] += k*(r-l+<span class="number">1</span>);</span><br><span class="line">        mark[p] += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传递懒标记，此时还没有递归到下层</span></span><br><span class="line">    <span class="built_in">save</span>(p,l,r);</span><br><span class="line">    ll mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//目标区间涉及左子树区间，递归更新左子树</span></span><br><span class="line">    <span class="keyword">if</span>(tl &lt;= mid)</span><br><span class="line">        <span class="built_in">update</span>(tl,tr,l,mid,<span class="built_in">ls</span>(p),k);</span><br><span class="line">    <span class="comment">//目标区间涉及右子树区间，递归更新右子树</span></span><br><span class="line">    <span class="keyword">if</span>(tr&gt;mid)</span><br><span class="line">        <span class="built_in">update</span>(tl,tr,mid+<span class="number">1</span>,r,<span class="built_in">rs</span>(p),k);</span><br><span class="line">    <span class="comment">//已经递归完左右子树了，回到上层更新节点值</span></span><br><span class="line">    <span class="built_in">load_sum</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归结起来就是三个步骤：</p>
<ul>
<li>判断当前区间是否包含于被修改区间，是则给当前区间添加懒标记并返回；否则下一步；</li>
<li>传递当前层的标记到下一层；</li>
<li>递归传递左右子树；</li>
<li>更新并返回上层节点。</li>
</ul>
<p>值得注意的是，如果当前区间被包含于目标区间，更新函数直接返回了，因此这个节点之下的其他节点并没有更新，这就是懒的地方，虽然没有更新下面的节点，但是这个点已经有了懒标记并且没有被save清空，也就是说，这一步以后线段树的状态是这个节点的值更新了，并且打上了标记，但是它的子树并没有更新，仍然是原来的状态。</p>
<p>显然这会导致部分错误，但是，线段树的精髓就在于懒标记，我们完全可以在查询的时候将这个没有传递的懒标记传递下去，从而保证查询结果的正确；而那些没有懒标记的节点即使传递了懒标记也不会出现问题，因为它们的懒标记应当为0，除非它们的某个祖先节点为他们传递了懒标记。</p>
<p>因此，懒标记实际上记录的是修改的操作值，而不仅仅是要不要修改的flag。</p>
<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll qx, ll qy, ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//查询区间包含当前区间，返回当前区间的值</span></span><br><span class="line">	<span class="keyword">if</span>(qx&lt;=l &amp;&amp; r &lt;= qy)</span><br><span class="line">		<span class="keyword">return</span> tree[p];</span><br><span class="line">	ll mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//否则传递到下面继续查询</span></span><br><span class="line">	<span class="built_in">save</span>(p,l,r);</span><br><span class="line">    <span class="comment">//涉及左子树</span></span><br><span class="line">	<span class="keyword">if</span>(qx &lt;= mid) </span><br><span class="line">		res += <span class="built_in">query</span>(qx,qy,l,mid,<span class="built_in">ls</span>(p));</span><br><span class="line">    <span class="comment">//涉及右子树</span></span><br><span class="line">	<span class="keyword">if</span>(qy &gt; mid)</span><br><span class="line">		res += <span class="built_in">query</span>(qx,qy,mid+<span class="number">1</span>,r,<span class="built_in">rs</span>(p));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在设计线段树维护的信息的时候要注意两个地方，一个是怎么安排懒标记或者信息的初值，例如在洛谷线段树2模板中，要求同时支持加和乘两种操作，由于两种操作的懒标记意义不同，因此要维护两个标记，其中加操作的懒标记显然初植为0，而乘操作的懒标记则需要为1的初植；另一个是查询时的懒标记传递函数怎么确定，前面的问题中，我们只能在查询的时候才能将懒标记传递下去，因此对左右子孙的更新要先乘法再加法，如果先加法，那么在加法之前的乘法会多乘，显然是错的。</p>
<h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><p>前面线段树有提到区间操作这个概念，对一个数组来说，直接随机存取后虽然能很快地查询每个元素值，但是并不利于修改整个数组区间的值，或者查询数组区间的值，因为大量的遍历显然会很大程度地浪费时间，换句话说随机存取的数组方便进行单点操作而不便进行区间操作。</p>
<p>有个方法叫前缀和，比较简单，就是记录数组累加或者其他的一些操作，从而方便进行区间查询，对单点查询一般也可以实现随机存取，但是并不能方便单点和区间修改，因为无论什么修改操作都只能让后面的数组重新更新一遍。</p>
<p>线段树则比较全面，查询和修改都是对数级别，泛用性比较强。</p>
<p>因此，除去普通数组，我们现在知道前缀和方便查询，线段树对查询修改都不错，最后还要介绍一个差分数组，当然就是方便修改了，对区间和单点修改，它的复杂度都是$O(1)$级别的。</p>
<p>简单来说，差分数组存储的就是当前元素和前一个元素的差值，就像下面这样：</p>
<p><img src="/2023/03/17/classicDA/12.png" alt></p>
<p>区间修改利用了差分数组的性质，试着将序号为[2,4]内的所有元素全部加3，那么差分数组中实际上只有序号为2，5的两个元素发生了改变，前者减3，后者加3，也就是说对区间[l,r]修改后差分数组中只有l和r+1发生改变，前者改变相同，后者改变相反，而中间的元素并不会发生改变，这样以来就实现了修改的$O(1)$操作。</p>
<p>更有意思的是，差分数组的前缀和就是原数组！这就是从差分数组求原数组的方法。</p>
<p>总结一下，方便区间查询用前缀和，方便区间修改用差分数组，都需要的话要么同时前缀和+差分，要么线段树。</p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>维护一个类似树的数据结构，其中的含义是每个树作为一个集合，其中的根节点是集合代表元素，而子节点属于这个集合，从而表示一种从属关系，将不同的数据分成不同集合。可以用数组来实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fa[max]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组存储每个节点的父节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(i)] = <span class="built_in">find</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将节点i合并到节点j的集合中，也就是将节点i的最终的父结点设置为j的最终父结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓最终父节点就是节点所在集合的代表元素，通过递归的方式查询，确定从属于哪一个集合。</p>
<p>此外还有一个称为路径压缩的操作，将一个代表元素下的所有的子元素的父结点都直接设置为这个代表元素，这样就不用通过慢慢递归的方式查询了，因此可以在第一次查询的时候进行一次维护，也就是路径压缩，将子结点的子结点变成子结点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = <span class="built_in">find</span>(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>并查集的推广，有些情况下不仅要记录不同元素之间的关系，还要记录他们之间某个相关联的值，此时声明另一个数组val来将连边上的值存储为节点上的值，方便查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fa[max];</span><br><span class="line"><span class="type">int</span> val[max];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[i] = i;</span><br><span class="line">		val[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//路径压缩</span></span><br><span class="line">        <span class="comment">//注意这里必须是先查father再更新value</span></span><br><span class="line">        <span class="comment">//递归的时候让value从根节点往下更新到当前节点</span></span><br><span class="line">        <span class="comment">//先find再更新value根本原因是，递归过程中可能把前面的节点路径压缩了</span></span><br><span class="line">        <span class="type">int</span> tmp = fa[x];</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">		val[x] += val[tmp];</span><br><span class="line">		<span class="keyword">return</span> fa[x];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> px = <span class="built_in">find</span>(i);</span><br><span class="line">	<span class="type">int</span> py = <span class="built_in">find</span>(j);</span><br><span class="line">	<span class="keyword">if</span>(px != py)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[px] = py;</span><br><span class="line">		val[px] = val[j] + weight - val[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带权并查集的合并比较难理解，可以通过下图这样计算理解：</p>
<p><img src="/2023/03/17/classicDA/1.png" alt></p>
<p>当然也不全是这样计算权值，有些题目中可能会进行取模乘除等操作，要参考具体情况。</p>
<h1 id="期望DP"><a href="#期望DP" class="headerlink" title="期望DP"></a>期望DP</h1><p>相比于普通的动态规划，期望DP主要是在求期望的递推式，常见的一种做法是，定义dp[i]为在第i个状态下，到达目标dp[n]还需要的花费，因此可以利用期望的线性可加性质计算dp[i]的状态为$dp[i] = p_1 dp[j]+p_2dp[k]+1$，注意后面可能还要加1，这是因为有时候题目表述下无论dp为何种状态，总是要先进行一次花费才能转移状态，因此每次要迭代加上一个1。此外还有很多期望DP的问题，不一定利用这种类似全概率公式的方式推导，这里暂时不记录了。</p>
<p>下面是一道典型例题，问有T组测试，每个测试输入一个n，表示一个n面的骰子，问期望投几次才能投到所有的面。</p>
<p>思路：定义dp[i]为摇到第i种点数时，还要摇到n种点数的期望，那么可以判断，dp[i]时再摇一次有两种可能，即摇到前面i种点数之一和摇到新的点数了，因此写出方程$dp[i] = dp[i+1] <em> (n-i)/n + i/n </em> dp[i] + 1$，也就是说摇到前面的点数那么期望就是现在的dp[i]，有新的点数就将状态转移到下一个dp[i+1]，最后无论是否转移状态，都要摇一次骰子，因此还要加1。化简这个式子得到状态转移方程：</p>
<p>$dp[i] = dp[i+1] + n / (n-i)$</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="type">double</span> dp[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		dp[n] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = dp[j+<span class="number">1</span>] + (<span class="type">double</span>)n / (<span class="type">double</span>)(n-j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, dp[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="博弈相关"><a href="#博弈相关" class="headerlink" title="博弈相关"></a>博弈相关</h1><p>有许多游戏可以通过博弈来确定最佳策略，从而达到先手或者后手必胜的情况，根据策梅洛定理，这类游戏满足五个特点：</p>
<ul>
<li>双人、回合制；</li>
<li>信息完全公开（perfect information）；</li>
<li>无随机因素（deterministic）；</li>
<li><p>必然在有限步内结束；</p>
</li>
<li><p>没有平局；</p>
</li>
</ul>
<p>可以通过必胜态和必败态的转换情况，最终确定玩家先手胜利还是后手胜利。采用模拟的办法来记录，判断条件为下面三个：</p>
<ul>
<li>游戏终局是必败态，取决于游戏规则，如果当前局面下玩家已经无路可走，那么就是必败态，这位玩家的上一位就赢了；</li>
<li>某个状态进行一步游戏操作后，如果只能转变为必胜态，那么这个状态就是必败态（通过操作将必胜态给了对手）；</li>
<li>某个状态进行一步游戏操作后，如果至少存在一个必败态，那么这个状态就是必胜态（通过操作将必败态给了对手）；</li>
</ul>
<p>因此对于博弈问题，可以确定某个状态的玩家必胜还是必败。竞赛中给出打表和DFS两种模板。打表还不明白，先介绍DFS的一般做法。</p>
<h2 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h2><p>其实就是先DFS再记录，然后拷贝进来根据输入直接输出，所以其实没啥区别。</p>
<p>打表方法就是竞赛中简单的暴力方法，只不过打表要求数据有限多(指你方便暴力循环后重新复制一遍)，然后复制进代码里直接输出，就不会超时了。</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>其实DFS就是暴力方法，只不过结合了博弈论的判断方法，加快了终止。一个博弈游戏因为两个人的决策会出现许多分支，那么我可以把这些分支像树的节点那样全部记录下来，同时判断出这些分支的状态是必胜还是必败，如果一个节点后面的状态是终局，那么就结束；如果后面的状态都是必胜态，那么当前这位玩家处于必败态，同样可以结束；如果后面的状态存在必败态，那么选择这个必败态继续遍历(因为没必要让对手得到必胜态)，这也是选择DFS而不是BFS的原因。</p>
<p>也就是说，DFS解决这种博弈问题就是写check函数和遍历函数，这两个确定了之后就都能常规处理。</p>
<p>下面是2022年蓝桥杯第二题的解法，就是经典的nim博弈游戏，用递归dfs解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checklast</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二元数组记录dfs情况</span></span><br><span class="line">map&lt;string, <span class="type">bool</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//m中存在s，直接将刚才判断的状态返回</span></span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">count</span>(s) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> m[s];</span><br><span class="line">    <span class="comment">//如果s是终局状态，也就是必败态，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checklast</span>(s) == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> m[s] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//对没有判断过，也不是终局的状态进行递归dfs</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp = s;</span><br><span class="line">            tmp[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="comment">//能转移到必败态都是必胜态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(tmp) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> m[s] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i+<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; i != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp = s;</span><br><span class="line">            tmp[i] = tmp[i+<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="comment">//能转移到必败态都是必胜态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(tmp) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> m[s] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一次都不能转移到必败态，只能转移到必胜态，此时当前状态则是必败</span></span><br><span class="line">    <span class="keyword">return</span> m[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s[] = &#123;<span class="string">&quot;10000000&quot;</span>, <span class="string">&quot;11000000&quot;</span>, <span class="string">&quot;01000000&quot;</span>, <span class="string">&quot;01100000&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(s[i]) == <span class="literal">true</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;L&quot;</span>;<span class="comment">///此时为必胜态，说明后手面临的局面必胜，输出L</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;V&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h1><p>数论是数学的分支，研究整数的性质，自然在计算机中就有很大用处。不过我们竞赛过程中也没必要完全掌握，下面是竞赛中常见的数论内容，并且以C++的处理为主，对于某些问题(例如对负数取模)不同语言结果不同，这一点要注意。</p>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>在竞赛中会出现一些比较大的数字，没办法直接输出或者计算，采用模运算来减小规模。编程上取模运算就是%，但是要注意左操作数（被除数）的正负，因为在C++中，如果有负数参与了取模运算，遵循以下规则：</p>
<ul>
<li>结果的符号只于左操作数有关；</li>
<li>结果的绝对值等于操作数绝对值的模运算；</li>
</ul>
<p>这种模运算定义被称为<strong>truncated division</strong>，Java和C都采用这种定义。Python采用的是<strong>floored division</strong>，可以自行了解。</p>
<p>模运算具有一些基本定理：</p>
<ul>
<li>和的模运算=模运算的和取模；</li>
<li>差的模运算=模运算的差取模；</li>
<li>积的模运算=模运算的积取模；</li>
</ul>
<p>除法则没有这个性质。通过这些定理可以防止数据溢出，从而计算大的数据。例如，下面的程序计算了(a*b)%m的结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a = a%m;</span><br><span class="line">	b = b%m;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(b &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) </span><br><span class="line">            res = (res + a) % m;</span><br><span class="line">		a = (a + a) % m;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用了乘法的性质，同时还利用了快速幂运算(while循环，后面会说)，先得到a、b的模运算结果，然后要计算积的模运算，此时将a、b看成二进制，b作为乘数，最低位如果是奇数，那么结果中就会有a取模的结果，再将a移动到高一位，乘以2，然后b移动到低一位，除以2，最终当b已经运算完了最高位，那么就得到结果。</p>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>直接做幂运算，那么显然a^n%m的时间复杂度是log(n)，如果采用快速幂运算方法，降低到对数级别。思想就是分治，下面的代码计算了a^n%m的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">fastPow</span><span class="params">(ll a, ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    a %= m;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % m;</span><br><span class="line">        a = (a  * a) % m;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上面的例子差不多，都是利用模运算性质后进一步优化乘法，这里a不断相乘，指数翻倍，从而减少乘法运算。</p>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p><img src="/2023/03/17/classicDA/2.png" alt></p>
<p>可以用来求乘法逆元。将快速幂和费马小定理结合，通常用来处理x/y%m形式的数据，求出y的乘法逆元$y^{-1}$，就得到$x*y^{-1}\%m$，从而防止了精度丢失，对大数据的运算很有用。22年蓝桥杯E题爬树的甲壳虫需要用这个方法。</p>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>原理和普通的快速幂相似，定义矩阵乘法后，可以用几乎相同的代码计算，依然是分治的思想：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span> &#123;<span class="type">int</span> m[N][N];&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="type">const</span> matrix &amp;a, <span class="type">const</span> matrix &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="built_in">memset</span>(c.m, <span class="number">0</span>, <span class="built_in">sizeof</span>(c.m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;<span class="comment">//如果数字大可以取模</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">matrix <span class="title">fastPow</span><span class="params">(matrix a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix ans;</span><br><span class="line">    <span class="comment">//初始为单位矩阵</span></span><br><span class="line">    <span class="built_in">memset</span>(ans.m, <span class="number">0</span>, <span class="built_in">sizeof</span>(ans.m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.[i][i] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵快速幂的时间复杂度是$O(N^3\log(n))$，通常会给出一个较大的n和较小的N来考察。</p>
<h3 id="应用到dp问题"><a href="#应用到dp问题" class="headerlink" title="应用到dp问题"></a>应用到dp问题</h3><p>矩阵快速幂可以用于解决部分能化简成幂函数形式的dp问题，将递归数列的递推关系转化为矩阵乘法，所以递推数列就能转化为幂函数，最后就可以应用快速幂得到结果。</p>
<p><img src="/2023/03/17/classicDA/3.png" alt></p>
<p><img src="/2023/03/17/classicDA/4.png" alt></p>
<p>垒骰子这道题考察得比较隐蔽，dp可以想到，如何转化为快速矩阵幂不容易想。<br><img src="/2023/03/17/classicDA/5.png" alt><br>这里通过手推找到规律，确定幂函数的底数a是六行六列的矩阵，其中每个元素表示确定了下面骰子以j为顶面且确定了位置时上面骰子以i为顶面的方案数为4，就将问题转化成矩阵快速幂了，最后求出n-1次方，然后取模即可。</p>
<h3 id="应用到图的最短路径"><a href="#应用到图的最短路径" class="headerlink" title="应用到图的最短路径"></a>应用到图的最短路径</h3><p>可以计算出赋权图上只经过m条边的最短通路长度，因为这个本来是通过邻接矩阵的幂函数实现的，邻接矩阵的m次方代表经过m条边的路径数，那么显然就可以通过快速幂计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">matrix <span class="title">fastPow</span><span class="params">(matrix adj, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix ans = a;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出重要的其实就是while内部的操作，这里将ans赋值为单位矩阵也可以的，只不过要多计算一次a和单位矩阵的乘法。</p>
<h2 id="GCD和LCM"><a href="#GCD和LCM" class="headerlink" title="GCD和LCM"></a>GCD和LCM</h2><p>最大公约数和最小公倍数有很多性质：</p>
<ul>
<li>$gcd(a,b) = gcd(a,a+b) = gcd(a,k*a+b)$</li>
<li>$gcd(ka,kb) = k * gcd(a,b)$</li>
<li>$gcd(a,b,c) = gcd(gcd(a,b), c)$</li>
<li>如果$gcd(a,b)=d$，那么$gcd(a/d,b/d)=1$</li>
<li>$gcd(a+cb,b)=gcd(a,b)$</li>
<li>辗转相除法：$gcd(a,b)= gcd(b, a\%b)$</li>
<li>$gcd(a,b)<em>lcm(a,b)=a</em>b, lcm(a, b) = a<em>b/gcd(a, b) = a/gcd(a, b)</em>b$</li>
</ul>
<p>还是要多做题才方便记住这些定理。</p>
<h3 id="贝祖定理"><a href="#贝祖定理" class="headerlink" title="贝祖定理"></a>贝祖定理</h3><ul>
<li><p>如果$gcd(a,b) = d$，那么对任意的$x,y$一定有$ax+by$是$d$的倍数</p>
</li>
<li><p>推论：$a,b$互质，那么存在$x,y$使得$ax+by=1$</p>
</li>
</ul>
<p><img src="/2023/03/17/classicDA/6.png" alt></p>
<p><img src="/2023/03/17/classicDA/7.png" alt></p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>用于求出$ax+by=gcd(a,b)$时的x，y和最大公因数。这个方程可以写成二元线性丢番图方程$ax+by=c$，这个方程有解的充要条件就是$c$能被$gcd(a,b)$整除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">extend_gcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;<span class="comment">//如果辗转相除到b为0，此时a就是最大公因数了</span></span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//递归调用，每次辗转相除找最大公因数，并交换x，y</span></span><br><span class="line">  <span class="comment">//这是因为在递归结束后要更新此时x，y的值，根据辗转相除法得到</span></span><br><span class="line">  <span class="comment">//如果里层递归时的值为x1和y1，那么外层的x应该等于y1，y等于按照下面式子更新后的值</span></span><br><span class="line">  <span class="comment">//才能保证ax+by=gcd(a,y)，推导见代码块之后</span></span><br><span class="line">  ll d = <span class="built_in">extend_gcd</span>(b, a % b, y, x);</span><br><span class="line">  </span><br><span class="line">  y -= a / b * x;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>$b <em> x1 + (a \% b) </em> y1 = gcd(b, a \% b)$</li>
<li>$a <em> x + b </em> y = gcd(a, b)$</li>
<li>$gcd(a,b) = b <em> x1 + (a - (a/b)</em>b) <em> y1     = a </em> y1 + b <em> (x1 - (a/b)</em>y1)$</li>
</ul>
<p>以上是推导过程。此时已经求出一个方程的特解(x,y)，其通解为$x^<em> = x_0+(b/gcd(a,b))</em>t,y^<em>=y_0-(a/gcd(a,b))</em>t$。利用通解我们可以进一步求出这个方程的最小正整数解，将x，y分别对$b/gcd(a,b)$和$a/gcd(a,b)$取正整数即可。</p>
<p>下面是一个实例：</p>
<p><img src="/2023/03/17/classicDA/8.png" alt></p>
<p>在这里两个地方要注意，一个是列出线性同余方程，这一步是关键；其次输出的时候为了保证x不是负数，要通过上面的取模处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = x * c / d;//求出初步的特解</span><br><span class="line">x = (x % (L/d) + L/d);//将x转化为正整数，这里L/d从扩展欧几里得算法中的x通解得来</span><br><span class="line">x = x % (L/d);//再次取模，如果x之前为负，这里没用；否则这里就是除去之前加上的一个L/d</span><br></pre></td></tr></table></figure>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>基本定理：</p>
<ul>
<li>有无穷多个素数，从小到大分布越来越稀少；</li>
<li>对任意整数n，存在n个连续的合数；</li>
<li>小的素数判断，只需要遍历到这个数的平方根处，因为不可能会有两个大于它平方根的数相乘得到这个数；</li>
</ul>
<h3 id="大素数检验"><a href="#大素数检验" class="headerlink" title="大素数检验"></a>大素数检验</h3><h4 id="费马素性检验"><a href="#费马素性检验" class="headerlink" title="费马素性检验"></a>费马素性检验</h4><p>基于费马小定理的逆定理，如果两个数a，n互质，那么，$a^{n-1}\equiv 1 \pmod n$。从1~n中选择一个数a来验证即可。</p>
<h4 id="Miller-Rabin素性检验"><a href="#Miller-Rabin素性检验" class="headerlink" title="Miller-Rabin素性检验"></a>Miller-Rabin素性检验</h4><p>如果存在$x$使得$x^2 \equiv 1 \pmod n,x \not= 1或n-1$，那么n是合数。</p>
<p>步骤：</p>
<ul>
<li>找到一个$t$和$u$使得$n- 1 = 2^t * u$；</li>
<li>找到一个$x_0$和$a$使得$x_0^2 = a^u \% n$；</li>
<li>递推$x<em>t = x</em>{t-1}^2 \% n$;</li>
<li>对最后的$x<em>t$判断，如果$x_t \not = 1$，且$x_t^{n-1} \not \equiv 1 \pmod n$，那么证明$n$是合数；对每个$x_t$判断，如果$x_t = 1$，而且$x</em>{t-1} \not = 1或n-1$，也证明n是合数。</li>
<li>注意，要对所有选择过的$x_t$都进行判断后才能输出，因为费马小定理对合数不一定正确，只要求两个数互质，因此即便满足了$x_t^{n-1} \equiv 1 \pmod n$也不能说n就是质数，除非确定此时的$x_t$是质数。但是，只要不符合这个条件，$n$就一定不是质数，所以费马小定理的逆定理仅作为判断合数的充分条件。</li>
</ul>
<p>如果遍历完选择的$t$个$x_t$后，条件都满足合数，那么就判断是合数，一般这样测试五十次就够了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">witness</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll u = n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//求出u和t</span></span><br><span class="line">    <span class="keyword">while</span>(u$l == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//看n-1能被2整除几次得到t</span></span><br><span class="line">        u = u&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x1, x2;</span><br><span class="line">    x1 = <span class="built_in">fast_pow</span>(a,u,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x2 = <span class="built_in">fastPow</span>(x1,<span class="number">2</span>,n);</span><br><span class="line">        <span class="comment">//如果满足第二个条件，说明是合数，存在非平凡平方根</span></span><br><span class="line">        <span class="keyword">if</span>(x2 == <span class="number">1</span> &amp;&amp; x1 !=<span class="number">1</span> &amp;&amp; x1 != n<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        x1 = x2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果满足第二个条件，即不满足费马小定理，那就是合数</span></span><br><span class="line">    <span class="keyword">if</span>(x1 != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//都没检测出来，大概率是质数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">miller_rabin</span><span class="params">(ll n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1既不是质数也不是合数</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2是质数</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//偶数是合数</span></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//做s次测试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s &amp;&amp; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a通过随机数确定，1~n-1</span></span><br><span class="line">        ll a = <span class="built_in">rand</span>() % (n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">witness</span>(a,n))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><p>给定一个素数p，那么：</p>
<ul>
<li>$((p-1)!+1)\%p=0$</li>
<li>$(p-1)!\%p=p-1$</li>
<li>$(p-1)!=kp-1$</li>
<li>$(p-1)! \equiv -1 \pmod p$</li>
</ul>
<p>对合数：除4外，(n-1)!肯定有两个数积为n的倍数。</p>
<p><img src="/2023/03/17/classicDA/9.png" alt></p>
<p>对这个题来说，n=4的时候单独计算，其余的n都是0。</p>
<h3 id="素数筛和合数分解质因数"><a href="#素数筛和合数分解质因数" class="headerlink" title="素数筛和合数分解质因数"></a><strong>素数筛和合数分解质因数</strong></h3><p>素数筛可以找出小于数n的所有质数。</p>
<h4 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h4><ul>
<li>埃氏筛：找到一个素数，筛去它所有的倍数；遍历所有小于n的数，输出没有被标记为合数的数，就是全部的质数；</li>
<li>欧拉筛：初始将所有数标记为素数isPrime，然后开始遍历，对标记为素数的数，添加到素数组Prime中并遍历Prime，筛去它所有已知素数倍数的合数，并且筛去后判断当前的这个数是否是Prime中某个素数的倍数，这样能保证每个合数只被它最小质因数筛选一次，例如对2标记为素数后，只筛去4；3标记为素数后，筛去6，9；4标记为合数，不加入Prime，筛去8，12；5标记后筛去10，15，25；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> prime[MAXN+<span class="number">1</span>];</span><br><span class="line"><span class="type">bool</span> isprime[MAXN+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isprime,<span class="literal">true</span>,<span class="built_in">sizeof</span>(isprime));</span><br><span class="line">    isprime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isprime[i] == <span class="literal">true</span>)</span><br><span class="line">            prime[++count] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= count &amp;&amp; i * prime[j] &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            isprime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合数分解"><a href="#合数分解" class="headerlink" title="合数分解"></a>合数分解</h4><ul>
<li>试除法：用筛后的素数去除；如果有素数整除了n，那么用这个数再除，直到不能整除，记录这个素数，用下一个素数继续遍历以此类推；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//试除法</span></span><br><span class="line">ll factor[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> facount;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFactors</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    facount = <span class="number">0</span>;</span><br><span class="line">    ll tmp = x;</span><br><span class="line">    <span class="comment">//只需要遍历到平方根即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; prime[i] &lt;= tmp/prime[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//factor[i][0]记录n被prime[i]整除</span></span><br><span class="line">        <span class="comment">//factor[i][1]记录n能被几个prime[i]整除</span></span><br><span class="line">        <span class="comment">//没有达到终止条件就要继续找下一个素因数，而不是用上次剩下的tmp作为最后的素因数</span></span><br><span class="line">        factor[facount][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//看n能不能整除素数prime[i]</span></span><br><span class="line">        <span class="keyword">if</span>(tmp % prime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录这次整除到多少</span></span><br><span class="line">            factor[facount][<span class="number">0</span>] = prime[i];</span><br><span class="line">            <span class="comment">//循环整除到几次</span></span><br><span class="line">            <span class="keyword">while</span>(tmp%prime[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                factor[facount][<span class="number">1</span>]++;</span><br><span class="line">                tmp /= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">            facount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录剩下多少tmp，作为最后一个因数</span></span><br><span class="line">        <span class="keyword">if</span>(tmp!=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            factor[facount][<span class="number">0</span>] = tmp;</span><br><span class="line">            factor[facount++][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> facount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Pollard_rho启发式方法；</li>
</ul>
<p>该方法采用随机数的方式选择试除对象，根据生日悖论提供一个以两个数绝对值作为除数的方法，不同的组合可以增加这个数是因数的概率，从而在判断中快速找到因数。而构造的序列$x<em>i=(x</em>{i-1}^2+C)%N$会构成一个$\rho$形状的数环，即不论从什么地方开始，这个序列总会进入循环，因此这也是一个伪随机的序列。</p>
<p>而为了判断环的存在，可以使用简单的Floyd判环算法，设经过时间$i$后，$t=i，r=2i$，表示后者速度是前者的一倍。因此当后者遇上前者时，有$x<em>t=x_r$，也就是$x_i=x</em>{2i}=x_{i+kC}$，其中k是整数，C是环的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启发式方法pollard_rho</span></span><br><span class="line"><span class="comment">//返回一个因数，不一定是质因数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//序列函数x=(x^2+c)%n</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x*x+c)%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回N的一个因数，不一定是质因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pollard_rho</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成常数C</span></span><br><span class="line">    <span class="type">int</span> c=<span class="built_in">rand</span>()%(N<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//floyd优化环判断，t是龟，r是兔子</span></span><br><span class="line">    <span class="comment">//设t=x1=f(0)，r=x2=f(x1)</span></span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">f</span>(<span class="number">0</span>,c,N),r=<span class="built_in">f</span>(<span class="built_in">f</span>(<span class="number">0</span>,c,N),c,N);</span><br><span class="line">    <span class="keyword">while</span>(t!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d=<span class="built_in">gcd</span>(<span class="built_in">abs</span>(t-r),N);</span><br><span class="line">        <span class="keyword">if</span>(d&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        <span class="comment">//更新时保证t=f(t)=x_i，那么r=f(r)=x_2i</span></span><br><span class="line">        t=<span class="built_in">f</span>(t,c,N),r=<span class="built_in">f</span>(<span class="built_in">f</span>(r,c,N),c,N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N;<span class="comment">//没有找到,重新调整参数c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><p>定义：$a \equiv b \pmod m$</p>
<p>性质：</p>
<ul>
<li>自反性：$a \equiv a \pmod p$</li>
<li>对称性：$a \equiv b \pmod m \Rightarrow b \equiv a \pmod m$</li>
<li>传递性：$a \equiv b \pmod p，b \equiv c \pmod p \Rightarrow a \equiv c \pmod m$</li>
</ul>
<p>运算，如果a，b同余，c，d同余，那么：</p>
<ul>
<li>$a\pm c \equiv b \pm d$</li>
<li>$ac \equiv bd$</li>
<li>$a^k \equiv b^k$</li>
<li>$(a/b)\%m = ((a\%m)*(b^{-1}\%m))\%m$</li>
</ul>
<h3 id="一元线性同余方程和乘法逆元"><a href="#一元线性同余方程和乘法逆元" class="headerlink" title="一元线性同余方程和乘法逆元"></a>一元线性同余方程和乘法逆元</h3><p>一元线性同余方程基本形式：$ax\equiv b \pmod m$，等价于前面扩展欧几里得算法提到的二元线性丢番图方程$ax+my=b$，因此有以下定理：</p>
<ul>
<li>定理：方程有解的充要条件是$gcd(a,m)|b$，与前面相同；此时有$gcd(a,m)$个不同的整数$x$使得$ax \equiv b \pmod m$；</li>
<li>推论：$gcd(a,m)=1$时，只有一个满足要求的解$x$，称为$a$模$m$的乘法逆元，记作$a^{-1}$。</li>
</ul>
<p>求乘法逆元的方法前面已经介绍了，通过扩展欧几里得算法，如果有一个特解是$x_0$，那么通解是$x=x_0+km$，其中k是整数，可以求出最小正整数解(逆的代表元)为：$((x_0\%m)+m)\%m$。</p>
<p>另外还可以通过费马小定理求逆，如果正好两个数$a$和$n$互质，那么有$a^{n-1} \equiv 1 \pmod n$，因此$a$的乘法逆元就是$a^{n-2}\%n$，而且已经是唯一解，因为此时$gcd(a,n)=1$。利用快速幂运算就是$fastPow(a,m-2,m)$。</p>
<p><img src="/2023/03/17/classicDA/10.png" alt></p>
<h3 id="同余方程组"><a href="#同余方程组" class="headerlink" title="同余方程组"></a>同余方程组</h3><p>中国剩余定理，如果同余方程组的模两两互素，设$m_1,m_2,…,m_r,r \geq 1$为$r$个方程的模，令$M=m_1<em>m_2</em>…<em>m_r=m_1</em>M_1=…=m_k<em>M_k$，那么方程组的解是$x=a_1</em>M_1<em>M_1^{-1}+…+a_r</em>M_r<em>M_r^{-1} \pmod M$，其中$M_i^{-1}$是$M_i$对方程的模$m_i$的逆元，即$M_i</em>M_i^{-1} \equiv 1 \pmod {m_i}$。</p>
<p>如果同余方程组的模并不是两两互素，那么就要使用扩展中国剩余定理。</p>
<p>扩展中国剩余定理每次将两个方程合并成一个，假设有方程$x \equiv r_1 \pmod {m_1},x \equiv r_2 \pmod {m_2}$，那么将这两个方程等价于$x = r_1 + k_1 <em> m_1,x=r_2+k_2</em>m_2$，合并两个方程并移项可以得到：</p>
<ul>
<li>$k_1m_1-k_2m_2=r_2-r_1$</li>
</ul>
<p>根据贝祖定理，这个方程组有解的充要条件是$r_2-r_1$能被$gcd(m1,m2)$整除，所以这时需要进行判断，如果不能整除，方程组无解；如果能整除，那么自然就是扩展欧几里得算法了，能求出方程$k_1m_1-k_2m_2=gcd(m_1,m_2)$的参数。</p>
<p>因此，进一步令$p_1=gcd(m_1,m_2)/(r_2-r_1)<em>k_1,p2=-gcd(m_1,m_2)/(r_2-r_1)</em>k_2$，那么这个式子就变成：</p>
<ul>
<li>$p_1<em>m_1+p_2</em>m_2=gcd(m_1,m_2)$</li>
</ul>
<p>然后用扩展欧几里得算法得到$p_1,p_2$，进而求出$k_1=p_1<em>gcd(m_1,m_2)/(r_2-r_1)，k_2=-p_2</em>gcd(m_1,m_2)/(r_2-r_1)$，这样以来又可以求出满足这两个方程的特解$x$，从而得到通解$x^<em>=x+k</em>lcm(m_1,m_2)$，等价于同余方程$x^* \equiv x \pmod {lcm(m_1,m_2)}$，就把两个方程合并成一个了。</p>
<p>因此，扩展中国剩余定理的流程就是：</p>
<ul>
<li>读入一个方程；</li>
<li>判断能否与之前处理好的方程合并，如果不能，返回无解；否则执行下一步；</li>
<li>返回第一步，直到全部方程都读入了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,mod[<span class="number">100009</span>],yu[<span class="number">100009</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速幂运算a*b%m</span></span><br><span class="line"><span class="function">ll <span class="title">qMul</span><span class="params">(ll a,ll b,ll m)</span></span>&#123;</span><br><span class="line">    ll an = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) an =(an+a) % m;</span><br><span class="line">        a = (a+a)%m;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> an%m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展欧几里得算法，返回gcd(a,b),并计算出ax+by = gcd(a,b)中的x和y</span></span><br><span class="line"><span class="function">ll <span class="title">exGcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( b == <span class="number">0</span> ) &#123; x = <span class="number">1</span>;y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    ll gcd = <span class="built_in">exGcd</span>(b,a%b,y,x);  <span class="comment">//注意x和y的顺序</span></span><br><span class="line">    y = y - a/b*x;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exCrt</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin&gt;&gt;mod[i]&gt;&gt;yu[i];</span><br><span class="line">    <span class="comment">//ans表示前i-1个方程式的特解（余数），M为前i-1个方程式的模数的最小公倍数(i从2开始)</span></span><br><span class="line">    <span class="comment">//k1和k2是合并两个同余方程时的待求参数</span></span><br><span class="line">    ll ans = yu[<span class="number">1</span>],M = mod[<span class="number">1</span>] ,k1,k2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="comment">//记录mi和r2-r1</span></span><br><span class="line">        ll mi = mod[i],res = ((yu[i] - ans)%mi + mi)%mi;</span><br><span class="line">        <span class="comment">//求出gcd(mi,M)</span></span><br><span class="line">        ll gcd = <span class="built_in">exGcd</span>(M,mi,k1,k2);</span><br><span class="line">        <span class="comment">//如果等式右边不能整除gcd，方程组无解</span></span><br><span class="line">        <span class="keyword">if</span>(res % gcd != <span class="number">0</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求出k1还要乘上倍数，注意是快速乘取模mi (对谁取模要分清)</span></span><br><span class="line">        k1 = <span class="built_in">qMul</span>(k1,res/gcd,mi);</span><br><span class="line">        <span class="comment">//得到前i个方程的特解（余数）</span></span><br><span class="line">        ans += k1 * M; </span><br><span class="line">        <span class="comment">//M等于lcm(M,mi)，注意乘法要在除法后面做，否则会爆long long</span></span><br><span class="line">        M = mi /gcd * M; </span><br><span class="line">        <span class="comment">//合并后的ans特解取最小正整数</span></span><br><span class="line">        ans = (ans%M+M)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>games101系列(1) 变换与投影</title>
    <url>/2022/08/24/games1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>games101是由闫令琪老师讲解的计算机图形学入门课程，主要涉及光栅化、图形学几何、光线追踪和路径追踪，以及动画模拟四部分。本人在学习完成后再完成作业，结合自己理解，不完全与games101重合，因此博客系列将以课程发布的七个作业为例作为课程的学习总结笔记，会给出作业中需要修改部分的代码，以及基本原理分析。<br>完整项目在课程主页上，需要修改的函数在博客中已经给出，仅供参考交流，更多内容请访问<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">课程主页</a>。<br><span id="more"></span><br>第一次作业主题是变换。在图形学中，要模拟真实感图形自然也要模拟真实世界中观察物体的方式，相当于摄像机记录场景的过程。因此整个作业会涉及到光栅化方法的实时渲染管线，利用一系列变换，将定义的物体从三维空间转换到二维图形，并且使用光栅化的方法将其表示在屏幕上。</p>
<p>先总结光栅化方法渲染管线中的变换，然后再分析作业；由于作业一并不需要设计其他内容，所以将在后面的博客中再总结完整的渲染管线。</p>
<h1 id="光栅化方法渲染管线—变换"><a href="#光栅化方法渲染管线—变换" class="headerlink" title="光栅化方法渲染管线—变换"></a>光栅化方法渲染管线—变换</h1><h2 id="变换的作用"><a href="#变换的作用" class="headerlink" title="变换的作用"></a>变换的作用</h2><p>之前说渲染管线就是模拟摄像机成像的过程，但是这样理解当然是片面的，严格来说渲染管线从顶点开始处理，经过一系列变换生成三角形面，然后对三角形面进行光栅化，接着还要处理光栅化后的片元，进行着色，最后才映射到屏幕上。<br><img src="/2022/08/24/games1/1.jpg" alt="场景"><br>因此，模拟摄像机成像的过程仅仅是对顶点的一系列变换，其他内容将在对各个过程有所了解以后再总结。<br><img src="/2022/08/24/games1/2.jpg" alt="场景"></p>
<p>图形学中MVP变换就是基本的变换，M是对物体的Model变换，V是对摄像机的View变换，P是将三维映射到二维的Projection变换。不理解没关系，下面会详细说明他们的定义。</p>
<p>要介绍这几种变换，首先要介绍以下几个坐标系概念。</p>
<ul>
<li><em>MODEL</em>首先是物体坐标系，或者说模型坐标系，这个坐标系用来给物体进行建模，定义复杂物体的各种几何属性；</li>
<li><em>WORLD</em>世界坐标系，建模完成的物体在世界坐标系中进行变换，从而移动到不同的位置和朝向；</li>
<li><em>VIEW</em>视图坐标系，将世界坐标系中的物体再进行视图变换，使其符合摄像机的观察(“符合”同样会在后面解释)；</li>
<li><em>PERSPECTIVE</em>裁剪坐标系，或者说透视坐标系，透视投影变换再次对物体进行处理，这时让整个可见空间的坐标范围缩放到标准的单位大小；</li>
<li><em>SCREEN</em>屏幕坐标系，透视投影已经让物体从三维变换到二维上了，所以可以根据屏幕大小再次缩放可见图形，在根据Z轴提供的深度关系，就完成了整个变换。</li>
</ul>
<p>实际在图形学的过程中，并不会很严格地对这几个坐标系进行区分，而是以具体的变换操作为主，接下来就借助坐标系转换的过程，对MVP变换进行总结。</p>
<p>模型变换，就是将物体在世界坐标系中移动到合适位置和朝向的过程；视图变换则是将摄像机在世界坐标系中移动到合适位置和朝向的过程。在实际过程中，由于模型变换和视图变换具有可逆性，也就是对物体的变换可以视为对摄像机的逆变换，所以通常将这两部分变换放在一起进行，统称模型视图变换(OpenGL就是这么做的)。而且，总是将摄像机看作固定的，位置在坐标原点，朝向Z轴负方向，以Y轴正方向为向上方向(注意这里是右手坐标系)。要移动摄像机就相当于对物体做逆变换，这样就简化了模型视图变换，采用统一的变换方式就能让物体”符合”摄像机的观察方向，将世界坐标系和视图坐标系合二为一。另外，对模型几何的详细处理一般不在这里进行，只要知道模型的形状即可进行变换。</p>
<p>到这里我们已经定义了物体的位置、朝向以及摄像机的位置、朝向，但是像前面裁剪坐标系说的一样，要将一个三维场景渲染到二维平面上，还需要进行投影变换，并且进行规格化地缩放，才能方便将场景映射到屏幕坐标系上。而投影也有两种方法，称为正交投影和透视投影。</p>
<p>正交投影，不会改变物体的任何几何属性，平行的直线一定不会相交，类似我们平时说的三视图一样；而透视投影则更符合人的直觉，例如火车铁轨相交。后面总结原理之后，再详细描述一下投影的数学过程。</p>
<p>现在，我们可以总结一下为什么需要使用变换了，MVP变换对物体进行了移动、旋转、缩放，还有投影，实际上是很多变换的集合，实现MVP变换需要借助变换这个工具。</p>
<h2 id="变换的数学过程"><a href="#变换的数学过程" class="headerlink" title="变换的数学过程"></a>变换的数学过程</h2><p>前面只介绍了变换的基本过程是什么，现在从数学的角度实际讲一讲什么是变换。首先数学上的对变换有严格的定义，先看我们需要的是什么变换，然后再进行数学计算。</p>
<h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>MV变换中，需要的是对物体移动到不同的位置和朝向，这通过平移和旋转就能完成；P变换中，还需要进行缩放。假设物体坐标是列优先存储的(x,y,z,1)，我们可以用矩阵的方式来表示这种变换：<br><img src="/2022/08/24/games1/3.jpg" alt="场景"><br><img src="/2022/08/24/games1/4.jpg" alt="场景"><br><img src="/2022/08/24/games1/5.jpg" alt="场景"><br>由于是列优先存储，将上面的矩阵对坐标进行左乘，就得到了变换后的坐标。详细推导不再赘述。</p>
<p>像旋转，缩放这种变换，统称为线性变换，投影也是线性变换，因为这些变换都保证变换以后向量保持加法和数乘运算，直观来说就是不会让图形发生中心的移动。也就是说，平移变换就不是严格的线性变换，不满足数学上的性质。但是在我们模型视图变换中也需要平移，把这种经过线性变换和平移变换的变换叫做仿射变换。</p>
<p>另外，由于是左乘的关系，最先生效的是最靠近坐标的变换矩阵，最简单可以试试先平移后旋转和先旋转后平移，效果是不一样的，要格外注意。也是因为这个原因，一般我们做变换都是按照缩放、旋转、平移的顺序，保证得到理想的结果，不必严格区分，清楚原理就行。</p>
<h3 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h3><p>你可能还注意到，上面的三维空间坐标，却总是用四维表示。这就是齐次坐标，用最后一维去表示一个向量的方向性，(x,y,z,0)表示一个向量，其他表示一个具体的点。当然齐次坐标并不仅仅有这一个用途，前面提到平移变换比较特殊，其实最根本的原因是用同一维度的矩阵没办法表示平移变换，必须要加上一个向量。因此我们加上一维，用多出来的维度表示平移变换，在上面的变换矩阵中也可以观察到，只有平移变换使用了第四维。</p>
<p>除此外，齐次坐标表示的平移变换还具有特殊的性质，点和点相加仍然是点，向量和向量相加仍然是向量，同时向量和点相加会得到一个点(相当于点朝向量方向平移)，点相减得到一个向量，这都是符合直觉的事情，原理就是坐标的第四维w不会变化。</p>
<h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>详解原理之前，先介绍视锥体的概念。在之前说的裁剪坐标系中，实际上我们是在世界坐标系中划定了一个用来投影的空间，也就是视锥体。视锥体有前后、上下、左右六个坐标。</p>
<p>另外，投影虽然是将三维转换为二维，但是这里仅仅是处理几何，输出一个视锥，等后面还要光栅化以后才能决定像素的颜色是什么。</p>
<h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>正交投影的平截体就是一个长方体，它可能在任意一个地方，也可能是任意大小。所以正交投影很简单，将这个长方体移动到原点，然后缩放到单位大小。<br><img src="/2022/08/24/games1/6.jpg" alt="场景"><br>right,left,top,bottom,near,far就是长方体的各种坐标。先平移，后缩放。上面的式子结果如下：</p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>对于透视投影，做法是先将透视投影的视锥压成一个长方体，再按照正交投影的方法进行处理。之所以要说要”压”成长方体，是因为透视的视锥是一个四棱台。<br><img src="/2022/08/24/games1/7.jpg" alt="场景"><br>当然这样压缩以后得到的内容会变形，但是后面的光栅化过程会解决这个问题。</p>
<p>投影的原理实际上是从一个点延伸出一个四棱锥，然后通过near和far定义远近，形成视锥。<br><img src="/2022/08/24/games1/8.jpg" alt="场景"><br>现在要挤压这个视锥，那么假设近平面的z为n，远平面的z为z，现在要将远平面的(x,y,z)挤压到和y’同样的高度，这样引申出一个对应关系，利用相似三角关系可以写出上面的对应关系。这里补充一点，因为我们这里讨论的Z坐标都是负的，所以有的地方会把这个相似关系右边加一个负号，保证值和原来一样，比较严谨，否则推出来就是齐次坐标的最后一个值正负不同，这里就先这样作为长度来推导。</p>
<p>同理，x也有一样的对应关系(从Y轴负方向观察)，因此建立了x和y的对应关系，但是z如何变化我们仍然不知道。<br><img src="/2022/08/24/games1/9.jpg" alt="场景"><br>因此我们现在要找的问题就变成了上面的形式，什么样的矩阵可以将齐次坐标变成对应关系的结果。利用其次坐标，可以同时乘以z简化分母z。此时可以直接推出矩阵形式应该和下面一样：<br><img src="/2022/08/24/games1/10.jpg" alt="场景"><br>求解第三行是关键。不过还有另外两个条件可以利用，在最远平面上，他的z值是不会变化的，因为我们没有从z轴两边进行变换，同理在近平面上也会这样：<br><img src="/2022/08/24/games1/11.jpg" alt="场景"><br>而且，第三行的前两项也一定为0.因为结果中没有出现x，y，综上可以推出两个额外的条件：<br><img src="/2022/08/24/games1/12.jpg" alt="场景"><br><img src="/2022/08/24/games1/13.jpg" alt="场景"><br>这样就解出AB：<br><img src="/2022/08/24/games1/14.jpg" alt="场景"><br>这样就得到了完整的”挤压矩阵”，所以先对视锥坐标左乘这个矩阵，然后再左乘正交投影的矩阵，就得到了透视投影后的标准空间，进行下一步光栅化。更详细的讲解在这篇<a href="https://zhuanlan.zhihu.com/p/554093703">知乎</a></p>
<p><img src="/2022/08/24/games1/6.png" alt></p>
<p><img src="/2022/08/24/games1/7.png" alt></p>
<p>推导完成后，我们实际上要的反而是通过坐标计算，对于正交投影，这一步应该给出长方体的六个坐标，然后通过上面的正交投影矩阵计算；</p>
<p>对于透视投影则不同，还定义了一些量来进行进一步计算。<br><img src="/2022/08/24/games1/15.jpg" alt="场景"><br>fov角(field of view)，定义了Y轴方向上的视野宽度，从透视点延伸的两条视锥边之夹角。另外是aspect比例，定义为某点对应的高度与宽度之比，对每个点应当是相同的，因为线性延伸并不会改变这个比例。</p>
<p>这样就比较清晰了，计算的时候给出fov角，Znear和Zfar，这时就已经确定了”挤压”矩阵；接着利用tan(fov/2)计算t，进一步根据aspect比例计算r，就完成了。至于l和b，如果移动透视点到原点，那么他们应该是对应坐标r和t的负数。如果没有移动到原点，需要根据透视点和原点的距离进一步计算。</p>
<h1 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h1><p>理解上述变换原理后，作业1还是比较简单的。代码构建了一个基于CPU的光栅化渲染器，其中三角形的光栅化已经写好，要求填写的只有两个矩阵：绕Z轴旋转矩阵和透视投影矩阵。main函数中，按下ESC退出程序，按下a增加旋转角度，按下d减小旋转角度，渲染对象是一个三角形，坐标也已经确定。</p>
<h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p>前面已经有了Z轴旋转的矩阵形式，函数输入是一个角度，要转化成弧度才能用数学库计算。下面是矩阵代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eigen::Matrix4f get_model_matrix(float rotation_angle)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Matrix4f model;</span><br><span class="line">    rotation_angle = rotation_angle * PI / 180;</span><br><span class="line">    model &lt;&lt; cosf(rotation_angle), -sinf(rotation_angle), 0, 0,</span><br><span class="line">        sinf(rotation_angle), cosf(rotation_angle), 0, 0,</span><br><span class="line">        0, 0, 1, 0,</span><br><span class="line">        0, 0, 0, 1;</span><br><span class="line">    return model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="透视投影矩阵"><a href="#透视投影矩阵" class="headerlink" title="透视投影矩阵"></a>透视投影矩阵</h2><p>透视投影矩阵是”挤压”矩阵和正交投影矩阵的乘积，正交投影矩阵又是平移和旋转矩阵的乘积。所以任务就是计算三个矩阵，计算方法和上面是一样的，将结果返回即可。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,</span><br><span class="line">    float zNear, float zFar)</span><br><span class="line">&#123;</span><br><span class="line">    // Students will implement this function</span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();</span><br><span class="line">    Eigen::Matrix4f M_p_o, M_scale, M_translate;</span><br><span class="line">    //计算视锥</span><br><span class="line">    float top, bottom, left, right, near, far, fovY;</span><br><span class="line">    fovY = eye_fov / 180 * PI;</span><br><span class="line"></span><br><span class="line">    near = -zNear;</span><br><span class="line">    far = zFar;</span><br><span class="line"></span><br><span class="line">    top = tan(fovY / 2) * zNear;</span><br><span class="line">    bottom = -top;</span><br><span class="line"></span><br><span class="line">    right = top * aspect_ratio;</span><br><span class="line">    left = -right;</span><br><span class="line"></span><br><span class="line">    //计算矩阵</span><br><span class="line">    M_scale &lt;&lt; 2 / (right - left), 0, 0, 0,</span><br><span class="line">        0, 2 / (top - bottom), 0, 0,</span><br><span class="line">        0, 0, 2 / (near - far), 0,</span><br><span class="line">        0, 0, 0, 1;</span><br><span class="line"></span><br><span class="line">    M_translate &lt;&lt; </span><br><span class="line">        1, 0, 0, -(right + left) / 2,//==0</span><br><span class="line">        0, 1, 0, -(top + bottom) / 2,//==0</span><br><span class="line">        0, 0, 1, -(near + far) / 2,//!=0</span><br><span class="line">        0, 0, 0, 1;</span><br><span class="line"></span><br><span class="line">    M_p_o &lt;&lt; near, 0, 0, 0,</span><br><span class="line">        0, near, 0, 0,</span><br><span class="line">        0, 0, near + far, -near * far,</span><br><span class="line">        0, 0, 1, 0;</span><br><span class="line">    </span><br><span class="line">    projection = M_scale * M_translate * M_p_o * projection;</span><br><span class="line">    return projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="绕任意轴旋转的矩阵"><a href="#绕任意轴旋转的矩阵" class="headerlink" title="绕任意轴旋转的矩阵"></a>绕任意轴旋转的矩阵</h2><p>罗德里格公式就是用来求解绕任意轴旋转的，现在假设要将向量v绕过原点的轴K旋转θ角度。<br><img src="/2022/08/24/games1/1.png" alt="场景"><br>由轴K和待旋转的向量v，可以确定一个平面，因此有过原点并垂直该平面的方向向量，也就是K方向向量和v的叉积，再通过右手坐标系得到三个相互垂直的向量如图，从而建立一个”歪斜”的坐标系。</p>
<p>建立坐标系的意义在于能够将待旋转向量分解成两个方位角，而且已经知道旋转后的向量的一个方位角没有变化，也就是K轴上的方位角不用求解了，只需要解得另一个方位角，矢量相加以后就得到了结果。v的分解如图所示，Vl就是会发生改变的那个方向角。</p>
<p><img src="/2022/08/24/games1/2.png" alt="场景"></p>
<p>而Vl旋转以后，模不会改变，同样分解到方位角，通过旋转的角度推出Vl的变换。</p>
<p><img src="/2022/08/24/games1/3.png" alt="场景"></p>
<p>现在将两个方位角相加，得到最后的结果。</p>
<p><img src="/2022/08/24/games1/4.png" alt="场景"></p>
<p>到这里已经能求出结果了，不过我们因为要得到旋转矩阵形式，所以要进一步化简。</p>
<p><img src="/2022/08/24/games1/5.png" alt="场景"></p>
<p>到这里，M就是要求的旋转矩阵了，可以看到Rk代表的就是K轴上的单位向量，θ则是旋转角度。代码上要实现的也就很简单了，不过要注意上图中虽然都是点乘，实际上是为了表示矩阵运算，Rk要写成叉乘矩阵(数学上实际叫做对偶矩阵)的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eigen::Matrix3f get_rotation(Vector3f K, float theta)</span><br><span class="line">&#123;</span><br><span class="line">    theta = theta * PI / 180;</span><br><span class="line">    Eigen::Matrix3f I = Eigen::Matrix3f::Identity();</span><br><span class="line">    K = K.normalized();</span><br><span class="line">    Eigen::Matrix3f K_dual;</span><br><span class="line">    K_dual &lt;&lt; 0, -K.z(), K.y(),</span><br><span class="line">        K.z(), 0, -K.x(),</span><br><span class="line">        -K.y(), K.x(), 0;</span><br><span class="line">    </span><br><span class="line">    return (I + (1 - cos(theta)) * K_dual * K_dual + K_dual * sin(theta))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回以后的矩阵是三维的，要实际使用还要用齐次坐标扩展，第四维就是(0, 0, 0, 1)。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>games101</category>
      </categories>
      <tags>
        <tag>gmaes101</tag>
        <tag>Computer Graphics</tag>
        <tag>Geometric Transformation</tag>
      </tags>
  </entry>
  <entry>
    <title>食店记录</title>
    <url>/2022/07/06/food-in-ChengDu/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>更新中</p>
<hr>
<p>来成都上学到现在还是去了不少食店，简单记录下这些店的位置和价格，顺带放一些游玩的照片。欢迎推荐~<br><span id="more"></span></p>
<h1 id="火锅串串类"><a href="#火锅串串类" class="headerlink" title="火锅串串类"></a>火锅串串类</h1><h2 id="小郡肝串串香"><a href="#小郡肝串串香" class="headerlink" title="小郡肝串串香"></a>小郡肝串串香</h2><p><img src="/2022/07/06/food-in-ChengDu/longhuchuan.jpg" alt="场景"><br>时间长忘记叫啥了😀，中规中矩的一家店，消费比较高，人均100左右，小酥肉好吃，又嫩又香。虽说买的是串串，但我吃串串总感觉跟火锅差不多，经常吃到一半然后把签子全部拿了当火锅吃。</p>
<p>味道印象中还可以，我感觉要把这种做难吃也挺不容易。</p>
<h1 id="自助"><a href="#自助" class="headerlink" title="自助"></a>自助</h1><h2 id="泰澜汀·海鲜自助烤肉火锅"><a href="#泰澜汀·海鲜自助烤肉火锅" class="headerlink" title="泰澜汀·海鲜自助烤肉火锅"></a>泰澜汀·海鲜自助烤肉火锅</h2><p>我去的这家是郫都龙湖新开的，美团63一位，据说价格恢复是一百多。60块钱的海鲜其实挺划算，他那里货都挺新鲜，不过种类不多，海鲜有螃蟹，蛤蜊，生蚝，扇贝，还有海星跟两种贝类，皮皮虾也有。肉类也正常，不过我觉得挺一般的。<br><img src="/2022/07/06/food-in-ChengDu/tai1.jpg" alt="场景"><br>生蚝挺小，螃蟹够大，总之那几种海鲜都挺新鲜，皮皮虾也小，基本没肉，要说60块钱倒也划算，总之海鲜是推荐的，如果没恢复原价。<br><img src="/2022/07/06/food-in-ChengDu/tai.jpg" alt="场景"><br>肉类就不说了，五花虽然不是合成，但是切的比较大，不太好吃；而且他这里很多腌过的肉都挺咸的，我当时吃了没多久就不想吃了。</p>
<p>酒水提供的也算一般般，有可乐雪碧什么的，其他就是常见的冒牌货了；水果也不多，大概三四种，不过吃还是挺好吃的，准备了沙拉可以自己拌。甜点也一般，就是抹茶蛋糕什么的，还提供了甜筒冰淇淋，不过一吃就知道很便宜那种，没什么味道。</p>
<p>总之60的海鲜自助算可以了，我现在吃下来还是觉得80块钱的吉布鲁最划算，酒水，甜点，熟菜种类都够，海鲜种类比这个多但是显然没这个好（吉布鲁甚至有刺身，见过有三文鱼的）。</p>
<h2 id="匠和风（悠方店）"><a href="#匠和风（悠方店）" class="headerlink" title="匠和风（悠方店）"></a>匠和风（悠方店）</h2><p>这家我馋好久了，多说一些。晚间自助288/人，到店消费办会员（不要钱也不用定额充值）可以打9折，可以预约。我当时要了个靠窗的位置，不过要脱鞋。服务员态度都很好，所以也倒不会尴尬。<br><img src="/2022/07/06/food-in-ChengDu/jiang_env.jpg" alt="场景"><br>288一位值不值就看个人了，点单用平板，火锅可以选寿喜锅，其他就是刺身和熟菜，酒水，甜点。上来我先要了一份刺身拼盘，点单按只算，总的来说不会拖时间，上菜也齐，现在这些自助，这一点来说就挺不错了。<br><img src="/2022/07/06/food-in-ChengDu/jiang_ci.jpg" alt="场景"><br>我要的鳌虾，甜虾，红酒鹅肝然后厚切三文鱼（我去的时候还有种刺身没有了，什么鱼腹来着），都没有腥味，很不错。不过我觉得鹅肝最好吃，有人说红酒酱放多了盖住了鹅肝香味，我倒觉得无所谓哈哈，鹅肝的口感真的一绝。<br><img src="/2022/07/06/food-in-ChengDu/jiang_niu.jpg" alt="场景"><br>后面是要的火锅，素食就不说了，这个和牛特别好吃，我确实到这次才知道和牛这种差距，主要是口感上很不一样，属于吃进去就觉得好吃，另外还给了无菌蛋，寿喜锅出来很好吃，非常推荐。<br><img src="/2022/07/06/food-in-ChengDu/jiang_ice.jpg" alt="场景"><br>这个忘记叫什么了，外面海苔饼干我觉得一般，里面是冰淇淋混着鱼籽，虾肉什么的，吃起来感觉冰淇淋的甜味太大了，盖住了其他味道。另外就是这个太容易吃饱了。<br><img src="/2022/07/06/food-in-ChengDu/jiang_jun.jpg" alt="场景"><br>这个就是正常的军舰寿司，上面是刺身，鱼籽，水果，出品算不错。<br><img src="/2022/07/06/food-in-ChengDu/jiang_pu.jpg" alt="场景"><br>蒲烧鳗鱼，非常好吃，鱼皮香软，鱼肉有蒲叶的清香，酱汁又很好地进行调味，是我比较喜欢的菜。<br><img src="/2022/07/06/food-in-ChengDu/jiang_zhang.jpg" alt="场景"><br>最后是我最不能接受的菜，这个芥末章鱼。我估计一般人都接受不了，章鱼是刺身，虽然切小了但是真的好硬啊，嚼不动，而且芥末有点多，吃起来那叫一个难受。</p>
<p>酒水什么的就不说了，对得起这个价格，清酒我看人家说算比较好的了，这方面我就不是很清楚。如果你要更好的酒可以加钱买。甜点也很不错，中看也中吃，有做奶茶，水果茶什么的。</p>
<p>最后这家还是推荐的，就是价格略贵，同一家公司开的还有花潮日料自助，这两家应该在成都挺出名的了，花潮主打高端，还有海胆什么的，这家是没有的。如果没有吃过可以试试，两个小时用餐时间，最后一次加餐会有服务员来问你，时间还是够了，毕竟上菜不会拖。那天有些菜品没有了挺可惜，期待下次再去。</p>
<h2 id="吉布鲁海鲜自助"><a href="#吉布鲁海鲜自助" class="headerlink" title="吉布鲁海鲜自助"></a>吉布鲁海鲜自助</h2><p>这家就很多店了，性价比很不错，83/人，在自助里不算最便宜那档，不过他这个规模倒也说得过去。<br><img src="/2022/07/06/food-in-ChengDu/jibulu.jpg" alt="场景"><br>特别好吃的其实说不上，对比上面一家就知道了，他这里我觉得还是胜在菜品多，想吃的基本都有，并且酒水都有好好提供，甜点也都还可以，如果不知道想吃什么的话去这里还是不错的。</p>
<h2 id="飞火令·西昌火盆自助烤肉"><a href="#飞火令·西昌火盆自助烤肉" class="headerlink" title="飞火令·西昌火盆自助烤肉"></a>飞火令·西昌火盆自助烤肉</h2><p>这家也还行，会员68/人，特点是肉类不错，但是菜品少，酒水一般。<br><img src="/2022/07/06/food-in-ChengDu/fei.jpg" alt="场景"><br>我有段时间吃烤肉太多了，所以印象就不是很好，店里的服务员有空会帮你烤，算是好吃吧，不过谈不上多享受，店比较小（郫都），有生蚝和扇贝。</p>
<h1 id="家常菜-炒菜-单点"><a href="#家常菜-炒菜-单点" class="headerlink" title="家常菜/炒菜/单点"></a>家常菜/炒菜/单点</h1><h2 id="御柴源北京烤鸭"><a href="#御柴源北京烤鸭" class="headerlink" title="御柴源北京烤鸭"></a>御柴源北京烤鸭</h2><p><img src="/2022/07/06/food-in-ChengDu/beijin.jpg" alt="场景"><br>这家我印象也很不错，环境很好，当时要了一个套餐加一个番茄鸡蛋汤，上面都是套餐里的，烤鸭挺好吃，我这个估计只切了半只，两个人吃还是勉勉强强。人均60，请客吃饭的话这里很好，当时有很多桌在谈事情，不过都有包厢。</p>
<h1 id="干锅"><a href="#干锅" class="headerlink" title="干锅"></a>干锅</h1><h2 id="盐都干锅王"><a href="#盐都干锅王" class="headerlink" title="盐都干锅王"></a>盐都干锅王</h2><p><img src="/2022/07/06/food-in-ChengDu/nanmenganguo.jpg" alt="场景"><br>电子科大清水河南门对面的小巷子走到转角，这家专买干锅，生意很不错，基本每次去都快满了，他家有烤鸭干锅（图里这个就是），还算好吃，价格大概在40/人，因为在学校附近所以平时对付一下还是挺不错的，其他没啥好说的。</p>
<h1 id="冒菜"><a href="#冒菜" class="headerlink" title="冒菜"></a>冒菜</h1><h1 id="套饭"><a href="#套饭" class="headerlink" title="套饭"></a>套饭</h1><h2 id="吉野家"><a href="#吉野家" class="headerlink" title="吉野家"></a>吉野家</h2><p>这家不用多说了吧，价格偏贵一点，大概30/人，随便对付一下还可以，算比较好吃的。<br><img src="/2022/07/06/food-in-ChengDu/ji.jpg" alt="场景"><br>标配就是肉+蔬菜+咸菜+饮料（可以自选）</p>
<h1 id="烧烤"><a href="#烧烤" class="headerlink" title="烧烤"></a>烧烤</h1><p>成都这边我还没吃过好吃的，晚上要回学校一般只能在学校附近找，又找不到好吃的碳烤，电烤跟炸的就不说了，根本不好吃。还是云南的烧烤得劲。</p>
<h1 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h1><h2 id="宽窄巷子"><a href="#宽窄巷子" class="headerlink" title="宽窄巷子"></a>宽窄巷子</h2><p>第一天来成都逛的地方，属于是外地人必去了。小吃属于都还可以但是没有什么特色，并且价格很贵，人也挺多的。<br><img src="/2022/07/06/food-in-ChengDu/scene.jpg" alt="场景"><br>有些东西没拍照，我就留了三张照片。<br><img src="/2022/07/06/food-in-ChengDu/jiao.jpg" alt="场景"><br>当时挺饿的，进去想找点面之类的吃，然后就找到这个买饺子的店，这一小份钟水饺好像二三十，味道也算正常，没啥好说的。<br><img src="/2022/07/06/food-in-ChengDu/bao.jpg" alt="场景"><br>这玩意忘了叫什么了，什么包来着，还算便宜，五块钱三个，就是太硬了，里面的馅是豆沙，挺好吃的，外面的面皮我都有点咬不动说实话。<br><img src="/2022/07/06/food-in-ChengDu/yezi.jpg" alt="场景"><br>然后一杯普普通通的椰子汁，兑水不少，糖也不少，不如说糖水算了，15一杯。<br>总之宽窄巷子逛逛挺好的，虽然都是按旅游区装修，可毕竟没去过。以后估计也不大可能去哈哈。</p>
<h2 id="建设路"><a href="#建设路" class="headerlink" title="建设路"></a>建设路</h2><p>这也是挺多人推荐的，我没全部吃过来，路口有一家买烤五花的特别多人，基本每次去都能看到在排长队。<br><img src="/2022/07/06/food-in-ChengDu/jianshe.jpg" alt="场景"><br>暂时没吃到很难吃的，这些店都不错，然后单份小吃价格基本都在10-20块钱，分量都还可以，我一般吃三份就差不多了，所以说比较适合那种到外面玩中午想将就一下的。<br><img src="/2022/07/06/food-in-ChengDu/bingfen.jpg" alt="场景"><br>这份八块好像，料很足，尤其是糍粑很好吃，我还挺喜欢的，也是在靠近拐角的地方，叫阿姨冰粉还是什么来着。</p>
<p>照片没留很多，下次去有机会再拍。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>探店</tag>
      </tags>
  </entry>
  <entry>
    <title>竞赛常用数据结构和算法(续)</title>
    <url>/2023/03/28/classicDA1/</url>
    <content><![CDATA[<p>篇幅原因，这篇博客继续记录常用算法和数据结构，主要是我不知道或者容易出错的部分。</p>
<span id="more"></span>
<h1 id="string和int，char类型的转换"><a href="#string和int，char类型的转换" class="headerlink" title="string和int，char类型的转换"></a>string和int，char类型的转换</h1><p>string作为C++的一个类模板，提供了方便的转换函数，to_string通过重载的方式将所有类型的数值转换为string类型。此外，string可以采用类似数组访问的形式访问字符串中的每个字符，也就是string[i]，得到字符串在该位置上的字符，但是其类型并不是string，而是char类型。而stoi函数可以将string类型转换为int，并且只保留string中的整数部分，例如输入表示小数的字符串会被截断，带有其他字符的会自动忽略。</p>
<p>char类型作为基本的字符类型，采用八位存储，ACSII编码，因此可以看作整型int处理。也就是说，加减不同的字符常量就能对char和int进行转换，这取决于ACSII码，例如要进行数字之间的转换，那么由于’0’的ACSII编码是30，因此char转数字就是减去’0’，数字转char就是加上’0’；而对于字母来说，要得到字母在字母表中的序号，也是减去’a’或者‘A’，但是小写大写字母在ACSII编码中并不连续，因此要分情况处理。</p>
<p>最后，string可以和char数组转换，strnig.c_str()方法返回一个以’\0’结束符为结尾的char*指针地址，而string.data()方法则直接返回地址，并不添加结束符。而string则可以直接读取char的值，因此直接赋值即可。</p>
<p>另外，ACSII码的重要点也要记住，小写字母从97开始，大写字母从65开始。</p>
<p>总结一些具体的转换方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//string-&gt;int</span><br><span class="line">int myint = stoi(str);</span><br><span class="line"></span><br><span class="line">// int-&gt;string</span><br><span class="line">string str = to_string(myint);</span><br><span class="line"></span><br><span class="line">// int-&gt;char</span><br><span class="line">char mychar = myint + ‘0’;</span><br><span class="line">char mychar = myint + &#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line">// char-&gt;int</span><br><span class="line">int myint = mychar - &#x27;0&#x27;;</span><br><span class="line">int myint = mychar - &#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line">//string-&gt;char*</span><br><span class="line">char *mychar = string.c_str();</span><br><span class="line">char *mychar = string.data();</span><br><span class="line"></span><br><span class="line">//char*-&gt;string</span><br><span class="line">string mystr = mychar;</span><br></pre></td></tr></table></figure>
<h1 id="四舍五入的实现"><a href="#四舍五入的实现" class="headerlink" title="四舍五入的实现"></a>四舍五入的实现</h1><h2 id="实现输出的四舍五入"><a href="#实现输出的四舍五入" class="headerlink" title="实现输出的四舍五入"></a>实现输出的四舍五入</h2><p>第一是用printf函数，规定输出小数位数的同时会自动四舍五入，因此如果要在输出的时候得到四舍五入的结果直接用这个就行了。</p>
<p>另外还可以用<iomanip>的函数实现，不过这个比较麻烦，cout的同时需要先流入两个函数fixed和setprecision(x)的返回，然后才是正常的输出内容。</iomanip></p>
<h2 id="实现数值的四舍五入"><a href="#实现数值的四舍五入" class="headerlink" title="实现数值的四舍五入"></a>实现数值的四舍五入</h2><p>除了自己写函数实现外，对整数能用<cmath>库的函数round，这个函数会返回输入浮点数的四舍五入的整数的结果。因此如果还要进一步设置保留位数，那只能自己写了。</cmath></p>
<h1 id="STL容器的遍历"><a href="#STL容器的遍历" class="headerlink" title="STL容器的遍历"></a>STL容器的遍历</h1><p>使用迭代器和auto关键字最简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(auto iter : slt)</span><br><span class="line">&#123;</span><br><span class="line">	iter.first;</span><br><span class="line">	iter.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>string、map、vector也都可以直接用下标找对应元素。</p>
<h1 id="较大数据"><a href="#较大数据" class="headerlink" title="较大数据"></a>较大数据</h1><p>一定要注意会不会超过ll的界限，有时候可能自己调试是正确的，但是实际运算过程中数据越界了，边界条件下得出的答案并不正确，所以要注意结合问题本身考虑是不是要取模，先除后乘等操作。</p>
<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>二分查找是常用的一种算法，但是其模板并不单一，会衍生出许多的边界问题导致最终写法不一，这里简单总结一下。</p>
<p>根据查找目标可以将其分为以下几类：</p>
<ul>
<li>查找最大值中的最小值</li>
<li><p>查找最小值中的最大值</p>
</li>
<li><p>查找最佳值(也就是普通的目标二分查找)</p>
</li>
</ul>
<p>三者区别在于满足条件的区间范围不一致，设l和r是二分的两端，mid是中间，如果要找最大值中的最小值，那么判断mid是否符合，如果符合则应该查找[l,mid]（因为mid可能就是最小的，但是还要看看mid前面是不是还有更小的），反之查找[mid+1,r]（因为此时mid不符合，肯定不会取到）；同理，找最小值中的最大值则是符合时查找[mid,r]，反之查找[l,mid-1]，另外，此时计算mid有所改变：mid=(l+r+1)/2，因为不加的话会导致mid==l，从而更新无效，进入死循环，例如最后一次查找[2,3]中的3；而最佳值查找则不用保存“上一个最佳的”这种信息，而且一般最佳值查找还能根据信息比较目标和mid的大小，因此不用保留mid，而是根据比较结果在[l,mid-1]和[mid+1,r]中进行查找，当mid符合时返回或者用ans保存mid的值直到l&gt;r。</p>
<p>下面是模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最大值中的最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小值中的最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找target</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="type">int</span> mid = (r + l)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid) &gt; target) </span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(mid) &lt; target) </span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后关于终止条件，前两个没有用小于等于，最后一个用了，因为最后一个需要判断一次是否和target相等，这个逻辑在前面是不需要的，因此如果不用等号，无法在最后一次判断的时候查看是否找到target，非要不用的话就是在退出循环后比较一次，看看是不是找到了（此时l和r相等）。前面两个模板则是将等于的判断合并到左右区间两个判断分支中了，并且即使满足也不直接返回，而是进一步查找，如果l和r相等了，那么此时的这个值一定是边界值。</p>
<p>总之记住对于要找边界值的问题用前两个模板就行，最后那种模板属于常规写法，要想清楚区间如何划分，要不要接受mid继续查找，还是放弃mid，就没有问题。</p>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>说是贪心其实不是暴力，指的是将问题从局部进行考虑，用局部的选择策略来对整个问题进行解决，这个策略必须具备无后效性，也就是说策略的执行并不会影响以前的状态，只与当前的情况有关。将多个局部策略的局部最优解合并为问题的最终解，就是贪心的方法。</p>
<p>例如蓝桥杯2018省赛C++A组，付账问题，让n个人分别带着a[i]的钱去吃饭，最后花了S元，现在要让这些人近似AA，也就是一起凑钱付账，让每个人付的钱的标准差最小。</p>
<p>对这个问题考虑贪心策略，如果整体上看最优策略是每个人付总账的平均值就行，但是有些人肯定带的钱不够，所以这时就分出来两类人考虑，钱不够肯定就全部掏出来，钱够的话只需要拿出一部分。因此我们的贪心就得到了两个局部问题要解决：</p>
<ul>
<li>如果这个人钱不够怎么办？</li>
<li>如果这个人钱够怎么办？</li>
</ul>
<p>怎么判断够不够就是问题的关键了，由于要尽可能靠近平均值(让标准差最小)，显然的想法就是如果一个人钱不够平均值，那么全部拿出来付掉，此时总账减去他付掉的这部分，剩下的人再来平分这部分的钱。考虑对数组直接使用这个策略，如果前面一个人不够付钱，会导致后面的人付钱的标准”上升”，也就是说很多本来够付原始AA的钱的人现在可能不够了，那么这些人也要全部掏出来。但是我们又没法知道谁最后一个达到这个上升的标准(带的钱比新的这个标准多)，所以就先排序一次，前面的都是穷人，不断付钱，直到这个人带的钱足够付得起现在的平均标准，那么显然他后面的人比他有钱，都能付得起这个钱了，那么就让他们出这个钱就行。</p>
<p>总结下上面的例子，这种策略将最终的问题拆分成两个子问题，并给出两个子问题的局部最优解方法，通过遍历的方式模拟得出最后的答案；而且策略具有无后效性，每人不断付钱只会影响后面的人的付钱额度(后面的人付钱标准在变化)，而对前面的人的付钱额度没有影响(穷人不够就全部拿出来)。因此，这就是一个典型的贪心问题。</p>
<p>贪心问题没有固定的模板，也没有固定的解法，只是一种大体上的思想，可以在很多问题中应用。</p>
<h1 id="关于子序列和双指针"><a href="#关于子序列和双指针" class="headerlink" title="关于子序列和双指针"></a>关于子序列和双指针</h1><p>很多问题会让找某个区间中符合要求的子序列，这里说的是连续的那种，而不是如最长不下降子序列那样断开的。对于连续的子序列可以采用遍历的方法进行查看，对于一维数组序列来说，左指针固定，右指针遍历区间，用O(N^2)的时间完成遍历；对于矩阵来说，则要用到两个双指针，固定列区间后还要用相同的方法遍历行区间，也就是用O(N^4)的时间完成遍历。</p>
<p>另外关于如何优化，如果问题的区间之间带有单调性，那么可以利用这个性质减少遍历的次数，例如对于一维序列找区间和来说，查找符合要求的子区间可以在区间达到最低要求时停止右指针，然后进入下次操作；对于二维矩阵找子矩阵和问题来说，列区间遍历的时间不能优化了，但是行区间遍历也可以用这种方法，行的下界达到临界时，回过去向下移动上界。</p>
<h1 id="结构体的排序"><a href="#结构体的排序" class="headerlink" title="结构体的排序"></a>结构体的排序</h1><p>有时需要对具有多个属性的成员根据某个属性进行排序，此时就可以使用结构体，排序通过sort函数的cmp函数指针实现，自定义排序方案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">    intb b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(student a, student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a&lt;b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> st[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">sort</span>(st,st+<span class="number">3</span>,cmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a>二维dp</h2><p>这里先记录下二维dp，出自经典的dp问题：最长公共子序列，给定两个字符串text1和text2，定义子序列是字符串任意删除字符后得到的子串，也就是不要求子序列的字符在原字符串中连续，和LIS问题(最长不下降子序列)类似，现在求其中最长的公共子序列的长度。</p>
<p>除了暴力枚举其中的每个子序列并比较外，利用动态规划可以很简单地解决这个问题，定义$dp[i][j]$表示text1的前i个前缀和text2的前j个前缀的最长公共子序列长度，那么最终的答案就是dp的终点，现在考虑如何进行状态转移。在边界情况，如果i或者j为零，表示前0个前缀串的公共子序列，显然为0；现在对于$dp[i][j]$如何求解，用动态规划的思路考虑与前面哪个dp值有关。</p>
<p>要求$dp[i][j]$，现在已经知道这个状态之前的所有i，j的最长子序列长度，又因为子序列不要求连续，所以直接看现在到达的两个字符是否相等：</p>
<ul>
<li>如果相等，$dp[i][j] = dp[i-1][j-1]+1$</li>
<li>如果不相等，$dp[i][j] = max(dp[i-1][j],dp[i][j-1])$</li>
</ul>
<p>text1[i]和text[j]相等时，在前面基础上多了一个公共字符，所以直接加1就行了；不相等的时候长度没有增加，就要看这两个字符之前两个字符串的dp状态，取个最大的就行了。这样以后dp的状态就全部分析过了，可以列出方程计算，两层循环得到最后的结果。</p>
<p>当然这个问题可以说还用到了双指针，也就是双指针+dp。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h1><ul>
<li>string.at(i)：取出下标为i的字符；</li>
<li>string.substr(i,n)：从下标为i的地方取出n个字符作为字符串返回；</li>
<li>string str(n,ch)：初始化字符串str为n个ch字符组成的字符串；</li>
<li>string.size() / string.length()：返回字符串长度；</li>
<li>string.resize(n,ch)：字符串长度改为n，不足的部分填充ch字符；</li>
<li>string.erase(i,n)：删除从下标为i开始的n个字符；</li>
</ul>
<h1 id="Vector方法"><a href="#Vector方法" class="headerlink" title="Vector方法"></a>Vector方法</h1><ul>
<li>vector v(n,value)：初始化一个长度为n，值为value的vector；</li>
<li>vector.push_back(x)：在尾部添加元素x；</li>
<li>vector.pop_back()：删除最后一个元素；</li>
<li>vector.clear()：清空数组；</li>
<li>vector.size()：返回数组大小；</li>
</ul>
<h1 id="Map方法"><a href="#Map方法" class="headerlink" title="Map方法"></a>Map方法</h1><ul>
<li>map.insert(pair<element1,element2>(value1,value2))：插入一个pair到map中；</element1,element2></li>
<li>map[value1] = value2：将键值为value1的关键值赋值为value2；</li>
<li>map.find(value1)：找到键值为value1的关键值返回；</li>
<li>map.erase(map.begin(), map.end())：清空元素；</li>
<li>map.size()：返回map大小；</li>
</ul>
<h1 id="C-枚举排列"><a href="#C-枚举排列" class="headerlink" title="C++枚举排列"></a>C++枚举排列</h1><p>STL提供了一个能得到数组元素不同排列顺序的方法：next_permutation(stl.begin(), stl.end())，调用后会排出新的容器序列，并返回一个bool值指示还有没有没有下一个未经遍历的序列。</p>
<p>另外，也可以通过递归的方法进行排列遍历，有机会的话在暴力求解中再说明。</p>
<h1 id="解答树"><a href="#解答树" class="headerlink" title="解答树"></a>解答树</h1><p>如果一个问题的解可以通过重复的步骤和步骤中多个选择的策略得到，而且这些策略可能依赖于先前的选择，可以用递归枚举法实现，它的工作方法可以用解答树描述。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>408</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>games101系列(2) 三角形的光栅化</title>
    <url>/2022/09/02/games2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面说到，在渲染管线中顶点流首先经过MVP变换，得到一个标准立方体(canonical cubic)，但是显然不能将这个立方体直接显示到屏幕上，而是要将这个立方体压到屏幕上，从而给每个像素赋值，这一步就是光栅化。当然，将立方体压到屏幕上这个过程显然是在对Z轴上的坐标进行处理，在这之前还需要先处理一下X，Y轴坐标，这就是视口矩阵的作用。<br><span id="more"></span><br>现在我们先介绍视口矩阵，然后再关注三角形的光栅化。</p>
<h1 id="视口矩阵"><a href="#视口矩阵" class="headerlink" title="视口矩阵"></a>视口矩阵</h1><p>标准立方体是通过某种投影，将顶点坐标变换到标准立方体空间中得到的结果，这个立方体包含了所有我们需要表示的物体。而现在要处理各个物体的XYZ坐标，符合屏幕大小，并且还要通过某种方式来做出物体遮挡的效果。直观地来想，调整到屏幕大小应该是在XY轴上处理，遮挡应该是在Z轴上处理，所以先处理XY轴，通过视口矩阵让XY坐标放大，计算出屏幕坐标，再思考如何处理Z轴。</p>
<p>上一节求出的标准立方体，坐标范围都在[-1,1]之间，实际上视口矩阵的处理也很简单，因为屏幕坐标规定的范围分别是[0,width]和[0,height]，所以想到之前的线性变换，只需要一个平移和一个缩放，也就是一次仿射变换，就能得到需要的屏幕坐标了。</p>
<p>首先对坐标进行一次缩放，标准立方体的X，Y轴长度都是2，等比例放大到width和height，也就是变成原来的width/2和height/2倍，接着都向正方向平移一半的长度，就将起始位置变换到(0,0)。<br><img src="/2022/09/02/games2/1.jpg" alt="场景"></p>
<p>现在可以总结一下顶点坐标的变换了，一个物体的顶点流，先经过(MVP变换)模型视图变换，投影变换，得到标准立方体(canonical cubic)，然后还要经过视口变换，将裁剪坐标系中的XY坐标变换到屏幕坐标系，与Z坐标进入光栅化过程。</p>
<h1 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h1><p>光栅化的真正原因是受限于硬件的像素排布，我们会给每个像素计算一个颜色用于显示，而每个像素显示怎样的颜色，才是要解决的问题。</p>
<p>这时就需要用到前面的处理的坐标了，通过采样的方式，我们判断每个像素在什么物体的面上，根据物体的颜色给像素赋值，建立一种映射关系。下图是2D平面的三角形光栅化例子。<br><img src="/2022/09/02/games2/2.jpg" alt="场景"><br>显然，判断一个像素点是否在这个三角形内部是非常必要的。下面的算法假设像素大小为1*1，平面最左下角坐标为(0,0)。<br><img src="/2022/09/02/games2/3.jpg" alt="场景"></p>
<h2 id="判断点在三角形内部"><a href="#判断点在三角形内部" class="headerlink" title="判断点在三角形内部"></a>判断点在三角形内部</h2><p>这里使用的方法是判断向量叉积，只要一个点在三角形内部，那么从三个顶点到该点连线的向量，与顺序连接三个顶点得到的边向量，他们分别的乘积，一定是同号的。否则，一定会有异号的结果。<br><img src="/2022/09/02/games2/4.jpg" alt="场景"><br>如图顺时针连接P0，P1，P2，得到向量P0P1，P1P2，P2P0，同时连接指向Q点的三个向量P0Q，P1Q，P2Q，计算叉积P0P1与P0Q&gt;0，P1P2与P1Q&gt;0，P2P0与P2Q&lt;0，因此判断Q在三角形外部。</p>
<h2 id="bouding-box"><a href="#bouding-box" class="headerlink" title="bouding box"></a>bouding box</h2><p>为了减少需要计算的像素点，采用包围盒是很有用的措施，利用三角形三个顶点可以求出一个包围三角形的长方体如下，只需要计算包围盒中的像素即可，因为包围盒外部的像素不可能在三角形中。<br><img src="/2022/09/02/games2/5.jpg" alt="场景"></p>
<h2 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h2><p>锯齿的产生是因为采样率低(低分辨率)导致的信号混叠，详细原理涉及频域和时域的傅里叶变换，这部分可以看课程理解，不理解也可以直观感受抗锯齿或者反走样的做法。</p>
<p>前面光栅化得到的三角形与实际看到的三角形差别很大，就是因为锯齿的存在。而反走样也有一些方法，最简单的是低通滤波器，用这个卷积核将图形中的高通滤波过滤，就得到模糊的样本，在一定程度上消除锯齿，使其同样变得模糊。<br><img src="/2022/09/02/games2/6.jpg" alt="场景"></p>
<p>还有一个方法叫超采样(MSAA)，增加采样频率，将每个像素分成很多个像素采样，最后平均像素中子像素得到的结果。<br><img src="/2022/09/02/games2/7.jpg" alt="场景"></p>
<p>当然还有很多反走样技术，稍后的作业2中会实现MSAA反走样，作为入门。</p>
<h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2><p>现在来解决前面留下的Z轴坐标，物体的遮挡关系显然是要通过Z轴坐标来判断，离摄像机近的物体才能被显示到平面上，因此设计一个缓冲区，也就是Z—Buffer来判断，在之前遍历像素的过程中，如果发现了物体某个点有更靠近平面的Z值，就将这个对应像素的值更新为靠近平面的点的值。</p>
<h1 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h1><p>作业2要实现一个三角形的光栅化过程，其中我们需要编写的是三角形bounding box求解的函数，以及判断三角形内部的Inside函数，当然还有深度测试即像素更新。</p>
<h2 id="三角形光栅化函数"><a href="#三角形光栅化函数" class="headerlink" title="三角形光栅化函数"></a>三角形光栅化函数</h2><p>我们从基本的光栅化开始，要绘制的物体只有两个固定的三角形，所以要先设计函数求三角形的包围盒，然后遍历包围盒中的像素，进行深度测试，并更新深度缓存中的深度值和对应像素的颜色，最后得到正确的渲染结果。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t) </span><br><span class="line">&#123;</span><br><span class="line">    auto v = t.toVector4();//返回顶点的齐次坐标形式</span><br><span class="line">    </span><br><span class="line">    // TODO : Find out the bounding box of current triangle.</span><br><span class="line">    int box_l, box_r, box_b, box_t;</span><br><span class="line">    box_l = static_cast&lt;int&gt; (std::min(v[0].x(), std::min(v[1].x(), v[2].x())));</span><br><span class="line">    box_r = static_cast&lt;int&gt; (std::max(v[0].x(), std::max(v[1].x(), v[2].x())));</span><br><span class="line">    box_b = static_cast&lt;int&gt; (std::min(v[0].y(), std::min(v[1].y(), v[2].y())));</span><br><span class="line">    box_t = static_cast&lt;int&gt; (std::max(v[0].y(), std::max(v[1].y(), v[2].y())));</span><br><span class="line">    </span><br><span class="line">    // iterate through the pixel and find if the current pixel is inside the triangle</span><br><span class="line">    for (int i = box_l; i &lt;= box_r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = box_b; j &lt;= box_t; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // If so, use the following code to get the interpolated z value.</span><br><span class="line">            if (insideTriangle(i + 0.5, j + 0.5, t.v))</span><br><span class="line">            &#123;</span><br><span class="line">                float alpha, beta, gamma;   </span><br><span class="line">                std::tie(alpha, beta, gamma) = computeBarycentric2D(static_cast&lt;float&gt;(i + 0.5), static_cast&lt;float&gt;(j + 0.5), t.v);</span><br><span class="line">                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span><br><span class="line">                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                if (depth_buf[get_index(i, j)] &gt; -z_interpolated)</span><br><span class="line">                &#123;</span><br><span class="line">                    // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span><br><span class="line">                    depth_buf[get_index(i, j)] = -z_interpolated;</span><br><span class="line"></span><br><span class="line">                    Eigen::Vector3f point;</span><br><span class="line">                    point &lt;&lt; static_cast&lt;float&gt;(i), static_cast&lt;float&gt;(j), -z_interpolated;</span><br><span class="line">                    set_pixel(point, t.getColor());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>求解包围盒很简单，找到三角形坐标的四个最值并记录，要记得转换为整型变量，因为像素是以1为单位长度的，就像课程中假设的那样。然后，直接根据这个坐标开始遍历，对象是用i为横坐标，j为纵坐标表示的像素，如果该像素在传入的三角形当中(使用下面编写的函数判断，而且所有坐标都转换到屏幕空间了)，那么先计算该坐标位置的深度插值(利用三角形重心坐标，只需要知道顶点就可以计算任意位置的深度值)，并比较当前深度缓存中该像素的深度，如果这个深度值小于当前深度缓存值，说明现在找到一个更靠近屏幕的点，应该优先显示，所以更新深度缓存的值，同时也更新该像素的颜色，就完成了一次遍历的过程。</p>
<p>值得说明的是，网上有博客指出Z值并没有反转，所以如果你直接使用原本的Z值，得到的结果正好与作业说明相反，是下面这个样子：<br><img src="/2022/09/02/games2/9.jpg" alt="场景"><br>所以，要得到和他相同的结果，实际上需要手动将得到的Z轴插值取反，这就是上面负号的由来了。最终得到的效果是这样：<br><img src="/2022/09/02/games2/10.jpg" alt="场景"><br>另外，如果将大于改成小于，而不改变符号，那么得到的是全黑的窗口，这显然是因为完全没有更新过，说明深度缓存的初始值是一个很大的正值。在代码中可以找到，clear函数中会将深度值赋值为正无穷Infinity。</p>
<p>现在再从上面的基础上实现2*2的MSAA抗锯齿。根据前面介绍的原理，现在修改一下像素个数和像素坐标，将原来的每个像素划分为四块即可，然后根据这四个子像素在三角形中的个数，然后决定颜色的比例。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t) </span><br><span class="line">&#123;</span><br><span class="line">    auto v = t.toVector4();//返回顶点的齐次坐标形式</span><br><span class="line"></span><br><span class="line">    // TODO : Find out the bounding box of current triangle.</span><br><span class="line">    int box_l, box_r, box_b, box_t;</span><br><span class="line">    box_l = static_cast&lt;int&gt; (std::min(v[0].x(), std::min(v[1].x(), v[2].x())));</span><br><span class="line">    box_r = static_cast&lt;int&gt; (std::max(v[0].x(), std::max(v[1].x(), v[2].x())));</span><br><span class="line">    box_b = static_cast&lt;int&gt; (std::min(v[0].y(), std::min(v[1].y(), v[2].y())));</span><br><span class="line">    box_t = static_cast&lt;int&gt; (std::max(v[0].y(), std::max(v[1].y(), v[2].y())));</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Eigen::Vector2f&gt; position&#123;</span><br><span class="line">        &#123;0.25, 0.25&#125;,</span><br><span class="line">        &#123;0.75, 0.25&#125;,</span><br><span class="line">        &#123;0.25, 0.75&#125;,</span><br><span class="line">        &#123;0.75, 0.75&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // iterate through the pixel and find if the current pixel is inside the triangle</span><br><span class="line">    for (int i = box_l; i &lt;= box_r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = box_b; j &lt;= box_t; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int count = 0;</span><br><span class="line">            for (int index = 0; index &lt; 4; index++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(insideTriangle(position[index].x() + i, position[index].y() + j, t.v))</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">            // If so, use the following code to get the interpolated z value.</span><br><span class="line">            if (count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                float alpha, beta, gamma;</span><br><span class="line">                std::tie(alpha, beta, gamma) = computeBarycentric2D(static_cast&lt;float&gt;(i + 0.5), static_cast&lt;float&gt;(j + 0.5), t.v);</span><br><span class="line">                float w_reciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span><br><span class="line">                float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                if (depth_buf[get_index(i, j)] &gt; -z_interpolated)</span><br><span class="line">                &#123;</span><br><span class="line">                    // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span><br><span class="line">                    depth_buf[get_index(i, j)] = -z_interpolated;</span><br><span class="line"></span><br><span class="line">                    Eigen::Vector3f point;</span><br><span class="line">                    point &lt;&lt; static_cast&lt;float&gt;(i), static_cast&lt;float&gt;(j), -z_interpolated;</span><br><span class="line">                    set_pixel(point, t.getColor() * (count / 4.0));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可能采样数较少，这里看着还是不太明显。算法上改变的并不多，详细步骤是对每个像素计算子像素的四个坐标，只要有一个子像素在三角形中，就进入if更新，并且根据子像素在三角形中的比例调整颜色百分比，从而实现”模糊”的效果。<br><img src="/2022/09/02/games2/10.jpg" alt="场景"></p>
<h2 id="三角形内部函数"><a href="#三角形内部函数" class="headerlink" title="三角形内部函数"></a>三角形内部函数</h2><p>方法和前面介绍的一样，三个叉积符号判断是否在内部，这里选择的边向量是逆时针连接，那么根据右手定则，在内部时结果都为正，所以只要有一个结果为负数，就说明不在三角形内部。</p>
<p>这里注意作业的说明，将Z值做了反转，保证都是正值，也就是说本来框架中屏幕向里才是Z轴的负方向，屏幕向外是Z轴的正方向，所以前面判断叉积结果为正没有问题(根据右手定则拇指朝外)。而且两个二维向量的叉积，实际上是两个第三维为0的三维向量进行叉积，按照右手系标准确定方向，计算结果确定正负，所以直接通过数值判断也是正确的。<br><img src="/2022/09/02/games2/8.jpg" alt="场景"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static bool insideTriangle(int x, int y, const Vector3f* _v)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span><br><span class="line">    Vector3f a, b, c;</span><br><span class="line">    //只关注XY坐标，Z坐标为视为0</span><br><span class="line">    a &lt;&lt; _v[1].x() - _v[0].x(), _v[1].y() - _v[0].y(), 0;</span><br><span class="line">    b &lt;&lt; _v[2].x() - _v[1].x(), _v[2].y() - _v[1].y(), 0;</span><br><span class="line">    c &lt;&lt; _v[0].x() - _v[2].x(), _v[0].y() - _v[2].y(), 0;</span><br><span class="line"></span><br><span class="line">    Vector3f d, e, f;</span><br><span class="line">    d &lt;&lt; x - _v[0].x(), y - _v[0].y(), 0;</span><br><span class="line">    e &lt;&lt; x - _v[1].x(), y - _v[1].y(), 0;</span><br><span class="line">    f &lt;&lt; x - _v[2].x(), y - _v[2].y(), 0;</span><br><span class="line"></span><br><span class="line">    if (a.cross(d).z() &lt; 0 || b.cross(e).z() &lt; 0 || c.cross(f).z() &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能由于Eigen的cross函数只支持三维向量的计算，所以如果用二维向量，需要手动用公式进行计算，否则可能编译错误；使用三维向量，只需要将第三维设置成0即可。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>games101</category>
      </categories>
      <tags>
        <tag>gmaes101</tag>
        <tag>Computer Graphics</tag>
        <tag>Rsterization</tag>
      </tags>
  </entry>
  <entry>
    <title>games101系列(3) 光照和纹理</title>
    <url>/2024/10/05/games3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面两个作业内容以后，我们已经掌握了简单的几何变换以及光栅化过程，现在可以将一个物体和摄像机移动到任意位置，投影得到屏幕坐标，然后通过光栅化与深度测试，计算屏幕上每个像素的值，从而将物体显示到屏幕上。现在，我们再考虑一下真实感，显然颜色是我们忽略的，物体也没有什么阴影，在作业3中，我们使用纹理和光照模型，渲染一个obj对象。着色(Shading)，给每个像素一个确定的颜色表示，让物体显示出明暗特征；纹理，让物体表面呈现不同的性质(凹凸，颜色等)。之前的作业中，我们都是用的黑白颜色来表示物体。<br><span id="more"></span><br>现在，我们先介绍Blinn-Phong反射模型，这是一种简单的光照模型；然后再看看纹理技术的实现，最后在作业中将这些方法全部实现。</p>
<h1 id="Blinn—Phong-Reflectance-Model"><a href="#Blinn—Phong-Reflectance-Model" class="headerlink" title="Blinn—Phong Reflectance Model"></a>Blinn—Phong Reflectance Model</h1><p>通过观察光照下的一个光滑物体表面(下面的茶杯)，这种模型将物体上的光分为三种类。<br><img src="/2024/10/05/games3/1.jpg" alt="场景"></p>
<ul>
<li>Specular highlights，镜面光，是物体上最亮的那部分高光；</li>
<li>Diffuse reflection，漫反射光，是物体上渐变的那部分光，在面对光源的地方让物体显得比较明亮，背对光源的地方让物体显得比较暗淡；</li>
<li>Ambient lighting，环境光，环境中其他物体反射到茶杯上的光；</li>
</ul>
<p>通过这三种类型的光，就能简单地模拟光照情况。现在从数学角度介绍一下这几种光的计算方法。</p>
<h2 id="Diffuse-reflection"><a href="#Diffuse-reflection" class="headerlink" title="Diffuse reflection"></a>Diffuse reflection</h2><p>显然，这种光出现的地方应该和物体与光源的角度有关。正对光源就应该比较亮，否则就比较暗。所以我们先定义几个方向向量，然后在此基础上具体计算。<br><img src="/2024/10/05/games3/2.jpg" alt="场景"><br>l是从待着色点指向光源的单位向量，n是待着色点在物体表面的法线向量，b则是从待着色点指向摄像机的单位向量。初次之外，还做一种假设，一个点光源朝四面八方发出光线，能量会逐渐衰减，这里假设能量与离光源的距离的平方成反比。最后得到这样的式子，被称为Lambert’s law：<br><img src="/2024/10/05/games3/3.jpg" alt="场景"><br>其中 <em>Ld</em> 是待着色点光强，<em>Kd</em> 是漫反射系数，决定物体接受光照以后是什么颜色；<em>I</em> 表示点光源的能量，<em>r</em> 表示距离；最后一项决定光源以这种角度照射到着色点，会接受多少能量，且这个值不会为负数，否则后方照来的光线也会照亮待着色点。</p>
<p>漫反射光的位置与摄像机视角无关，只和光源与物体表面法线的夹角有关。</p>
<h2 id="Specular-highlights"><a href="#Specular-highlights" class="headerlink" title="Specular highlights"></a>Specular highlights</h2><p>从直觉上感受，镜面光应该与摄像机视角有关了，从光学上解释，这部分光是光源的光线反射出来的，包含了大部分的能量，所以比较明亮。</p>
<p>通过反射，我们定义一个半程向量h，也就是向量l和v的角平分线向量。<br><img src="/2024/10/05/games3/6.jpg" alt="场景"><br>之所以使用这个向量，是因为我们假设当观察视角和反射光方向比较接近的时候，看到的镜面光比较强；而这个时候，角平分线向量就应该比较接近法线向量，也就是直接比较法线向量n和这个半程向量就可以得出光照结果了，避免了反射光的复杂计算。<br><img src="/2024/10/05/games3/4.jpg" alt="场景"><br>然后和漫反射相似，也定义一个镜面反射系数 <em>Ks</em>， 另外还引入一个容忍度 <em>p</em>。<br><img src="/2024/10/05/games3/5.jpg" alt="场景"><br>由于后一项一定是在[0,1]之间的值，所以容忍度p越大，随着夹角变大，该项下降地就越快，镜面光就越暗，也就是容忍度与镜面光面积大小成反比。</p>
<h2 id="Ambient-lighting"><a href="#Ambient-lighting" class="headerlink" title="Ambient lighting"></a>Ambient lighting</h2><p>由于是环境光，所以从任何方向观察都应该没有变化，而且还不和光源有关系，换句话说这种光应该是常数项。<br><img src="/2024/10/05/games3/7.jpg" alt="场景"><br><em>Ka</em> 是环境光反射系数，<em>Ia</em>则是环境光强度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们将三种光加起来，这就是Blinn-Phong反射模型的效果。不过要注意，这种光照模型是各向同性的，如果固定视角和光源，旋转物体，得到的效果完全一样，因此不适用于各向异性材质。<br><img src="/2024/10/05/games3/8.jpg" alt="场景"></p>
<h1 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h1><h2 id="Flat-Shading-平面着色"><a href="#Flat-Shading-平面着色" class="headerlink" title="Flat Shading 平面着色"></a>Flat Shading 平面着色</h2><p>这种着色方式对每个三角形进行一次着色，每个面计算一个法线向量。<br><img src="/2024/10/05/games3/9.jpg" alt="场景"></p>
<h2 id="Gouraud-Shading-顶点着色"><a href="#Gouraud-Shading-顶点着色" class="headerlink" title="Gouraud Shading 顶点着色"></a>Gouraud Shading 顶点着色</h2><p>对每个顶点进行一次着色，以插值的方式计算所有点的颜色。<br><img src="/2024/10/05/games3/10.jpg" alt="场景"><br>这样一来每个顶点都需要一个法线，使用每个顶点相邻面的法线和的平均值(例如加权和平均)。<br><img src="/2024/10/05/games3/12.jpg" alt="场景"><br><img src="/2024/10/05/games3/13.jpg" alt="场景"></p>
<h2 id="Phong-Shading-像素着色"><a href="#Phong-Shading-像素着色" class="headerlink" title="Phong Shading 像素着色"></a>Phong Shading 像素着色</h2><p>这种着色方式并不是前面提到的光照模型，对每个像素计算一个法线，方法就是先计算每个顶点的法线，然后利用重心坐标，求出三角形内部的所有像素的法线。<br><img src="/2024/10/05/games3/11.jpg" alt="场景"></p>
<h1 id="实时渲染管线"><a href="#实时渲染管线" class="headerlink" title="实时渲染管线"></a>实时渲染管线</h1><p><img src="/2024/10/05/games3/14.jpg" alt="场景"></p>
<p>现在可以好好总结渲染管线了，首先我们定义一系列顶点，以及这些顶点的连接方式，从而构成一个物体。<br><img src="/2024/10/05/games3/15.jpg" alt="场景"><br>然后对这些顶点流斤进行MVP变换，移动到我们想要的位置。确定以后，按照连接方式连接这些顶点，形成三角形流。<br><img src="/2024/10/05/games3/16.jpg" alt="场景"><br>接着像素在许多三角形上进行采样，判断内部外部，生成片段流。这里的片段流指的是一个采样点覆盖的区域，例如一个像素采样一次就是一个片段，一个像素如果有四个子像素采样就是四个片段。<br><img src="/2024/10/05/games3/17.jpg" alt="场景"><br>进行深度测试，用Z-Buffer判断不同片段的可见性。<br><img src="/2024/10/05/games3/18.jpg" alt="场景"><br>完成后光照模型也在这里应用，依然对可见的片段流处理。通过插值求出片段流的法线向量。<br><img src="/2024/10/05/games3/19.jpg" alt="场景"><br>纹理操作同样对片段进行处理，这部分后面再介绍。</p>
<p>根据处理对象的不同，各种计算也发生在不同的阶段，例如对顶点进行几何变换就是顶点处理阶段发生的，规定三角形法线自然也要到三角形处理阶段完成，反比后面计算顶点法线，甚至进行插值。当然不同的API有不同的渲染管线定义，大致和这个类似，也不用完全依照这个记忆，重在理解。</p>
<h1 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h1><p>物体上如果通过手动指定的方式实现各种细节，需要的数据量是非常大的，所以采用纹理进行辅助，让物体上的一个点能够通过查询的方式找到它对应的属性，这个属性可以是颜色，也可以是几何特点，还可以是其他特征。</p>
<p>而纹理函数通常是二维的函数，定义纹理坐标(u,v)用来查询纹理上的值，纹理坐标又对应实际渲染像素(i,j)，通过某种方式将像素(或者说片段)的坐标映射到纹理坐标，查询需要的特征，就是纹理映射的过程。</p>
<h2 id="像素放大"><a href="#像素放大" class="headerlink" title="像素放大"></a>像素放大</h2><p>纹理分辨率过小，导致纹理映射的纹理坐标出现非整数值，所以需要将纹理放大。这里有三种放大纹理的方法，Nearst，Bilinear，Bicubic。<br><img src="/2024/10/05/games3/20.jpg" alt="场景"><br>Nearst，根据纹理坐标取最近的整数值，即四舍五入，不过这样导致不同的纹理查询到相同的颜色。</p>
<p>Bilinear，双线性插值，在u，v方向上先选择一个方向进行线性插值，然后再使用插值结果在另外一个方向进行线性插值，就是双线性插值。<br><img src="/2024/10/05/games3/21.jpg" alt="场景"><br>如图先选择水平u方向插值，得到u0和u1，然后用u1和u0的垂直v方向插值，得到目标点的颜色值。</p>
<p>Bicubic，和双线性插值类似，不过取16个相邻的纹理颜色而不是4个进行插值。</p>
<h2 id="像素缩小"><a href="#像素缩小" class="headerlink" title="像素缩小"></a>像素缩小</h2><p>纹理分辨率过大，查询的时候一个像素可能对应多个纹理值，应该缩小纹理。提高采样频率可以解决，例如前面的MSAA，但是太耗费时间。</p>
<h3 id="MipMap"><a href="#MipMap" class="headerlink" title="MipMap"></a>MipMap</h3><p>采用范围查询代替点查询，具体做法是使用Mipmap，不断对一个纹理进行区域平均(平均一定大小块的颜色值)。<br><img src="/2024/10/05/games3/22.jpg" alt="场景"><br>但是怎么确定查询那个维度等级的MipMap呢？首先我们知道，维度每上升一次，纹理大小就缩小一倍，因此我们要找到这个缩放的比例，就先定义一个距离L，在一个像素查询纹理的同时，查询它相邻两个像素的纹理坐标，通过这三个纹理坐标计算L如下：<br><img src="/2024/10/05/games3/23.jpg" alt="场景"><br>然后直接对L取对数，找到缩小多少倍，就得到维度D了。当然D可能不是整数，需要进一步处理。如果直接四舍五入，得到的纹理显然不连续。</p>
<h4 id="三线性插值"><a href="#三线性插值" class="headerlink" title="三线性插值"></a>三线性插值</h4><p>对于D不是正数的情况，当然还可以通过插值解决。在D的两个上下界维度的MipMap中，分别做双线性插值，找到两个对应的纹理特征，再用这两个特征在MipMap维度上插值。<br><img src="/2024/10/05/games3/24.jpg" alt="场景"><br>通过这样的方式查新一个像素的纹理，整个图形得到的纹理特征就显然是连续的了。</p>
<h3 id="各向异性"><a href="#各向异性" class="headerlink" title="各向异性"></a>各向异性</h3><p>现在看看MipMap处理后的结果图形。<br><img src="/2024/10/05/games3/25.jpg" alt="场景"><br>这是直接采样的结果。<br><img src="/2024/10/05/games3/26.jpg" alt="场景"><br>通过上面的MipMap得到的结果，在远处的图形还是变得模糊了，这是因为MipMap处理的仅是正方形，前面进行距离L计算的时候，取像素邻居模拟的是一个正方形形状，但是有时候映射到纹理图上这个像素邻居组成的矩形并不是正方形，而是矩形或其他形状。而且，三线性插值本来也是一种近似处理，所以得到的结果显然没有那么精细。<br><img src="/2024/10/05/games3/27.jpg" alt="场景"></p>
<p>解决的方法就是使用各向异性过滤，可以设置将MipMap在水平或竖直方向进行压缩，从而解决映射结果为水平矩形或者竖直矩形的问题。但是对于斜的矩形，仍然效果不好，可以使用EWA过滤解决，这里不再讨论。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="环境光贴图-Environment-Map"><a href="#环境光贴图-Environment-Map" class="headerlink" title="环境光贴图 Environment Map"></a>环境光贴图 Environment Map</h3><p>用贴图记录各个方向的光照，表示环境光。</p>
<h2 id="凹凸贴图-Bump-Mapping"><a href="#凹凸贴图-Bump-Mapping" class="headerlink" title="凹凸贴图 Bump Mapping"></a>凹凸贴图 Bump Mapping</h2><p>记录顶点法线的偏移，但是不改变物体原本的几何信息。查询到纹理坐标后，先求该坐标在凹凸曲线上的法线(通过导数)，然后再垂直并取单位值得到法线向量。图中h表示高度函数，C表示扰动程度。<br><img src="/2024/10/05/games3/28.jpg" alt="场景"><br><img src="/2024/10/05/games3/29.jpg" alt="场景"></p>
<p>三维的情况，先求其中两个方向的切线，然后同样垂直得到结果。<br><img src="/2024/10/05/games3/30.jpg" alt="场景"></p>
<h3 id="位移贴图-Displacement-mapping"><a href="#位移贴图-Displacement-mapping" class="headerlink" title="位移贴图 Displacement mapping"></a>位移贴图 Displacement mapping</h3><p>使用和凹凸贴图相同的原理，不过会使得顶点实际发生移动。凹凸贴图和位移贴图会在作业中实现。</p>
<h3 id="程序化纹理-Procedural-Noise-amp-Procedural-textures"><a href="#程序化纹理-Procedural-Noise-amp-Procedural-textures" class="headerlink" title="程序化纹理 Procedural Noise&amp;Procedural textures"></a>程序化纹理 Procedural Noise&amp;Procedural textures</h3><p>定义一种噪声函数作为纹理来进行查询。</p>
<h3 id="预计算着色-Precomputed-Shading"><a href="#预计算着色-Precomputed-Shading" class="headerlink" title="预计算着色 Precomputed Shading"></a>预计算着色 Precomputed Shading</h3><p>纹理存储环境光遮蔽的信息，着色的时候使用其他着色结果与这个信息作用，得到结果。</p>
<h3 id="3D-Texture-and-Volume-rendering"><a href="#3D-Texture-and-Volume-rendering" class="headerlink" title="3D Texture and Volume rendering"></a>3D Texture and Volume rendering</h3><p>纹理是三维的，应用在体积渲染中。</p>
<h1 id="作业3"><a href="#作业3" class="headerlink" title="作业3"></a>作业3</h1><p>作业3的内容比较多，在这次作业中实现了一个完整的渲染框架，包括前面的变换，以及这次的光照纹理，一共实现了五种渲染，使用法线作为颜色的Normal，使用Phong光照模型的Phong，应用了纹理的Texture，使用了凹凸贴图并且以法线作为颜色的Bump，最后应用了位移贴图的Displacement，要编写的就是这些shader，其中第一个shader已经给出。</p>
<h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>使用前面编写的函数即可。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO: Use the same projection matrix from the previous assignments</span><br><span class="line">    // Students will implement this function</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f M_p_o, M_scale, M_translate;</span><br><span class="line"></span><br><span class="line">    //计算视锥</span><br><span class="line">    float top, bottom, left, right, near, far, fovY;</span><br><span class="line"></span><br><span class="line">    fovY = eye_fov / 180 * PI;</span><br><span class="line"></span><br><span class="line">    near = -zNear;</span><br><span class="line">    far = zFar;</span><br><span class="line"></span><br><span class="line">    top = tan(fovY / 2) * zNear;</span><br><span class="line">    bottom = -top;</span><br><span class="line"></span><br><span class="line">    right = top * aspect_ratio;</span><br><span class="line">    left = -right;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //计算矩阵</span><br><span class="line">    M_scale &lt;&lt; 2 / (right - left), 0, 0, 0,</span><br><span class="line">        0, 2 / (top - bottom), 0, 0,</span><br><span class="line">        0, 0, 2 / (near - far), 0,</span><br><span class="line">        0, 0, 0, 1;</span><br><span class="line"></span><br><span class="line">    M_translate &lt;&lt;</span><br><span class="line">        1, 0, 0, -(right + left) / 2,//==0</span><br><span class="line">        0, 1, 0, -(top + bottom) / 2,//==0</span><br><span class="line">        0, 0, 1, -(near + far) / 2,//!=0</span><br><span class="line">        0, 0, 0, 1;</span><br><span class="line"></span><br><span class="line">    M_p_o &lt;&lt; near, 0, 0, 0,</span><br><span class="line">        0, near, 0, 0,</span><br><span class="line">        0, 0, near + far, -near * far,</span><br><span class="line">        0, 0, 1, 0;</span><br><span class="line"></span><br><span class="line">    projection = M_scale * M_translate * M_p_o * projection;</span><br><span class="line">    return projection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h2><p>第一个模型由于shader已经给出，现在反而要求是编写片段的各种插值量，修改第二次作业的光栅化函数。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Screen space rasterization</span><br><span class="line">void rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3&gt;&amp; view_pos) </span><br><span class="line">&#123;</span><br><span class="line">    // TODO: From your HW3, get the triangle rasterization code.</span><br><span class="line">    auto v = t.toVector4();//返回顶点的齐次坐标形式</span><br><span class="line"></span><br><span class="line">    // TODO : Find out the bounding box of current triangle.</span><br><span class="line">    int box_l, box_r, box_b, box_t;</span><br><span class="line">    box_l = static_cast&lt;int&gt; (std::min(v[0].x(), std::min(v[1].x(), v[2].x())));</span><br><span class="line">    box_r = static_cast&lt;int&gt; (std::max(v[0].x(), std::max(v[1].x(), v[2].x())));</span><br><span class="line">    box_b = static_cast&lt;int&gt; (std::min(v[0].y(), std::min(v[1].y(), v[2].y())));</span><br><span class="line">    box_t = static_cast&lt;int&gt; (std::max(v[0].y(), std::max(v[1].y(), v[2].y())));</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Eigen::Vector2f&gt; position&#123;</span><br><span class="line">        &#123;0.25, 0.25&#125;,</span><br><span class="line">        &#123;0.75, 0.25&#125;,</span><br><span class="line">        &#123;0.25, 0.75&#125;,</span><br><span class="line">        &#123;0.75, 0.75&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // iterate through the pixel and find if the current pixel is inside the triangle</span><br><span class="line">    for (int i = box_l; i &lt;= box_r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = box_b; j &lt;= box_t; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int count = 0;</span><br><span class="line">            for (int index = 0; index &lt; 4; index++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (insideTriangle(position[index].x() + i, position[index].y() + j, t.v))</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // If so, use the following code to get the interpolated z value.</span><br><span class="line">            if (count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // TODO: Inside your rasterization loop:</span><br><span class="line">                //    * v[i].w() is the vertex view space depth value z.</span><br><span class="line">                //    * Z is interpolated view space depth for the current pixel</span><br><span class="line">                //    * zp is depth between zNear and zFar, used for z-buffer</span><br><span class="line">                float alpha, beta, gamma;</span><br><span class="line">                std::tie(alpha, beta, gamma) = computeBarycentric2D(static_cast&lt;float&gt;(i + 0.5), static_cast&lt;float&gt;(j + 0.5), t.v);</span><br><span class="line">                float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span><br><span class="line">                float zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span><br><span class="line">                zp *= Z;</span><br><span class="line"></span><br><span class="line">                if (depth_buf[get_index(i, j)] &gt; -zp)</span><br><span class="line">                &#123;</span><br><span class="line">                    // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span><br><span class="line">                    depth_buf[get_index(i, j)] = -zp;</span><br><span class="line"></span><br><span class="line">                    //插值求颜色，法线，纹理坐标，着色坐标</span><br><span class="line">                    // TODO: Interpolate the attributes:</span><br><span class="line">                    // auto interpolated_color</span><br><span class="line">                    // auto interpolated_normal</span><br><span class="line">                    // auto interpolated_texcoords</span><br><span class="line">                    // auto interpolated_shadingcoords</span><br><span class="line">                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);</span><br><span class="line">                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1).normalized();</span><br><span class="line">                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);</span><br><span class="line">                    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);</span><br><span class="line">                    // Use: Instead of passing the triangle&#x27;s color directly to the frame buffer, pass the color to the shaders first to get the final color;</span><br><span class="line">                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);</span><br><span class="line">                    payload.view_pos = interpolated_shadingcoords;</span><br><span class="line">                    auto pixel_color = fragment_shader(payload);</span><br><span class="line"></span><br><span class="line">                    Eigen::Vector2i point;</span><br><span class="line">                    point &lt;&lt; i, j;</span><br><span class="line">                    set_pixel(point, pixel_color * (count / 4.0));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>修改一个是上面几项插值计算，颜色，法线，纹理坐标，着色坐标(着色器要用)，计算出重心坐标以后用函数即可。另外还有一个改动是set_pixel，作业二中传入的point三维坐标改成了二维，因为像素只用XY坐标。最后注释给出Z轴插值坐标计算，与作业二相比改了一下名字。<br>实际上必要的代码都给了，但是需要调整代码，不然写完这个函数以后用Normal着色器很可能会报错，多修改几次。<br><img src="/2024/10/05/games3/normal.png" alt="场景"></p>
<h2 id="Phong"><a href="#Phong" class="headerlink" title="Phong"></a>Phong</h2><p>现在开始，就可以正式编写shader了。首先看看给出的法线着色器例子，熟悉一下传入的参数是什么。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eigen::Vector3f normal_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Vector3f return_color = (payload.normal.head&lt;3&gt;().normalized() + Eigen::Vector3f(1.0f, 1.0f, 1.0f)) / 2.f;</span><br><span class="line">    Eigen::Vector3f result;</span><br><span class="line">    result &lt;&lt; return_color.x() * 255, return_color.y() * 255, return_color.z() * 255;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>分析代码，payload包含了片段的颜色、法线，纹理坐标、顶点转换到视角坐标系中的坐标信息，这个着色器中将片段的法线坐标归一化后加上0.5，然后放大到255的颜色值，返回就构成了上面的颜色结果，还是比较好看的。</p>
<p>根据前面介绍的理论，Phong反射光照模型可以用一个公式表示片段颜色，框架中也给了模型中一些值的取值，要做的只是用这些值，在循环中分别计算不同的光照效果，然后相加。注意环境光由于不会改变，所以可以放在循环体外。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);</span><br><span class="line"></span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;</span><br><span class="line"></span><br><span class="line">    float p = 150;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;0, 0, 0&#125;;</span><br><span class="line">    for (auto&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* </span><br><span class="line">        // components are. Then, accumulate that result on the *result_color* object.</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3f l = (light.position - point).normalized();</span><br><span class="line">        Eigen::Vector3f v = (eye_pos - point).normalized();</span><br><span class="line">        Eigen::Vector3f h = (l + v).normalized();</span><br><span class="line"></span><br><span class="line">        float r = (light.position - point).dot(light.position - point);</span><br><span class="line">        //diffuse</span><br><span class="line">        Eigen::Vector3f Ld = kd.cwiseProduct(light.intensity / r) * std::max(0.0f, normal.dot(l));</span><br><span class="line">        //specular</span><br><span class="line">        Eigen::Vector3f Ls = ks.cwiseProduct(light.intensity / r) * std::pow(std::max(0.0f, normal.dot(h)), p);</span><br><span class="line">        result_color += Ls + Ld;</span><br><span class="line">    &#125;</span><br><span class="line">    Eigen::Vector3f La = ka.cwiseProduct(amb_light_intensity);</span><br><span class="line">    result_color += La;</span><br><span class="line"></span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先规定了三种光的反射系数(反射光和总光能量的比例)，其中漫反射就是直接采用在前面插值计算出的颜色，作为物体表面的颜色。然后规定了两个光源，指定了位置和强度(对应RGB分量强度)，确定了摄像机位置，环境光颜色。然后再次规定了片段坐标point，片段法线normal，结合前面规定的光源位置和摄像机位置，还有物体在视点坐标系中的坐标，就可以用这个循环计算两个光源的效果了。</p>
<p>循环里面，计算理论部分定义的l，v，h向量判断光照情况，然后就是公式计算，得到结果颜色后仍然是归一化的结果，放大到255的颜色区间。这样，就完成了一个着色器，不过我看到网上有人说，将环境光计算放到循环里会导致画面变暗，应该是result_color加了两次环境光，环境光有比较暗的情况，导致归一化的结果也变暗了。完成后是下面这个样子。<br><img src="/2024/10/05/games3/phong.png" alt="场景"></p>
<h2 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h2><p>现在在上面光照模型的基础上，还要加上纹理的应用。原理就是修改光照模型的漫反射颜色，其他完全相同。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eigen::Vector3f texture_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    Eigen::Vector3f return_color = &#123;0, 0, 0&#125;;</span><br><span class="line">    if (payload.texture)</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Get the texture value at the texture coordinates of the current fragment</span><br><span class="line">        return_color = payload.texture-&gt;getColor(payload.tex_coords.x(), payload.tex_coords.y());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Eigen::Vector3f texture_color;</span><br><span class="line">    texture_color &lt;&lt; return_color.x(), return_color.y(), return_color.z();</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);</span><br><span class="line">    Eigen::Vector3f kd = texture_color / 255.f;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);</span><br><span class="line"></span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;</span><br><span class="line"></span><br><span class="line">    float p = 150;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = texture_color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;0, 0, 0&#125;;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::Vector3f l = (light.position - point).normalized();</span><br><span class="line">        Eigen::Vector3f v = (eye_pos - point).normalized();</span><br><span class="line">        Eigen::Vector3f h = (l + v).normalized();</span><br><span class="line"></span><br><span class="line">        float r = (light.position - point).dot(light.position - point);</span><br><span class="line">        //diffuse</span><br><span class="line">        Eigen::Vector3f Ld = kd.cwiseProduct(light.intensity / r) * std::max(0.0f, normal.dot(l));</span><br><span class="line">        //specular</span><br><span class="line">        Eigen::Vector3f Ls = ks.cwiseProduct(light.intensity / r) * std::pow(std::max(0.0f, normal.dot(h)), p);</span><br><span class="line">        result_color += Ls + Ld;</span><br><span class="line">    &#125;</span><br><span class="line">    Eigen::Vector3f La = ka.cwiseProduct(amb_light_intensity);</span><br><span class="line">    result_color += La;</span><br><span class="line"></span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实际上，纹理坐标和纹理都已经给到片段的payload中了，而且方法也写好，向上面那样调用，会得到一个三维的颜色值，作为漫反射系数，然后进入Phong反射模型计算颜色即可。<br><img src="/2024/10/05/games3/texture.png" alt="场景"></p>
<h2 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h2><p>知道纹理的基本用法，现在考虑一下凹凸贴图的原理，需要计算微分求切线，微分量取纹理宽度或高度的倒数，然后垂直得到法线向量。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eigen::Vector3f bump_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);</span><br><span class="line"></span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;</span><br><span class="line"></span><br><span class="line">    float p = 150;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color; </span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    float kh = 0.2, kn = 0.1;</span><br><span class="line"></span><br><span class="line">    // TODO: Implement bump mapping here</span><br><span class="line">    // Let n = normal = (x, y, z)</span><br><span class="line">    float x = normal.x();</span><br><span class="line">    float y = normal.y();</span><br><span class="line">    float z = normal.z();</span><br><span class="line">    Vector3f t(x * y / sqrt(x * x + z * z), sqrt(x * x + z * z), z * y / sqrt(x * x + z * z));</span><br><span class="line">    Vector3f b = normal.cross(t);</span><br><span class="line">    Eigen::Matrix3f TBN;</span><br><span class="line">    TBN &lt;&lt; t.x(), b.x(), normal.x(),</span><br><span class="line">        t.y(), b.y(), normal.y(),</span><br><span class="line">        t.z(), b.z(), normal.z();</span><br><span class="line">    //TBN矩阵的作用是将局部坐标转化成实际坐标表示</span><br><span class="line"></span><br><span class="line">    float u = payload.tex_coords.x();</span><br><span class="line">    float v = payload.tex_coords.y();</span><br><span class="line">    float w = payload.texture-&gt;width;</span><br><span class="line">    float h = payload.texture-&gt;height;</span><br><span class="line"></span><br><span class="line">    //求u，v微分</span><br><span class="line">    float dU = kh * kn * (payload.texture-&gt;getColor(u + 1 / w, v).norm() - payload.texture-&gt;getColor(u, v).norm());</span><br><span class="line">    float dV = kh * kn * (payload.texture-&gt;getColor(u, v + 1 / h).norm() - payload.texture-&gt;getColor(u, v).norm());</span><br><span class="line"></span><br><span class="line">    Vector3f ln(-dU, -dV, 1);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f result_color = (TBN * ln).normalized();</span><br><span class="line"></span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注释中写出了大部分伪代码，但是这里还是要说明，凹凸贴图的计算涉及到TBN矩阵和切空间，可以简单理解为把物体的三维坐标和纹理坐标连接起来，课程中只说了后面求局部坐标系中法线的方法，并且让局部坐标系中的法线都为(0,0,1)，这个局部空间实际上就是TBN空间，在u和v方向求切线后得到垂直的扰动法线，当然要将这个纹理空间中的法向量转化到片段所在的空间。所以TBN矩阵就是将局部坐标中的法向量变换到着色时的空间中了。<br><img src="/2024/10/05/games3/Bump.png" alt="场景"><br>具体的计算可以找这部分知识推导，理解可以就这样。</p>
<h2 id="位移贴图"><a href="#位移贴图" class="headerlink" title="位移贴图"></a>位移贴图</h2><p>在实现了凹凸贴图的基础上，对顶点做实际的移动。所以要添加的代码只有一行。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eigen::Vector3f displacement_fragment_shader(const fragment_shader_payload&amp; payload)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);</span><br><span class="line"></span><br><span class="line">    auto l1 = light&#123;&#123;20, 20, 20&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line">    auto l2 = light&#123;&#123;-20, 20, 0&#125;, &#123;500, 500, 500&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;10, 10, 10&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;0, 0, 10&#125;;</span><br><span class="line"></span><br><span class="line">    float p = 150;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color; </span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    float kh = 0.2, kn = 0.1;</span><br><span class="line">    </span><br><span class="line">    // TODO: Implement displacement mapping here</span><br><span class="line">    float x = normal.x();</span><br><span class="line">    float y = normal.y();</span><br><span class="line">    float z = normal.z();</span><br><span class="line">    Vector3f t(x * y / sqrt(x * x + z * z), sqrt(x * x + z * z), z * y / sqrt(x * x + z * z));</span><br><span class="line">    Vector3f b = normal.cross(t);</span><br><span class="line">    Eigen::Matrix3f TBN;</span><br><span class="line">    TBN &lt;&lt; t.x(), b.x(), normal.x(),</span><br><span class="line">        t.y(), b.y(), normal.y(),</span><br><span class="line">        t.z(), b.z(), normal.z();</span><br><span class="line">    //TBN矩阵的作用是将局部坐标转化成实际坐标表示</span><br><span class="line"></span><br><span class="line">    float u = payload.tex_coords.x();</span><br><span class="line">    float v = payload.tex_coords.y();</span><br><span class="line">    float w = payload.texture-&gt;width;</span><br><span class="line">    float h = payload.texture-&gt;height;</span><br><span class="line"></span><br><span class="line">    //求u，v微分，微分量取纹理宽、高的倒数</span><br><span class="line">    float dU = kh * kn * (payload.texture-&gt;getColor(u + 1 / w, v).norm() - payload.texture-&gt;getColor(u, v).norm());</span><br><span class="line">    float dV = kh * kn * (payload.texture-&gt;getColor(u, v + 1 / h).norm() - payload.texture-&gt;getColor(u, v).norm());</span><br><span class="line"></span><br><span class="line">    Vector3f ln(-dU, -dV, 1);</span><br><span class="line"></span><br><span class="line">    //仅仅添加了下面这一行函数</span><br><span class="line">    point = point + kn * normal * payload.texture-&gt;getColor(u, v).norm();</span><br><span class="line"></span><br><span class="line">    normal = (TBN * ln).normalized();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;0, 0, 0&#125;;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular* </span><br><span class="line">        // components are. Then, accumulate that result on the *result_color* object.</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3f l = (light.position - point).normalized();</span><br><span class="line">        Eigen::Vector3f v = (eye_pos - point).normalized();</span><br><span class="line">        Eigen::Vector3f h = (l + v).normalized();</span><br><span class="line"></span><br><span class="line">        float r = (light.position - point).dot(light.position - point);</span><br><span class="line">        //diffuse</span><br><span class="line">        Eigen::Vector3f Ld = kd.cwiseProduct(light.intensity / r) * std::max(0.0f, normal.dot(l));</span><br><span class="line">        //specular</span><br><span class="line">        Eigen::Vector3f Ls = ks.cwiseProduct(light.intensity / r) * std::pow(std::max(0.0f, normal.dot(h)), p);</span><br><span class="line">        result_color += Ls + Ld;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Eigen::Vector3f La = ka.cwiseProduct(amb_light_intensity);</span><br><span class="line">    result_color += La;</span><br><span class="line"></span><br><span class="line">    return result_color * 255.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>得到了下面的结果：<br><img src="/2024/10/05/games3/displacement.png" alt="场景"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>到这里作业就全部完成了，提高项这次就不做了，有机会再说。关于代码还要提到一个点，计算result_color的时候，先声明其为一个全0的三维向量，后面赋值只能一次一次累加，而不能直接赋值，例如result_color = Ls + Ld，只能是result_color += Ls + Ld，否则得到的最后这个位移贴图结果就是比较灰暗的，这就是因为有两个光源，直接赋值显然就错了，只计算了一个光的光照结果。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>games101</category>
      </categories>
      <tags>
        <tag>gmaes101</tag>
        <tag>Computer Graphics</tag>
        <tag>Rsterization</tag>
      </tags>
  </entry>
  <entry>
    <title>games101系列(4) 几何</title>
    <url>/2022/09/07/games4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第四次作业是几何部分的内容，课程中关于这部分讲了很多，比较庞杂，所以只选择了贝塞尔曲线简单实现。博客会回顾一下这部分的知识，然后给出作业效果。<br><span id="more"></span></p>
<h1 id="几何概念"><a href="#几何概念" class="headerlink" title="几何概念"></a>几何概念</h1><h2 id="隐式表示"><a href="#隐式表示" class="headerlink" title="隐式表示"></a>隐式表示</h2><p>间接表示某些满足特定条件的点，例如公式表示f(x,y,z)=0。</p>
<h3 id="隐式表示方法"><a href="#隐式表示方法" class="headerlink" title="隐式表示方法"></a>隐式表示方法</h3><ul>
<li>Algebraic Surface</li>
<li>Constructive Solid Geometry</li>
<li>Distance Functions</li>
<li>Level Set Methods</li>
<li>Fractals</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>描述使用等式，比较简单；</li>
<li>查询简单，速度快；</li>
<li>计算光线容易</li>
<li>能够精确描述简单的物体</li>
<li><p>拓扑变换容易掌握；</p>
</li>
<li><p>但是不能描述复杂的形状。</p>
</li>
</ul>
<h2 id="显式表示"><a href="#显式表示" class="headerlink" title="显式表示"></a>显式表示</h2><p>直接给出点的坐标，或者点坐标的查询方式。</p>
<h3 id="显式表示方法"><a href="#显式表示方法" class="headerlink" title="显式表示方法"></a>显式表示方法</h3><ul>
<li>点云；</li>
<li>多边形面；</li>
<li>wavefront obj，定义点和点的连接关系，纹理坐标，法线等。</li>
</ul>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>容易判断内外；</li>
<li>需要存储空间；</li>
</ul>
<h1 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h1><h2 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2><h3 id="二次贝塞尔曲线"><a href="#二次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线"></a>二次贝塞尔曲线</h3><p><img src="/2022/09/07/games4/1.png" alt="场景"><br><img src="/2022/09/07/games4/2.png" alt="场景"></p>
<h3 id="分段贝塞尔曲线"><a href="#分段贝塞尔曲线" class="headerlink" title="分段贝塞尔曲线"></a>分段贝塞尔曲线</h3><p><img src="/2022/09/07/games4/3.png" alt="场景"></p>
<h1 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h1><h2 id="Subdivision"><a href="#Subdivision" class="headerlink" title="Subdivision"></a>Subdivision</h2><p>增加面数。</p>
<h3 id="Loop-Subvision"><a href="#Loop-Subvision" class="headerlink" title="Loop Subvision"></a>Loop Subvision</h3><p><img src="/2022/09/07/games4/1.jpg" alt="场景"></p>
<h3 id="Catmull—Clark-Subvision"><a href="#Catmull—Clark-Subvision" class="headerlink" title="Catmull—Clark Subvision"></a>Catmull—Clark Subvision</h3><p><img src="/2022/09/07/games4/2.jpg" alt="场景"></p>
<h2 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h2><p>减少面数。</p>
<h3 id="Edge-Collapsing-amp-Quadric-Error-Metrics"><a href="#Edge-Collapsing-amp-Quadric-Error-Metrics" class="headerlink" title="Edge Collapsing &amp; Quadric Error Metrics"></a>Edge Collapsing &amp; Quadric Error Metrics</h3><p><img src="/2022/09/07/games4/3.jpg" alt="场景"></p>
<h2 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h2><p>面数不变。 </p>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>作业4内容就是通过鼠标选择4个控制点，然后绘制贝塞尔曲线。框架直接给出了通过前面推导的二项式公式得出的贝塞尔曲线，也就是数学方法，现在我们要做的是通过几何方法得到正确的贝塞尔曲线。先看看数学方法得到的效果。<br><img src="/2022/09/07/games4/4.jpg" alt="场景"><br>绘制的曲线是红色的，现在看看代码是怎样实现的。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void naive_bezier(const std::vector&lt;cv::Point2f&gt;&amp; points, cv::Mat&amp; window)</span><br><span class="line">&#123;</span><br><span class="line">    auto&amp; p_0 = points[0];</span><br><span class="line">    auto&amp; p_1 = points[1];</span><br><span class="line">    auto&amp; p_2 = points[2];</span><br><span class="line">    auto&amp; p_3 = points[3];</span><br><span class="line"></span><br><span class="line">    for (double t = 0.0; t &lt;= 1.0; t += 0.001)</span><br><span class="line">    &#123;</span><br><span class="line">        auto point = std::pow(1 - t, 3) * p_0 + 3 * t * std::pow(1 - t, 2) * p_1 +</span><br><span class="line">            3 * std::pow(t, 2) * (1 - t) * p_2 + std::pow(t, 3) * p_3;</span><br><span class="line"></span><br><span class="line">        window.at&lt;cv::Vec3b&gt;(point.y, point.x)[2] = 255;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数作用是使用opencv在窗口中改变像素的颜色，所以没有返回值，输入一个是指定的控制点数组points，一个是用于绘制的opencv窗口句柄window。那么现在我们就知道绘制的方法了，先得到要绘制的点的坐标，然后仿照上面使用window.at方法指定。</p>
<p>作业要求实现两个函数，一个是Bezier函数，输入和作用与native_bezier完全相同，只是方法不同，要求对比例t进行迭代，增量微小，每次调用另一个函数recursive_bezier，返回当前t值对应的像素坐标。注意，这里按照要求要将曲线绘制成绿色，所以将像素的RGB中G赋值为255最大值。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void bezier(const std::vector&lt;cv::Point2f&gt;&amp; control_points, cv::Mat&amp; window)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau&#x27;s </span><br><span class="line">    // recursive Bezier algorithm.</span><br><span class="line">    for (double t = 0; t &lt;= 1; t += 0.001)</span><br><span class="line">    &#123;</span><br><span class="line">        auto point = recursive_bezier(control_points, t); </span><br><span class="line">        //下面之所以只赋值[1]，是为了将曲线显示成绿色</span><br><span class="line">        //将y行x列的像素的Green值赋值为255</span><br><span class="line">        window.at&lt;cv::Vec3b&gt;(point.y, point.x)[1] = 255;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再分析另一个，recursive_bezier函数就是使用之前介绍的算法，输入还是控制点，回顾算法过程，实际上是一个递归的过程，三个控制点的贝塞尔曲线，只需要递归一次，四个控制点的贝塞尔曲线，需要递归两次，从中发现一个规律，每递归一次，控制点减少一个，当控制点组points只剩下两个点的时候，按照t比例划分就能得到最后的结果了。所以递归结束的标志就是控制点只剩下两个的时候，将两个控制点的t比例分割点返回即可。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv::Point2f recursive_bezier(const std::vector&lt;cv::Point2f&gt;&amp; control_points, float t)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO: Implement de Casteljau&#x27;s algorithm</span><br><span class="line">    if (control_points.size() == 2) </span><br><span class="line">        return control_points[0] + t * (control_points[1] - control_points[0]);</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;cv::Point2f&gt; ano_points;</span><br><span class="line">    for (int i = 0; i &lt; control_points.size() - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ano_points.push_back(control_points[i] + t * (control_points[i + 1] - control_points[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    return recursive_bezier(ano_points, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这部分函数是参照网上写的，因为我起初没有详细看框架，一些方法不知道怎么用，所以这里建议自己写的时候都看一看框架。现在调用自己编写的函数，得到下面的结果。<br><img src="/2022/09/07/games4/4.png" alt="场景"><br>最后根据作业要求，同时调用Bezier和native_bezier，得到曲线颜色应该是(255,255,0)，也就是黄色，这就说明自己编写的函数是正确的。<br><img src="/2022/09/07/games4/5.png" alt="场景"></p>
<h1 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h1><p>有机会以后再做，作业要求里有注释。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>games101</category>
      </categories>
      <tags>
        <tag>gmaes101</tag>
        <tag>Computer Graphics</tag>
        <tag>Rsterization</tag>
      </tags>
  </entry>
  <entry>
    <title>games101系列(6) 加速结构</title>
    <url>/2022/09/10/games6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面介绍了光线追踪的基本原理，结合光线追踪的特点，可以想到光线追踪有一个很明显的缺点，那就是速度太慢了。为了加速光线追踪的渲染过程，提出包围体积(Bounding Volumes)加速求交点，并且在作业中，我们会将这项技术应用到光线追踪上。<br><span id="more"></span></p>
<h1 id="Bounding-Volumes"><a href="#Bounding-Volumes" class="headerlink" title="Bounding Volumes"></a>Bounding Volumes</h1><p>其实前面光栅化的时候，我们已经介绍过类似的思想了，在对每个像素进行遍历求三角形内外的时候，我们也是用一个包围盒确定要计算的像素，避免每次对很多像素进行计算。而这项技术的做法和名字相同，就是用一个盒子将一个等待求交点的物体包围起来，这样一来我们先判断光线会不会与这个盒子相交，再判断会不会与物体相交，所以这里先介绍如何求一个物体的包围盒。</p>
<h2 id="Axis-Aligned-Bouding-Box"><a href="#Axis-Aligned-Bouding-Box" class="headerlink" title="Axis-Aligned Bouding Box"></a>Axis-Aligned Bouding Box</h2><p><img src="/2022/09/10/games6/1.jpg" alt="场景"><br>这种AABB盒子就是我们说的包围盒，它实际上是一个长方体，那么我们当然想到，确定这个长方体只需要六个值：上下、左右、前后，实际上也就是通过这六个值来表示长方体的。不过如何用这六个值进行求交才是重点，我们先来看看二维的情况。<br><img src="/2022/09/10/games6/2.jpg" alt="场景"><br>仍然使用前面的光线模型，对包围盒求光线与盒子x值与y值的交点，暂时用tmin和tmax表示，如上图。当然，对x值求交点得到了一组[tmin,tmax]，通过对y值求交点又得到了一组[tmin’, tmax’]，而实际上我们需要的是光线什么时候最早进入盒子，什么时候又从盒子最晚出去，所以对这两组中的t，tmin取最大值，tmax又取最小值，也就是两个区间求交集，最后得到一组最终的t，记为[tEnter,tExit]。</p>
<p>在三维空间中，我们也采取相同的做法，tEnter=max(tmin)，tExit=min(tmax)。求这两个t值就可以进行求交的判断了，可以发现以下条件：</p>
<ul>
<li>tEnter&lt;tExit，这是有交点的必要情况；</li>
<li>tExit&lt;0，说明光源在盒子外面，而且光线经过反向延长才离开盒子，所以光线实际上没有交点；</li>
<li>tEnter<0 && texit>=0，这时光源就在盒子内部，也是有交点的；当然如果tEnter&gt;=0，光源就在盒子上或者盒子外部。</0></li>
</ul>
<p>总结三种情况，可以发现当且仅当tEnter<tExit并且tExit>=0，才是有交点的情况，不论光源在盒子内部还是外部。</tExit并且tExit></p>
<p>而之所以不直接求光线和长方体面的交点，也是为了加快速度。</p>
<h2 id="Accelerating"><a href="#Accelerating" class="headerlink" title="Accelerating"></a>Accelerating</h2><p>上面介绍了如何使用一个包围盒，现在实际考虑在光线追踪上应用，这其实有很多方法，并不是直接对所有的包围盒求交点，而是将空间划分成不同的区域，这样才能进一步加速，根据光线的位置找出可能相交的少部分包围盒。介绍两种方法，均匀划分(Uniform grids)和空间划分(Spatial partions)。</p>
<h3 id="Uniform-grids"><a href="#Uniform-grids" class="headerlink" title="Uniform grids"></a>Uniform grids</h3><p>你可能注意到了，前面并没有说对某个物体如何求包围盒，因为这并不需要，在均匀划分中，首先是要找到一整个场景的包围盒，然后将这个包围盒分成均匀的块，每个块也是一个包围盒，这样找到那些存在物体的块(内部当然不计算)并存储起来，称为cell，每次对这些cell进行判断就行了。<br><img src="/2022/09/10/games6/3.jpg" alt="场景"><br>当一条光线进入场景，用前面的方法找到光线相交的这些块，如果光线进入了一个cell，那就进一步判断光线是否和物体有交点(就是前一个作业的三角形求交Moller Trumbore Algorithm)。<br><img src="/2022/09/10/games6/4.jpg" alt="场景"><br>如图，前面浅蓝色格子计算的都是包围盒，只有最后一个深蓝色的格子是cell，需要计算物体的交点。这样，就可以加快计算速度了。</p>
<h3 id="Spatial-Partitions"><a href="#Spatial-Partitions" class="headerlink" title="Spatial Partitions"></a>Spatial Partitions</h3><p>上面那种做法显然造成了浪费，在一些没有物体的地方显然没有必要分这么多格子，所以就提出了一些划分空间的做法。</p>
<p><img src="/2022/09/10/games6/5.jpg" alt="场景"></p>
<ul>
<li>八叉树，递归地划分一个正方体，第一个图那样，存在物体的地方就进行递归，直到划分到需要的程度，不过这样会造成存储空间指数上升；</li>
<li>KD-Tree，同样是递归划分，不过每次只朝一个轴划分，例如上面第二个图，先在X轴划分一次，然后对下面的物体在Y轴再次划分；上面的物体Y轴划分后，重新在X轴划分；</li>
<li>BSP-Tree，与KD-Tree类似，不过不要求轴对齐划分，任意选择方向。</li>
</ul>
<p>下面重点介绍KD-Tree，它的存储方式是下面这样：<br><img src="/2022/09/10/games6/6.jpg" alt="场景"><br>存储也是递归的过程，叶子结点一定是具体的包围盒，而非叶子结点一定被划分成叶子结点，所以不存储实际物体。</p>
<p>在递归遍历的时候，从根结点开始找到每个光线穿过的根结点代表的盒子的tmin和tmax，判断是否穿过盒子，如果盒子还有孩子结点，进一步判断是否穿过了孩子结点指向的包围盒，以此类推，最后判断这些结点里面的物体是否和光线相交。<br><img src="/2022/09/10/games6/7.jpg" alt="场景"></p>
<p>做法的缺点：</p>
<ul>
<li>可能一个叶子结点重复存储了一个物体，如果这个物体同时在几个包围盒中；</li>
<li>三角形与包围盒求交点比较困难，导致物体不好判断存储在哪里；</li>
</ul>
<p>要解决这两个问题都很困难，所以，现在介绍一种通过物体划分的方法。</p>
<h3 id="Object-Partitions"><a href="#Object-Partitions" class="headerlink" title="Object Partitions"></a>Object Partitions</h3><p>通过这种方式得到的就是BVH(Bounding Volume Hierarchy)，我们仍然从整个场景的包围盒出发，然后将这个场景中的物体不断划分成两部分，分别计算这两部分物体的包围盒，直到划分得到的最小包围盒中物体数量达到一定要求。<br><img src="/2022/09/10/games6/8.jpg" alt="场景"><br>现在的划分方式又有两个特点：存储不会重复了，但是包围盒边界可能会有交集。而遍历的算法则与上面KD-Tree相似。</p>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>本次作业依然是光线追踪的框架，要求实现与AABB包围盒求交算法以及刚刚介绍的BVH求交算法。</p>
<h2 id="引用代码改动"><a href="#引用代码改动" class="headerlink" title="引用代码改动"></a>引用代码改动</h2><p>有部分需要用到之前作业写的函数，不过需要简单改动。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline Intersection Triangle::getIntersection(Ray ray)</span><br><span class="line">&#123;</span><br><span class="line">    Intersection inter;</span><br><span class="line"></span><br><span class="line">    if (dotProduct(ray.direction, normal) &gt; 0)</span><br><span class="line">        return inter;</span><br><span class="line">    double u, v, t_tmp = 0;</span><br><span class="line">    Vector3f pvec = crossProduct(ray.direction, e2);</span><br><span class="line">    double det = dotProduct(e1, pvec);</span><br><span class="line">    if (fabs(det) &lt; EPSILON)</span><br><span class="line">        return inter;</span><br><span class="line"></span><br><span class="line">    double det_inv = 1. / det;</span><br><span class="line">    Vector3f tvec = ray.origin - v0;</span><br><span class="line">    u = dotProduct(tvec, pvec) * det_inv;</span><br><span class="line">    if (u &lt; 0 || u &gt; 1)</span><br><span class="line">        return inter;</span><br><span class="line">    Vector3f qvec = crossProduct(tvec, e1);</span><br><span class="line">    v = dotProduct(ray.direction, qvec) * det_inv;</span><br><span class="line">    if (v &lt; 0 || u + v &gt; 1)</span><br><span class="line">        return inter;</span><br><span class="line">    t_tmp = dotProduct(e2, qvec) * det_inv;</span><br><span class="line"></span><br><span class="line">    // TODO find ray triangle intersection</span><br><span class="line">    //下面是没有给出的部分</span><br><span class="line">    if(t_tmp &lt; 0)</span><br><span class="line">        return inter;</span><br><span class="line">    </span><br><span class="line">    inter.happened = true;</span><br><span class="line">    inter.distance = t_tmp;</span><br><span class="line">    inter.m = m;</span><br><span class="line">    inter.obj = this;</span><br><span class="line">    inter.normal = normal;</span><br><span class="line">    inter.coords = ray(t_tmp);</span><br><span class="line">    return inter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>回顾前面的三角形求交算法，该函数中已经求出克莱默法则解中的t(t_tmp)，b1(u)，b2(v)，而且前面限制了u，v的取值，所以条件只要求t非负了。Intersection是一个记录数据的结构体，将求出的各种值赋值给对应的变量即可；如果前面几个if判断没有相交，将直接返回，不进行赋值(使用默认值)。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Renderer::Render(const Scene&amp; scene)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;Vector3f&gt; framebuffer(scene.width * scene.height);</span><br><span class="line"></span><br><span class="line">    float scale = tan(deg2rad(scene.fov * 0.5));</span><br><span class="line">    float imageAspectRatio = scene.width / (float)scene.height;</span><br><span class="line">    Vector3f eye_pos(-1, 5, 10);</span><br><span class="line">    int m = 0;</span><br><span class="line">    for (uint32_t j = 0; j &lt; scene.height; ++j) </span><br><span class="line">    &#123;</span><br><span class="line">        for (uint32_t i = 0; i &lt; scene.width; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            float x =  (2 * (i + 0.5) / scene.width  - 1) * scale * imageAspectRatio;</span><br><span class="line">            float y = -(2 * (j + 0.5) / scene.height - 1) * scale;   </span><br><span class="line">            Vector3f dir = normalize(Vector3f(x, y, -1)); </span><br><span class="line">            //下面两行有所改动</span><br><span class="line">            Ray ray(eye_pos,dir);</span><br><span class="line">            framebuffer[m++] = scene.castRay(ray,0);</span><br><span class="line">        &#125;</span><br><span class="line">    UpdateProgress(1.f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // save framebuffer to file</span><br><span class="line">    FILE* fp = fopen(&quot;binary.ppm&quot;, &quot;wb&quot;);</span><br><span class="line">    (void)fprintf(fp, &quot;P6\n%d %d\n255\n&quot;, scene.width, scene.height);</span><br><span class="line">    for (auto i = 0; i &lt; scene.height * scene.width; ++i) &#123;</span><br><span class="line">        static unsigned char color[3];</span><br><span class="line">        color[0] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].x));</span><br><span class="line">        color[1] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].y));</span><br><span class="line">        color[2] = (unsigned char)(255 * clamp(0, 1, framebuffer[i].z));</span><br><span class="line">        fwrite(color, 1, 3, fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数的改动是castRay函数变成类Scene的一个方法了，而且输入中第一个参数变成了光线类Ray，找到Ray的构造函数输入参数即可得到ray，然后作为投射光线函数的参数。</p>
<h2 id="AABB包围盒求交"><a href="#AABB包围盒求交" class="headerlink" title="AABB包围盒求交"></a>AABB包围盒求交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline bool Bounds3::IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir,</span><br><span class="line">                                const std::array&lt;int, 3&gt;&amp; dirIsNeg) const</span><br><span class="line">&#123;</span><br><span class="line">    // invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division</span><br><span class="line">    // dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic</span><br><span class="line">    // TODO test if ray bound intersects</span><br><span class="line">    float x_tmin = (pMin.x - ray.origin.x) * invDir[0];</span><br><span class="line">    float y_tmin = (pMin.y - ray.origin.y) * invDir[1];</span><br><span class="line">    float z_tmin = (pMin.z - ray.origin.z) * invDir[2];</span><br><span class="line">    float x_tmax = (pMax.x - ray.origin.x) * invDir[0];</span><br><span class="line">    float y_tmax = (pMax.y - ray.origin.y) * invDir[1];</span><br><span class="line">    float z_tmax = (pMax.z - ray.origin.z) * invDir[2];</span><br><span class="line"></span><br><span class="line">    if(dirIsNeg[0])</span><br><span class="line">    &#123;</span><br><span class="line">        float t = x_tmin;</span><br><span class="line">        x_tmin = x_tmax;</span><br><span class="line">        x_tmax = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dirIsNeg[1])</span><br><span class="line">    &#123;</span><br><span class="line">        float t = y_tmin;</span><br><span class="line">        y_tmin = y_tmax;</span><br><span class="line">        y_tmax = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dirIsNeg[2])</span><br><span class="line">    &#123;</span><br><span class="line">        float t = z_tmin;</span><br><span class="line">        z_tmin = z_tmax;</span><br><span class="line">        z_tmax = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float tEnter = std::max(x_tmin, std::max(y_tmin, z_tmin));</span><br><span class="line">    float tExit = std::min(x_tmax, std::min(y_tmax, z_tmax));</span><br><span class="line"></span><br><span class="line">    if(tEnter &lt; tExit &amp;&amp; tExit &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在正式进入函数的编写，AABB包围盒的参数通过定义的变量pMin和pMax得到，两者分别记录了包围盒三个轴坐标的最小、最大值，按照前面的方法，我们首先要求出光线和三个轴相交的tmin和tmax值，这一步很简单，光线方程为O+t*d=x/y/z，也就是t=(x/y/z-O.x/y/z)/d，这里第一个x/y/z就是包围盒的六个参数(上下，左右，前后)，O是光源位置(ray.origin)，d则是光线方向dir，注释中说明使用乘法比除法快，所以计算的时候我们直接乘以dir的倒数invdir，对应轴进行对应坐标的计算，得到三组t值。</p>
<p>之后还要进行一个判断，dirIsNeg记录了三个轴上方向向量的正负，因为我们计算交点的t值时，当方向为正都是从小到大的t满足条件，即tEnter<tExit，如果方向为负，实际上t应该是tEnter>tExit满足相交，所以要交换，最后判断条件就是一样的了。</tExit，如果方向为负，实际上t应该是tEnter></p>
<h2 id="递归求BVH交点"><a href="#递归求BVH交点" class="headerlink" title="递归求BVH交点"></a>递归求BVH交点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray&amp; ray) const</span><br><span class="line">&#123;</span><br><span class="line">    // TODO Traverse the BVH to find intersection</span><br><span class="line">    Intersection inter;</span><br><span class="line">    Vector3f invdir(1 / ray.direction.x, 1 / ray.direction.y, 1 / ray.direction.z);</span><br><span class="line"></span><br><span class="line">    std::array&lt;int, 3&gt;dirIsNeg;</span><br><span class="line">    dirIsNeg[0] = ray.direction.x &lt; 0;</span><br><span class="line">    dirIsNeg[1] = ray.direction.y &lt; 0;</span><br><span class="line">    dirIsNeg[2] = ray.direction.z &lt; 0;</span><br><span class="line"></span><br><span class="line">    if(node-&gt;bounds.IntersectP(ray, invdir, dirIsNeg) == false)</span><br><span class="line">    &#123;</span><br><span class="line">        return inter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return node-&gt;object-&gt;getIntersection(ray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intersection hit_left = getIntersection(node-&gt;left, ray);</span><br><span class="line">    Intersection hit_right = getIntersection(node-&gt;right, ray);</span><br><span class="line"></span><br><span class="line">    if(hit_left.distance &lt; hit_right.distance)</span><br><span class="line">        return hit_left;</span><br><span class="line">    else</span><br><span class="line">        return hit_right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个递归的函数，遍历的方式是对一棵链式存储的二叉树进行遍历，访问函数就是调用前面编写的求box交点函数IntersectP，该函数需要的参数都在前面计算了，如果该结点是一个叶子结点，而且光线与这个叶子结点代表的包围盒相交了，那么就应该再与叶子结点存储的物体求交点，这里调用了一个同名的方法。</p>
<p>要注意的是，最后要返回一个求交结果的结构体，根据递归光线追踪的原理，每次光线投射时找到最近的那个交点即可，所以在所有这些子树返回的结果中，应该找到t值最小的那个交点的结构体，因此在返回的时候加上一个判断条件，将最近的交点返回。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/2022/09/10/games6/9.jpg" alt="场景"></p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>games101</category>
      </categories>
      <tags>
        <tag>gmaes101</tag>
        <tag>Computer Graphics</tag>
        <tag>Rsterization</tag>
      </tags>
  </entry>
  <entry>
    <title>games101系列(7) 路径追踪</title>
    <url>/2022/09/11/games7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>光线追踪的效果很不错，但是有一个细节上的假设，光线在到达光滑物体点上的时候，总是发生反射或折射(或者一起发生)；但是如果物体材质是漫反射材质，那么光线就不再进行反射和折射。这其实是错误的做法，在Phong光照反射模型中，漫反射也是一种光，现在我们要通过更科学的方式解释这种现象，也就是通过辐射度量学推导出的渲染方程，并且还将介绍应用渲染方程的高级光线追踪——路径追踪算法。<br><span id="more"></span></p>
<h1 id="光线追踪的问题"><a href="#光线追踪的问题" class="headerlink" title="光线追踪的问题"></a>光线追踪的问题</h1><p>重新看作业5的框架代码，你会发现我们之前确实是这样做的，对一条光线进行投射的时候，根据达到的点的材质进行不同的递归，如果反射和折射同时发生，那么同时对这两种光线进行递归投射；如果只发生了反射，只对反射光线发生递归；其他所有情况都不进行递归，而是直接计算着色情况并返回，作为递归的退出条件。下面茶壶与康奈尔盒的例子会更直观的指出这个问题：<br><img src="/2022/09/11/games7/1.jpg" alt="场景"><br><img src="/2022/09/11/games7/2.jpg" alt="场景"><br>第一，光线追踪对镜面材质效果是很不错的，但是对于漫反射材质不能很好地处理，例如上面的茶壶，右边的效果使用光线追踪很难得到；<br>第二，康奈尔盒中，左边是限制了直接光照的路径追踪，可以看作是用简单光线追踪得到的结果，光源没有直接照到的地方明显没有了亮度，这显然就是错误的，在这种场景全部是漫反射材质的时候，即使使用光线追踪得到的效果和直接光照的光栅化也没有多大区别，因为这时光线仅仅弹射了一次。</p>
<p>这就是我们需要使用路径追踪的原因，路径追踪可以物理学地正确模拟任何光照结果。</p>
<h1 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h1><h2 id="基本物理量"><a href="#基本物理量" class="headerlink" title="基本物理量"></a>基本物理量</h2><p>辐射度量学是渲染方程的基础，我们只需要掌握基本的定义，然后就能进行方程的推导了，这可能需要一些基本的物理知识。</p>
<p>首先，我们将能量记为Q[J]，中括号中的是单位。同样，定义功率Radiant flux记为能量对时间求导dQ/dt[w][lm]，然后我们再定义下面三个物理量：<br><img src="/2022/09/11/games7/3.jpg" alt="场景"><br>Radiant Intensity，单位立体角上的功率；Irradiance，单位面机上的功率；Radiance，单位立体角到单位面积上的功率。</p>
<p>在Radiant Intensity中(记为I)，关于立体角，就是球体上的一个单位面积除以球半径，可以推导出微分形式的表示，见上图；一个光源的所有功率就是所有立体角上的Radiant Intensity的积分，而且我们计算体积的二重积分时，由于只需要计算半个球体(另外一半可以通过对称得到结果)，所以只积分到PI而不是2*PI。Ω求出的就是球面上的单位立体角之和，那么自然得到Intensity为总功率除以总立体角和。</p>
<p>在Irradiance中(记为E)，要注意这个单位面积也应该和光线方向垂直，所以通过cos计算投影面积。球面面积4ΠR^2，所以对一个球来说Irradiance就是总功率除以总面积，发现只有R这一项是变量，所以前面在Phong光照模型中假设光线能量与距离平方的倒数成反比是正确的。</p>
<p>在Radiance中(记为L)，功率对方位角和单位面积同时微分，得到的就是某个方位角的Radiance到某个单位面积上的能量，与光线的传播就非常相似了。Radiance的物理意义也有两种如图：Incident Radiance和Exiting Radiance，与前面介绍的两种物理量就联系了起来。<br><img src="/2022/09/11/games7/4.jpg" alt="场景"></p>
<h2 id="Bidirectional-Reflectance-Distribution-Function"><a href="#Bidirectional-Reflectance-Distribution-Function" class="headerlink" title="Bidirectional Reflectance Distribution Function"></a>Bidirectional Reflectance Distribution Function</h2><p>双向反射分布函数是一种用来决定材质的量，可以用之前的几种物理量推导，表示的就是反射光的如何进行反射。<br><img src="/2022/09/11/games7/5.jpg" alt="场景"><br>光线能量照到某个点上，可以用Irradiance表示，因为不管哪个方向的能量都算到这个点上；但是反射出去的时候应该是一个Exiting Radiance。我们将两个能量的比值定义出来，这就是BRDF，所以它其实不算一个函数，而是一种比例，确定有多少能量会被反射出去。<br><img src="/2022/09/11/games7/6.jpg" alt="场景"><br>这样，就可以建立一个反射方程了，还是以半球为基准，对Irradiance进行积分得到Exiting Radiance，而且可以定义入射光线和法线的夹角θi以及反射光线和法线的夹角θr，从而具体确定不同物体的反射方式。</p>
<h1 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h1><p>通过上面的反射方程，现在要推导出渲染方程。首先要解决的问题是在光线渲染的过程中，第一次光线从光源弹射到物体表面求反射光线，决定于输入的光线是什么，但是输入的光线并不仅仅是光源的光线，还有其他物体可能发射到这个点上，除非限制光线只弹射一次。</p>
<p>现在，先对反射方程处理以下，加上之前没有的自发光项Emission：<br><img src="/2022/09/11/games7/7.jpg" alt="场景"><br>这就是渲染方程，之前的问题影响的就是如何解出渲染方程，但是此时渲染方程的形式是没有问题的，还将反射方程中的cos值换成两个向量的点积。下面通过费雷德霍姆积分方程得到式1，再进一步转化为线性算子方程，得到式2，两边有相同的L，也就是Radiance。<br><img src="/2022/09/11/games7/8.jpg" alt="场景"><br><img src="/2022/09/11/games7/9.jpg" alt="场景"><br>合并L后，通过二项式定理得到最终形式。<br><img src="/2022/09/11/games7/10.jpg" alt="场景"><br>现在可以根据其统一的形式分析其物理意义了，K可以视作反射操作符，一个场景的反射光线由光源的发光E，以及经过K次反射后的E的能量，K操作一次时就是直接光照的结果，K操作两次即两次以上就是间接光照的结果，这三种能量就构成了全局光照。光栅化能模拟的，就是K至多操作一次的情况。</p>
<h1 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h1><p>在渲染方程中，K算子含有积分运算，我们采用方便的蒙特卡洛积分来求解。蒙特卡洛积分可以看作通过多此采样得到的函数平均值进行积分，或者说对所有可能的函数值求平均。<br><img src="/2022/09/11/games7/11.jpg" alt="场景"><br>其中，H(x)是f(x)的积分，P是x的概率密度函数，g是f对P的期望值。如果P是常数，表面x所有值出现的概率相同。H(x)的期望就是对g的积分，通过对g的积分由式1可以推出，所以g再除以P就得到了H(x)的期望。可以理解成除以P进行一个概率上的平均。</p>
<p>而对于这个变量的概率密度函数，也有很多取法，例如取常数等等，会造成不同的结果。</p>
<h1 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h1><p>现在，通过蒙特卡洛积分和渲染方程的解法，可以试着编写路径追踪的算法了。这是一个递归的shader，决定光线Li从wi入射时到p点时，反射到wo立体角上光线有多少能量。</p>
<h2 id="积分方法解渲染方程"><a href="#积分方法解渲染方程" class="headerlink" title="积分方法解渲染方程"></a>积分方法解渲染方程</h2><p>根据之前的知识，渲染方程中的L积分可以写成下面这样：<br><img src="/2022/09/11/games7/12.jpg" alt="场景"><br>其中，概率密度函数我们这里先选择均匀采样，因为积分是对立体角的积分，所以均匀采样得到的就是半球上的总面积除以半径平方，然后取倒数，也就是1/2Π。</p>
<h2 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h2><p>如果还是按照光线追踪一样，递归光照结果作为新的光源重新计算：<br><img src="/2022/09/11/games7/13.jpg" alt="场景"><br>此时遇到第一个问题，这样会导致计算量太大，因为不同方向的反射光线会各自得到新的许多不同方向的反射光线，是幂函数的复杂度。<br><img src="/2022/09/11/games7/14.jpg" alt="场景"><br>所以每次选择只取一个方向进行模拟，并且取足够多的方向求平均值，像下面这样。<br><img src="/2022/09/11/games7/15.jpg" alt="场景"><br>当然这样会导致得到的结果很不准确，因为采样太少了，所以我们在更外层进行更多次的路径追踪即可，也就是对每个像素取不同的方向进行模拟，得到每个像素的颜色就不会有问题了。<br><img src="/2022/09/11/games7/16.jpg" alt="场景"></p>
<p>第二个问题，在实际上，由于光线满足能量守恒，所以其实是一直在不断弹射的，但是我们现在必须要让光线能够停下，也就是没有递归停止的条件，所以采用轮盘赌的方法决定光线是否停下，如果光线停下了就返回0即可。<br><img src="/2022/09/11/games7/17.jpg" alt="场景"><br>P_RP是取到当前方向的概率，所以同样要作为概率密度除去。这是一个正确的路径追踪算法的伪代码。</p>
<h2 id="优化采样"><a href="#优化采样" class="headerlink" title="优化采样"></a>优化采样</h2><p>现在得到的算法虽然正确，但是太慢了，原因是我们让打到光源的光线直接返回累计的结果这是能看到的光线；其他光线则一直弹射直到轮盘赌让他停止，如果还没有打到光线，那就只能返回0。所以导致如果对每个像素取样频率(Samples per pixel)不高，会造成很多黑点。<br><img src="/2022/09/11/games7/18.jpg" alt="场景"><br>也就是说，如果对半球进行均匀采样，会有很多路径不会打到光源，计算这些路径是无效的，所以我们必须改变采样频率，进一步分析哪些立体角上的光线会打到光源。</p>
<p>现在假设光源总面积为A，取微分dA，只要找到dA对应哪些立体角dW，就可以知道哪些立体角是需要计算的了。根据立体角的定义，可以找到这个关系。<br><img src="/2022/09/11/games7/19.jpg" alt="场景"><br>这样，对立体角积分就变成了对光源面积的积分，我们在光源上均匀采样是没有任何问题的，只不过将这个采样变换到立体角上和之前是不同的。<br><img src="/2022/09/11/games7/20.jpg" alt="场景"><br>这是对光源的贡献的计算，就是直接光照；非光源贡献的计算和前面相同，就是间接光照。<br><img src="/2022/09/11/games7/21.jpg" alt="场景"><br>最终得到优化后的路径追踪算法。也就是说，我们对一个点的着色进行计算的时候，先看光源能不能直接照到这个点，这就是直接光照；然后选择反射方向再次追踪反射光线，如果反射光线又打到另一个非光源物体上，就可以开始递归了，直到光线什么都没打到或者打到了光源，已经因为轮盘赌概率停止。</p>
<p>当然，路径追踪仍然有很多地方可以进一步优化，对不同的场景也应该有不同的方法，入门以后可以继续学习。</p>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>这将是本系列最后一个作业，课程后面的内容有机会再更新，因为后面是对材质(BRDF)先进研究的介绍，成像原理的科普，最后还有动画模拟，这部分内容也很多，但是基本的渲染方法我们已经了解了，作为本科学习来说，已经足够，但是GAMES101的课程还是偏理论，作为入门了解是够了，但是代码学习仍然重要。</p>
<p>作业7就是实现路径追踪算法，沿用了前面作业的一些函数。伪代码在作业说明中更详细地给出了，符合框架，照着编写理解即可。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vector3f Scene::castRay(const Ray &amp;ray, int depth) const</span><br><span class="line">&#123;</span><br><span class="line">    Vector3f L_dir, L_indir;</span><br><span class="line">    // TODO Implement Path Tracing Algorithm here</span><br><span class="line">    // ray and scene intersect at p</span><br><span class="line">    //找到交点p</span><br><span class="line">    Intersection inter_p = intersect(ray);</span><br><span class="line">    //如果没有交点，返回空值</span><br><span class="line">    if (!inter_p.happened)</span><br><span class="line">    &#123;</span><br><span class="line">        return Vector3f();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果打到光源，返回光源的能量，点亮光源</span><br><span class="line">    if (inter_p.m-&gt;hasEmission())</span><br><span class="line">    &#123;</span><br><span class="line">        return inter_p.m-&gt;getEmission();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打到物体上</span><br><span class="line"></span><br><span class="line">    //交点p坐标</span><br><span class="line">    Vector3f&amp; p = inter_p.coords;</span><br><span class="line">    //交点p法线</span><br><span class="line">    Vector3f&amp; N = inter_p.normal;</span><br><span class="line">    //交点到光线起始位置的单位向量</span><br><span class="line">    Vector3f wo = (ray.origin - p).normalized();</span><br><span class="line">    //交点材质</span><br><span class="line">    Material* m = inter_p.m;</span><br><span class="line"></span><br><span class="line">    Intersection inter;</span><br><span class="line">    float pdf_light;</span><br><span class="line">    //对光源采样</span><br><span class="line">    sampleLight(inter, pdf_light);</span><br><span class="line">    // Get x, ws, NN, emit from inter</span><br><span class="line">    //光源坐标</span><br><span class="line">    Vector3f&amp; x = inter.coords;</span><br><span class="line">    //光源法线</span><br><span class="line">    Vector3f&amp; NN = inter.normal;</span><br><span class="line">    //光源能量</span><br><span class="line">    Vector3f&amp; emit = inter.emit;</span><br><span class="line">    //交点到光源的单位向量</span><br><span class="line">    Vector3f ws = (x - p).normalized();</span><br><span class="line">    //交点到光源的距离</span><br><span class="line">    float d = (x - p).norm();</span><br><span class="line"></span><br><span class="line">    // Shoot a ray from p to x</span><br><span class="line">    //计算直接光照</span><br><span class="line">    //从交点发射一条光线到光源</span><br><span class="line">    Ray r(p, ws);</span><br><span class="line">    //光线r最近交点在i中</span><br><span class="line">    Intersection i = intersect(r);</span><br><span class="line"></span><br><span class="line">    //如果这条光线没有被阻挡，那么i记录的distance应该等于d，为了判断相等，我们</span><br><span class="line">    //做差后将两个值的误差控制在绝对值0.001内，这个误差越小越可能导致横条出现</span><br><span class="line">    if (i.distance - d &gt; -0.001)</span><br><span class="line">    &#123;</span><br><span class="line">        L_dir = emit * m-&gt;eval(wo, ws, N) * dotProduct(ws, N) * </span><br><span class="line">            dotProduct(-ws, NN) / (d * d * pdf_light);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果有阻挡当然直接光照的贡献为0</span><br><span class="line"></span><br><span class="line">    //计算间接光照</span><br><span class="line">    float f = get_random_float();</span><br><span class="line">    //轮盘赌</span><br><span class="line">    if (f &lt; RussianRoulette)</span><br><span class="line">    &#123;</span><br><span class="line">        //反射方向</span><br><span class="line">        Vector3f wi = m-&gt;sample(wo, N).normalized();</span><br><span class="line">        //追踪反射方向的光线</span><br><span class="line">        Ray r(p, wi);</span><br><span class="line">        Intersection i = intersect(r);</span><br><span class="line">        //打到物体上</span><br><span class="line">        if (i.happened &amp;&amp; !i.m-&gt;hasEmission())</span><br><span class="line">        &#123;</span><br><span class="line">            //递归开始</span><br><span class="line">            L_indir = castRay(r, depth + 1) * m-&gt;eval(wo, wi, N) *</span><br><span class="line">                dotProduct(wi, N) / m-&gt;pdf(wo, wi, N) / RussianRoulette;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return L_dir + L_indir;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>代码注释详细写了算法具体过程。可以看到，除了后面实现的伪代码部分，前面还有一部分没有提到，我们让光线没有交点时不返回值，打到光源时返回光源的能量，这就是作业说明中最后光源全黑的原因，因为伪代码中并没有处理打到光源的光线。另外，作业说明中还提到pdf接近0的时候会导致噪点过多，采样光源时光线被挡会出现黑色横向条纹，在代码中对第二个问题进行了处理。代码来自<a href="https://blog.csdn.net/weixin_42489848/article/details/125548847">博客</a>，里面讲的很清楚。<br><img src="/2022/09/11/games7/23.jpg" alt="场景"><br><img src="/2022/09/11/games7/22.jpg" alt="场景"></p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>games101</category>
      </categories>
      <tags>
        <tag>gmaes101</tag>
        <tag>Computer Graphics</tag>
        <tag>Rsterization</tag>
      </tags>
  </entry>
  <entry>
    <title>games101系列(5) 光线追踪</title>
    <url>/2022/09/08/games5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的课程和作业中，我们熟悉了一套完整的光栅化过程，然后学习了一些典型的几何表示，现在来到课程的第三个部分，光线追踪。从渲染的角度来说，光栅化和光线追踪是两种不同的着色方式，前者通过光照模型对片段进行投影，然后得到片段颜色，是从物体颜色的计算再到像素；后者虽然是光照模型，但是完全改变了着色方法，从像素出发，模仿光线的传播，完整地计算片段经过光线折射、投射后得到的结果。<br><span id="more"></span><br>下面，我们简单介绍一下两种方法的优缺点，然后进入光线追踪的学习。</p>
<h1 id="光栅化与光线追踪"><a href="#光栅化与光线追踪" class="headerlink" title="光栅化与光线追踪"></a>光栅化与光线追踪</h1><h2 id="光栅化总结"><a href="#光栅化总结" class="headerlink" title="光栅化总结"></a>光栅化总结</h2><p>光栅化计算比较简单，将物体投影到屏幕上进行内外判断，决定片段颜色。</p>
<p>另外，光栅化做阴影的方法也有，就是Shadow Map，原理就是一个点如果不在阴影中，那么应该是从光源和摄像机视角都能看见的。具体做法是，从光源打光线到场景物体，得到一个含有每个像素的深度信息的Shadow Map，然后再从摄像机打光线到整个场景，这次计算每个像素(或片段)与光源的距离(转化到之前空间中，其实反过来也可以)作为深度值，然后映射(可能走样)找到Shadow Map中记录的值进行比较，如果这两个值相同，就说明该像素没有在阴影中；否则像素就在阴影中。<br><img src="/2022/09/08/games5/1.jpg" alt="场景"><br>上面ZA就是光源记录的深度值，ZB是摄像机记录后，转换到光源空间中的值，ZB大于ZA表示ZB离光源更远，所以该点是光源不可见的，在阴影中。</p>
<p>这样，光栅化的基本方法就都介绍完了，最大的优点就是计算快，所以可以轻松做到实时计算，并且也有不错的效果。但是光栅化由于模型都是假设得到的，缺乏实际理论，导致光栅化的结果也很简单，一个是阴影是硬阴影，再一个是只模拟了局部光照，并没有光线多次反射的间接光照效果，也就是全局光照。</p>
<h2 id="光线追踪优缺点"><a href="#光线追踪优缺点" class="headerlink" title="光线追踪优缺点"></a>光线追踪优缺点</h2><p>光线追踪的做法就跟名字一样，基本按照光学原理在场景中计算光线的弹射，模拟全局光照效果。优点当然是对全局光照效果的精确模拟，缺点也很明显，光线的多此计算是非常耗费计算量的，所以光线追踪不容易实时应用。</p>
<h1 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h1><h2 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h2><p>要模拟光线传播，首先要定义光线的性质。在光线追踪中，光线就用射线表示，做如下假设：</p>
<ul>
<li>光线沿直线传播；</li>
<li>光线之间不会发生碰撞；</li>
<li>光线从光源出发，经过反射、折射得到摄像机，并且这个过程可逆。</li>
</ul>
<h2 id="光线投射-Ray-Casting"><a href="#光线投射-Ray-Casting" class="headerlink" title="光线投射 Ray Casting"></a>光线投射 Ray Casting</h2><p>这个模型是80年代提出的，可以称为光线追踪的基本过程。先说一下基本的做法：</p>
<ul>
<li>从摄像机出发，每个像素投射一根光线出去；</li>
<li>用投射的光线寻找光源，从而判断阴影。<br>也就是说，由于光线具有可逆性，所以从光源出发和从相机出发等效，从相机出发达到一个物体，这个物体就是相机可见；进一步，如果这个光线最终达到了光源，那么这个光源就不在阴影中，这样的一条光路包含的能量，就可以用来计算一个像素的颜色。现在，可以明确光线追踪的做法细节了。</li>
</ul>
<h2 id="针孔相机模型-Pinhold-Camera-Model"><a href="#针孔相机模型-Pinhold-Camera-Model" class="headerlink" title="针孔相机模型 Pinhold Camera Model"></a>针孔相机模型 Pinhold Camera Model</h2><p><img src="/2022/09/08/games5/2.jpg" alt="场景"></p>
<p>从观察点出发，对每个像素都进行光线投射，每根光线进行上面的操作：光线沿着光路找到第一个相交的物体点，对这个物体点找到法线进行着色计算(例如使用Phong光照模型)，而且还要通过这个点能否达到光源(与光源是否有遮挡物，反过来看就是光线从光源出发没有到观察点)判断点是否在阴影中，然后综合阴影和着色结果，写入光线发出的像素中。</p>
<h2 id="Witted-Style-Ray-Tracing-Recursive"><a href="#Witted-Style-Ray-Tracing-Recursive" class="headerlink" title="Witted-Style Ray Tracing (Recursive)"></a>Witted-Style Ray Tracing (Recursive)</h2><p>很显然，上面的模型虽然是通过光线进行追踪，但是仍然没有考虑光线弹射，所以得到的结果还是局部的光照。考虑通过递归的方式处理任何一根光线，如果光线发生了折射或者反射，那么以这个点为出发点重新计算光线的投射，这才是完整的光线追踪。<br><img src="/2022/09/08/games5/3.jpg" alt="场景"><br>仍然从观察点出发，对每个像素投射光线，光线找到最近的相交点，并且考虑反射和折射光线(统称为Secondary Ray)，如果发生了反射折射，就对反射折射光线进行递归；如果不发生(例如遇到漫反射材质)，则停止追踪这条光线，对这个不发生发射折射的点使用其他光照模型得到着色结果，并返回颜色，最终在递归中汇聚所有值，平均到出发的像素中。   </p>
<h3 id="光线求交点"><a href="#光线求交点" class="headerlink" title="光线求交点"></a>光线求交点</h3><p>现在，给光线一个完整的数学定义：<br><img src="/2022/09/08/games5/4.jpg" alt="场景"></p>
<h4 id="隐式表示的物体"><a href="#隐式表示的物体" class="headerlink" title="隐式表示的物体"></a>隐式表示的物体</h4><p>然后，先考虑二维中光线与球相交的情况，球可以用隐式的公式表示，所以把两个方程联列求解：<br><img src="/2022/09/08/games5/5.jpg" alt="场景"><br>所以，可以使用相同的方法对三维中所有隐式表示f(p)=0，p点如果也可以用光线的方程表示，那么p就是交点。</p>
<h4 id="显式表示的物体"><a href="#显式表示的物体" class="headerlink" title="显式表示的物体"></a>显式表示的物体</h4><p>显式表示的物体确定了点的坐标，其实也就确定了许多的三角形面，光线追踪中，我们先看光线与面的交点，再这个交点是否在面上的三角形内，如果两者都满足，才能确定一个交点。</p>
<h5 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h5><p>与面相交的交点是比较好求的，方便了计算过程。<br><img src="/2022/09/08/games5/6.jpg" alt="场景"><br>其实也是隐式求交的方法，只不过是平面的函数表示。P点是平面上的点，P’是等待判断的点，如果P’在平面上，那么他和P点连成的向量应该和法线N垂直。最后解出t的表示如上，如果t是非负实数，说明这个点存在，带入光线的定义得到点坐标。</p>
<p>求出点的坐标后就是判断三角形内外了，采用前面的向量叉乘法，就可以得到判断结果。</p>
<h6 id="Moller-Trumbore-Algorithm"><a href="#Moller-Trumbore-Algorithm" class="headerlink" title="Moller Trumbore Algorithm"></a>Moller Trumbore Algorithm</h6><p>这里介绍一种更快的方法，利用重心坐标的性质求解。<br><img src="/2022/09/08/games5/7.jpg" alt="场景"><br>右边三个P向量表示三角形的三个顶点(不是向量)，如果点在三角形内部，那么重心坐标的三个权重应该在[0,1]之间，秩为3的矩阵求解三个未知数，通过克莱默法则得到下面的解形式：<br><img src="/2022/09/08/games5/8.jpg" alt="场景"></p>
<p>好了，现在知道了如何求交点，完成作业5以后，再进一步学习光线追踪。</p>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>本次作业还是使用了新的框架，要求写的内容就是上面求交点的算法，还有最简单的光线追踪算法。首先我们分析光线追踪算法的具体实现。</p>
<h2 id="光线追踪算法部分"><a href="#光线追踪算法部分" class="headerlink" title="光线追踪算法部分"></a>光线追踪算法部分</h2><p>作业要求为每一个像素生成一条对应的光线，调用castRay()函数得到颜色，并存储在帧缓冲区的相应像素中。阅读框架发现，实际上要做的只是求屏幕空间的像素对应到世界中的坐标，也就是说，这和之前光栅化之前的步骤都相同，而且已经得到了屏幕坐标系(NCD)中的像素坐标了。但是现在使用了不同的渲染方式，从像素出发，所以要重新计算片段原本在世界系中的位置，方便投射光线。<br><img src="/2022/09/08/games5/11.jpg" alt="场景"><br>那么分析一下这些坐标的变换情况如下，世界坐标系中的原始坐标P0，经过透视投影压缩到[-1,1]的范围中，这是P1，这一步中定义了fov角和横纵比ratio，然后投射到屏幕上得到P2，范围是[0,+inf]。所以现在反过来已知P2求P0，首先要将P2重新压缩到[-1,1]上，对X坐标应该先除以屏幕宽度width，然后乘以2，减去1；Y坐标和X的计算相反，因为屏幕坐标系中Y正方向向下，所以我们是用负的Y坐标除以屏幕高度，乘以二然后加上1。<br><img src="/2022/09/08/games5/10.jpg" alt="场景"></p>
<p>得到P1后，分析透视投影的fov角，tan(fov/2)=高宽/Z值，这实际上就是直接对XY坐标的缩放，所以框架给出了scale这个值放大坐标。最后，这样得到的XY坐标实际上是相等的，因为还有一个宽高比没有用，宽高比就是宽度是高度的多少倍，所以把X坐标乘以这个宽高比，就得到了原始的X坐标，Y坐标不用乘，这就是P0。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Renderer::Render(const Scene&amp; scene)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;Vector3f&gt; framebuffer(scene.width * scene.height);</span><br><span class="line"></span><br><span class="line">    float scale = std::tan(deg2rad(scene.fov * 0.5f));</span><br><span class="line">    float imageAspectRatio = scene.width / (float)scene.height;</span><br><span class="line"></span><br><span class="line">    // Use this variable as the eye position to start your rays.</span><br><span class="line">    Vector3f eye_pos(0);</span><br><span class="line">    int m = 0;</span><br><span class="line">    for (int j = 0; j &lt; scene.height; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; scene.width; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            // generate primary ray direction</span><br><span class="line">            //(i+0.5,j+0.5)才是像素在屏幕上的位置，而且因为屏幕以左上角作为原点，</span><br><span class="line">            //导致y轴坐标向下为正方向，所以实际上y的计算和x相反</span><br><span class="line">            float x = (2 * (i + 0.5) / scene.width - 1) * imageAspectRatio * scale;</span><br><span class="line">            float y = (1 - 2 * (j + 0.5) / scene.height) * scale;</span><br><span class="line">            // TODO: Find the x and y positions of the current pixel to get the direction</span><br><span class="line">            // vector that passes through it.</span><br><span class="line">            // Also, don&#x27;t forget to multiply both of them with the variable *scale*, and</span><br><span class="line">            // x (horizontal) variable with the *imageAspectRatio*            </span><br><span class="line"></span><br><span class="line">            Vector3f dir = normalize(Vector3f(x, y, -1)); // Don&#x27;t forget to normalize this direction!</span><br><span class="line">            framebuffer[m++] = castRay(eye_pos, dir, scene, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        UpdateProgress(j / (float)scene.height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // save framebuffer to file</span><br><span class="line">    FILE* fp = fopen(&quot;binary.ppm&quot;, &quot;wb&quot;);</span><br><span class="line">    (void)fprintf(fp, &quot;P6\n%d %d\n255\n&quot;, scene.width, scene.height);</span><br><span class="line">    for (auto i = 0; i &lt; scene.height * scene.width; ++i) &#123;</span><br><span class="line">        static unsigned char color[3];</span><br><span class="line">        color[0] = (char)(255 * clamp(0, 1, framebuffer[i].x));</span><br><span class="line">        color[1] = (char)(255 * clamp(0, 1, framebuffer[i].y));</span><br><span class="line">        color[2] = (char)(255 * clamp(0, 1, framebuffer[i].z));</span><br><span class="line">        fwrite(color, 1, 3, fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>只有中间求x，y那里是需要填写的，其他已经写好，不过记得对dir这个方向向量进行归一化。</p>
<h2 id="三角形求交部分"><a href="#三角形求交部分" class="headerlink" title="三角形求交部分"></a>三角形求交部分</h2><p>这部分就很简单了，按照公式计算即可，向量和点都已经给出。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool rayTriangleIntersect(const Vector3f&amp; v0, const Vector3f&amp; v1, const Vector3f&amp; v2, const Vector3f&amp; orig,</span><br><span class="line">                          const Vector3f&amp; dir, float&amp; tnear, float&amp; u, float&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO: Implement this function that tests whether the triangle</span><br><span class="line">    // that&#x27;s specified bt v0, v1 and v2 intersects with the ray (whose</span><br><span class="line">    // origin is *orig* and direction is *dir*)</span><br><span class="line">    // Also don&#x27;t forget to update tnear, u and v.</span><br><span class="line">    //按照克莱默法则得到的解形式计算就行了</span><br><span class="line">    Vector3f E1 = v1 - v0;</span><br><span class="line">    Vector3f E2 = v2 - v0;</span><br><span class="line">    Vector3f S = orig - v0;</span><br><span class="line">    Vector3f S1 = crossProduct(dir, E2);</span><br><span class="line">    Vector3f S2 = crossProduct(S, E1);</span><br><span class="line">    tnear = dotProduct(S2, E2) / dotProduct(S1, E1);</span><br><span class="line">    u = dotProduct(S1, S) / dotProduct(S1, E1);</span><br><span class="line">    v = dotProduct(S2, dir) / dotProduct(S1, E1);</span><br><span class="line">    if (tnear &gt;= 0 &amp;&amp; u &gt;= 0 &amp;&amp; v &gt;= 0 &amp;&amp; (1 - u - v) &gt;= 0)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里都是引用形式，所以直接修改变量名即可。如果解出的三个值都满足条件，t非负，重心坐标的三个权重都在0和1之间，那么点就在三角形内部。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/2022/09/08/games5/9.jpg" alt="场景"></p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>games101</category>
      </categories>
      <tags>
        <tag>gmaes101</tag>
        <tag>Computer Graphics</tag>
        <tag>Rsterization</tag>
      </tags>
  </entry>
  <entry>
    <title>图嵌入和图神经网络</title>
    <url>/2022/07/22/graph-embedding/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>图作为重要的数据结构，可以表示物体与物体之间的关系，这里总结一下图的深度学习中经常提到的图嵌入（图表示学习/Network Embedding/Graph Embedding）和图神经网络（GNN）。<br><span id="more"></span><br>图嵌入和图神经网络是有交集的两个研究领域，并且密切相关。其中图神经网络是随深度学习发展提出的用于处理图数据的神经网络结构，而图嵌入旨在将图的节点表示成低维向量空间，同时保留图的拓扑结构和节点信息，便于用简单的机器学习算法处理。图神经网络又同时可以支持图嵌入的工作，即图嵌入的深度学习方法。  </p>
<p>本文中会介绍图嵌入的常见算法，以及图神经网络的结构。</p>
<h1 id="图嵌入"><a href="#图嵌入" class="headerlink" title="图嵌入"></a>图嵌入</h1><p>在研究社交网络这样比较稀疏的图时，如果直接使用邻接矩阵花费|<em>V</em>|<em>|</em>V*|的存储空间，显然会造成浪费，数据的稀疏使得邻接矩阵的信息很难得到利用。</p>
<p>因此图嵌入用来学习得到网络中节点的低维向量表示，即图嵌入对每个节点<em>v</em>进行学习，得到一个向量<em>R</em>，然后提供给其他方法对数据进行处理。</p>
<p>一般图嵌入的方法可以大致分为三类，(1)Matrix Factorization，(2)Random Walk，(3)Deep Learning。这里着重写一下基于第二种方法的Node2vec算法。</p>
<h2 id="Matrix-Factorization-矩阵分解"><a href="#Matrix-Factorization-矩阵分解" class="headerlink" title="Matrix Factorization 矩阵分解"></a>Matrix Factorization 矩阵分解</h2><p>通过矩阵分解的方式得到每个结点的低维向量表示。</p>
<h2 id="Random-Walk-随机游走"><a href="#Random-Walk-随机游走" class="headerlink" title="Random Walk 随机游走"></a>Random Walk 随机游走</h2><p>这种方法通过在图上的短距离游走，使得共现的节点具有相似的表示方式，从而优化节点的嵌入。</p>
<h3 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h3><p>该算法作为评价互联网网页重要性的算法，对每个代表一个网页的结点给出一个正实数值，作为排序的依据。这实际上是通过在图上定义一阶的马尔可夫链实现的，因为马尔可夫链的状态转移矩阵具有很好的性质，可以找到一个平稳的分布，平稳分布的概率值就是网页的排序依据。<br>以下图为例，在PageRank中假设一个点转移到与他相邻的结点的概率相等，也就是说一个点转移到任何一个邻居的概率都是这个结点的度的倒数。因此结点j到邻居结点i的概率为1/n，n为i的度；如果一个结点没有出度，那么这个结点的转移概率为0。通过这样的方式定义一个状态转移矩阵M，M[i][j]代表结点j转移到结点i的概率，举例如下：<br><img src="/2022/07/22/graph-embedding/4.jpg" alt="场景"><br><img src="/2022/07/22/graph-embedding/5.jpg" alt="场景"><br>在t时刻每个结点的概率分布用一个列向量R表示，那么R的更新如下：<br><img src="/2022/07/22/graph-embedding/6.jpg" alt="场景"><br>当达到平稳分布R的时候，R满足MR=R，这个平稳分布R就是PageRank的值。这就是PageRank的基本定义，但是其实这样的马尔可夫链不一定具有平稳分布，根据定理有强连通且非周期的有向图上定义的随机游走模型，在时间t趋于无穷的时候分布收敛到唯一分布，所以进一步推广。<br>如果导入平滑项，就是PageRank的一般定义了，可以证明得以下形式的马尔可夫链具有唯一分布：<br><img src="/2022/07/22/graph-embedding/7.jpg" alt="场景"><br>其中，阻尼因子d越接近1，越按照转移矩阵进行；越接近0，随机游走越以等概率访问各个结点。1是全1的n维矩阵。这意味着，浏览者以概率d跳转到当前网页连接的其他网页；以概率1-d跳转到完全随机的其他网页(不一定连接到当前网页)，这可以保证平稳分布。</p>
<p>具体计算可以直接按照上式，等R的更新幅度很小，就可以停止迭代了。</p>
<h3 id="DeepWalk"><a href="#DeepWalk" class="headerlink" title="DeepWalk"></a>DeepWalk</h3><h2 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h2><h1 id="图神经网络-GNN"><a href="#图神经网络-GNN" class="headerlink" title="图神经网络(GNN)"></a>图神经网络(GNN)</h1><p>前面说到，深度学习在发展中才提出了GNN，那是什么导致GNN的出现和发展呢？答案是图这种结构的特殊性。不同于规整的图像等数据，一个图的结构往往是不规则的，并且不同节点之间还有关联，使得以往的深度学习方法没办法很好地用到图上，因此图神经网络应运而生。<a href="https://blog.csdn.net/qq_44186838/article/details/109378474?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166323184816782395396213%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166323184816782395396213&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-109378474-null-null.142^v47^pc_rank_34_default_23,201^v3^control_2&amp;utm_term=GNN&amp;spm=1018.2226.3001.4187">这篇文章</a>很好地解释了GNN的计算过程，方便理解。</p>
<h2 id="一般GNN-GCN"><a href="#一般GNN-GCN" class="headerlink" title="一般GNN(GCN)"></a>一般GNN(GCN)</h2><p>GNN的输入一般是图的邻接矩阵A，以及结点的特征矩阵X。现在我们假设要对样本G进行计算，图G并不存在边特征，是一个无向图，要求进行训练并实现图分类。那么使用最简单的GNN，可以用三层网络结构描述，输入层，隐层，输出层，其中输入我们知道是(A,X)，经过隐层计算后输出，现在看看隐层计算什么以及如何计算。</p>
<p>在图神经网络中，对一个结点的更新定义聚合操作，也就是将这个顶点的邻居的特征向量以某种方式汇聚到这个顶点的特征向量上，方法就是使用邻接矩阵A左乘特征矩阵X，并且X还使用了训练参数W进行调整:Z=AXW，相比原始的神经网络，只不过多加了一个邻接矩阵。</p>
<p>此时有两个问题需要解决，一是这样更新以后结点自身的特征向量被忽略了，因此要为邻接矩阵A中的结点增加自环；二是度越大的结点汇聚的特征越多，导致这个值越大，最好进行归一化避免，将特征平均到每个度上，所以还要将每个结点的特征向量除以结点的度。</p>
<p>现在，就得到了隐层的完整计算，Z=inv(D)A’XW，其中inv(D)表示度对角矩阵的逆，A’表示增加了自环的邻接矩阵，X是结点信息矩阵，W是权重矩阵。每次，通过这样的方式前向，并后向传播使用SGD更新权重参数，最后完成网络的训练。当然，结点更新后生成的仍然是和X相同维度的N*M维的结点特征矩阵，其中N是结点数量，M是结点特征的维度。结合前面的嵌入，自然可以想到结点的嵌入向量实际上就在这里用作特征向量。而在实际的工作中，我们把嵌入的向量(Embeedings)称为隐式特征Implicit Feature，如果数据中结点还带有具体的属性(Attributes)，又把这部分叫做Explicit Feature，可以对这两部分特征都进行更新。</p>
<p>那应该如何从特征向量矩阵得到最后需要的任务目标？用全连接神经网络即可，称为局部输出函数，用这个结果来确定误差并反向传播。而反向传播的过程与一般神经网络也类似，但是因为不动点理论和压缩映射，训练目标不是简单的梯度下降算法，理解上不造成影响。</p>
<p><img src="/2022/07/22/graph-embedding/1.png" alt="场景"></p>
<h2 id="多跳邻居的GNN"><a href="#多跳邻居的GNN" class="headerlink" title="多跳邻居的GNN"></a>多跳邻居的GNN</h2><p>一般的GNN也可以说是采用直接邻居的GNN，在 <em>Representation Learning on Graphs with Jumping Knowledge Networks</em> 一文中，作者将GCN的汇聚范围同Random Walk做对比，说明了GCN的每层网络汇聚就相当于Random Walk多走一步，也就是说一个结点在GNN中进行汇聚，每汇聚一次得到的全局信息就越多。但是这其实有一定缺陷，因为某些结点并不在中心结点的位置，因此它汇聚完成后的特征表示也不应该具有过多的全局信息，而是应该更多保留自身的特征，多层的GNN有可能破坏这样的特征，所以许多人提出了新的方案处理这个问题，本质上就是将每层的信息通过某种方式保留，到训练完成后再选择需要哪层汇聚的信息。</p>
<h3 id="DGCNN"><a href="#DGCNN" class="headerlink" title="DGCNN"></a>DGCNN</h3><p>DGCNN在一般GCN的基础上，加入SrotPooling层依照特征向量对结点进行排序，提取出汇聚信息最多的一部分重要的结点，解决处理图数据时为统一图大小而需要截断邻接矩阵的问题。<br><img src="/2022/07/22/graph-embedding/1.jpg" alt="场景"><br>输入：邻接矩阵A和信息矩阵X；</p>
<p>卷积层：<br><img src="/2022/07/22/graph-embedding/2.jpg" alt="场景"></p>
<p>拼接：将每次Zt的结果按行拼接起来。每行是结点的特征描述，每列是一个通道。<br><img src="/2022/07/22/graph-embedding/3.jpg" alt="场景"></p>
<p>排序池化层：从最后一列往前，降序排列前K个大的顶点信息，并输出K个结点的特征描述矩阵。由于是从后往前排序，所以在这个过程中可以将损失梯度传回到前一层的训练，让前一层的参数可以进行训练。作者说这可以类比WL的颜色排序，得到结点的排序和统一大小的卷积后的信息矩阵。在这一层实现了不同层汇聚信息的选择，作者按照降序排列，且论文中设置的最后一层的通道数为1，也就是说作者选择了汇聚信息最多的重要的k个结点的特征进行后面的处理。</p>
<p>CNNs：<br>将前面得到的矩阵展成一列，也就是将每行拼接起来转置。用一维的CNN训练(为了学习结点的信息维度添加了一些)，结果用全连接层激活进行分类。</p>
<p>贡献：实现了图端到端的分类，处理不规则的图，让CNN能直接应用在图上，并且让结点有一定的顺序让CNN读取，得到更好的结果。作者认为WLNM中为了应用神经网络直接将邻接矩阵截断再训练，可能导致信息丢失，所以通过降序排序池化的方式进行截断，在一定程度上降低了信息的丢失。</p>
<p>作者直接按照每个通道中的大小排序，用WL解释个人感觉比较牵强，实际上就是哪个结点汇聚的更多就提取哪个结点，如果能在卷积或者池化的同时进一步增强这种“重要性”，结果可能会得到提升。后来本人找到一些关于这种思路的论文，为子图赋权或者开发某种衡量结点重要性的指标。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Deep Learning</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Graph Embedding</tag>
        <tag>Graph Neural Network</tag>
      </tags>
  </entry>
  <entry>
    <title>你好！</title>
    <url>/2024/10/05/hello-world/</url>
    <content><![CDATA[<p>这里是ANKIIMA的博客，出于兴趣分享一些学习过程和其他见闻！</p>
<hr>
<span id="more"></span>
<p>联系我：  </p>
<blockquote>
<p><i class="fa-brands fa-github"></i> <a href="https://github.com/ANKIIMA">ANKIIMA</a>  </p>
<p><i class="fa-brands fa-weixin"></i> Aa1667791793</p>
</blockquote>
<p><head> 
    <script defer src="https://use.fontawesome.com/releases/v5.0.13/js/all.js"></script> 
    <script defer src="https://use.fontawesome.com/releases/v5.0.13/js/v4-shims.js"></script> 
</head> </p>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css">

]]></content>
  </entry>
  <entry>
    <title>YOLOv5实现口罩佩戴检测</title>
    <url>/2022/07/04/mask/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章记录通过使用YOLOv5深度学习框架，对口罩佩戴数据集进行训练，并实现实时检测口罩佩戴情况的过程。  不需要您对深度学习有基础，可以直接快速上手。<br><span id="more"></span></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>由于竞赛任务，我需要短时间内实现口罩检测算法，最好能够在电脑摄像头中实时检测口罩佩戴情况。  </p>
<p>在没有人工智能基础的情况下，最好的方式就是使用框架。这里有必要大概介绍一下，如果你完全不了解人工智能，那么可以记住机器学习是人工智能的一个子集，而深度学习就是机器学习中最前沿的方法。其中深度指的就是构建神经网络的深度。  </p>
<p>但是不必担心，我们将直接使用经过改进的YOLO算法，作者将这一算法整理成完整的框架，并提供了合适的接口，只要修改配置文件就可以完成基本任务了。  </p>
<p>当然如果你想对这部分理论进行更深层次的研究，也许这篇文章只能让你大致了解使用框架的过程，而非详尽的数学理论。</p>
<p>本文使用的方法为参考另外两篇博客博客总结出来的，如果过程中有疑问可以移步查看。<br><a href="https://blog.csdn.net/kushe123/article/details/113702225">利用yolov5实现口罩佩戴检测算法(非常详细)</a><br><a href="https://blog.csdn.net/didiaopao/article/details/120022845?spm=1001.2014.3001.5502">目标检测—-数据集格式转化及训练集和验证集划分</a>  </p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>现在，我们先安装YOLOv5框架必要的组件，包括pyhton环境，python包管理工具，YOLOv5项目下载，pyhotn IDE(推荐pycharm)，用于训练数据集的CUDA计算支持和pytorch安装(有必要的话)。<br>这里将以我自己安装的版本为例，如有不同需要确认安装版本是否支持。当然也可以完全根据我的版本来，不容易出错。</p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>如果已经安装了Python环境，可以忽略。在Windows中打开控制台，查看Python版本：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\16677&gt;python -V</span><br><span class="line">Python 3.7.8</span><br></pre></td></tr></table></figure><br>如果显示错误，就应该要重新正确安装python。这部分网上有很多教程了，推荐安装3.7以上版本，一般不会导致严重的问题。使用后面介绍的包管理工具也一样能完成python安装。  </p>
<h2 id="Python包管理工具"><a href="#Python包管理工具" class="headerlink" title="Python包管理工具"></a>Python包管理工具</h2><p>Python有很多功能强大的包提供算法或计算支持，庞杂的包管理通常需要安装包管理工具来解决，一般有两个工具要安装，一个是pip，提供轻量级包管理；另一个是Anaconda，除了包管理以外还提供许多必要的强大功能。  </p>
<p>而这两个工具其实不冲突，网上有关于这部分的介绍，感兴趣可以搜索看看。总而言之，pip和conda都可以安装python包，但是最好使用其中一个进行配置，避免重复安装。(实际上我自己安装的时候感觉环境会自动同步)  </p>
<p>之所以安装两个是因为有时候某个工具安装会出错，因此还是有必要的。</p>
<p>安装都比较简单，按照网上教程就行，使用命令查看是否正确安装：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\16677&gt;pip -V</span><br><span class="line">pip 22.1.2 from d:\program files (x86)\microsoft visual studio\shared\python37_64\lib\site-packages\pip (python 3.7)</span><br><span class="line"></span><br><span class="line">C:\Users\16677&gt;conda -V</span><br><span class="line">conda 4.12.0</span><br></pre></td></tr></table></figure><br>除此之外，安装Ananconda的另一个主要用途是创建虚拟环境，pip需要额外的包才能创建，但conda直接提供了虚拟环境的管理。什么是虚拟环境？因为不同的工程需要不同的python包，如果都安装在源环境中肯定会越来越复杂，导致在你开发分享的时候生成requirements会包含很多不必要的包。而创建虚拟环境就可以避免这个问题，每个虚拟环境都有自己特有的配置，且互不冲突。  </p>
<p>在我们这次配置的时候就可以试着创建一个虚拟环境，再正式安装需要的pyhton包。</p>
<h2 id="YOLOv5项目下载"><a href="#YOLOv5项目下载" class="headerlink" title="YOLOv5项目下载"></a>YOLOv5项目下载</h2><p><a href="https://github.com/ultralytics/yolov5">YOLOv5</a>在GitHub上进行了开源，可以通过git克隆或者直接下载的方式得到整个项目文件包，解压后放到自己选的目录。<br>也许目录和我的会有所不同，因为YOLO也一直在更新，但是不用担心会出错，正确配置文件路径即可。</p>
<h2 id="pycharm安装"><a href="#pycharm安装" class="headerlink" title="pycharm安装"></a>pycharm安装</h2><p>类似VS，pycharm专用于python的开发环境管理，对工程文件不推荐小型编辑器如VSCode。跟着网上教程就可以安装了。</p>
<h2 id="CUDA和pytorch-gpu"><a href="#CUDA和pytorch-gpu" class="headerlink" title="CUDA和pytorch(gpu)"></a>CUDA和pytorch(gpu)</h2><p>前面基本没什么坑，但是这两个要注意一下。</p>
<p>这两个放在一起说，因为gpu版本的pytorch包需要CUDA协助才能工作，安装的时候也要特别注意CUDA版本是否和pytorch版本匹配。</p>
<p>正常来说直接使用pip安装requirements.txt(YOLOv5中的配置要求文件)也可以，当然安装的只是cpu版本的pytorch，计算会相当慢，以我的电脑i5 10200H的CPU根本无法完成训练。如果还是想在自己电脑上跑一次训练，还是有必要使用gpu进行计算。</p>
<p>CUDA是N卡才有的运算平台，可以参考博客<a href="https://blog.csdn.net/qq_42814530/article/details/121716046">cuda安装</a>完成，注意最好先看看pytorch官网提供的CUDA支持版本再回过头来安装CUDA，相同的版本不容易出错。比如我的显卡是GTX1650Ti，支持到cuda11.7，但是我查看pytorch只有10.0和11.3，所以就安装了11.3。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\16677&gt;nvcc -V</span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2021 NVIDIA Corporation</span><br><span class="line">Built on Sun_Mar_21_19:24:09_Pacific_Daylight_Time_2021</span><br><span class="line">Cuda compilation tools, release 11.3, V11.3.58</span><br><span class="line">Build cuda_11.3.r11.3/compiler.29745058_0</span><br></pre></td></tr></table></figure></p>
<p>pytorch是常用机器学习库，官网提供的安装方式就是pip和conda。个人推荐使用pip安装。  </p>
<p>这里有的教程还推荐使用清华源进行下载(国内肯定容易下载失败嘛)，不过可能会出问题，有人说清华源的pytorch就是cpu版本而不是gpu版本，但我安装的时候直接使用pip命令使用清华源就成功了，conda同样用清华镜像也可以通过测试，但是就是不能跑YOLO。所以多次尝试后我就推荐在pip中加入清华镜像源，然后直接用官网命令安装就行了。</p>
<p>查看自己pip源：(不是清华源可以自己找方法添加，如果能正常安装也没必要)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\16677&gt;pip config list</span><br><span class="line">global.cache-dir=&#x27;D:\\组件\\pip-22.1.2\\cache&#x27;</span><br><span class="line">global.index-url=&#x27;https://pypi.tuna.tsinghua.edu.cn/simple&#x27;</span><br></pre></td></tr></table></figure><br><a href="https://pytorch.org/get-started/locally/">pytorch官网</a>命令：(自己看对应什么版本，图片的命令是conda安装，可以在Package一栏选择pip安装命令)<br><img src="/2022/07/04/mask/2.jpg" alt="pytorch官网"><br>正常情况下应该能顺利安装。然后就是测试了，输入conda命令看看版本有没有匹配：(这里已经进入了虚拟环境)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(pytorch-gpu) C:\Users\16677&gt;conda list</span><br><span class="line"># packages in environment at D:\anaconda\envs\pytorch-gpu:</span><br><span class="line">#</span><br><span class="line"># Name                    Version                   Build  Channel</span><br><span class="line">……</span><br><span class="line">torch                     1.12.0+cu113             pypi_0    pypi</span><br><span class="line">torchaudio                0.12.0+cu113             pypi_0    pypi</span><br><span class="line">torchvision               0.13.0+cu113             pypi_0    pypi</span><br></pre></td></tr></table></figure><br>cu113就是CUDA版本支持为11.3，说明应该没有问题，再进一步测试，进入python后导入torch，测试是否可用gpu计算：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\16677&gt;conda activate pytorch-gpu</span><br><span class="line"></span><br><span class="line">(pytorch-gpu) C:\Users\16677&gt;python</span><br><span class="line">Python 3.7.13 (default, Mar 28 2022, 08:03:21) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import torch</span><br><span class="line">&gt;&gt;&gt; print(torch.cuda.is_available())</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; torch.cuda.device_count()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; torch.cuda.get_device_name(0)</span><br><span class="line">&#x27;NVIDIA GeForce GTX 1650 Ti&#x27;</span><br></pre></td></tr></table></figure><br>如果像上面这样显示，一般就没问题了，其实距离完成整个项目也就成功了大半(永远是第一次配环境最麻烦)。</p>
<h1 id="YOLOv5"><a href="#YOLOv5" class="headerlink" title="YOLOv5"></a>YOLOv5</h1><p>用pycharm打开之前下载的YOLO项目，大概是这个样子：<br><img src="/2022/07/04/mask/yolov5.jpg" alt="YOLOv5"><br>VOCdevkit文件夹是后面加上的，其他应该都有，没有也不用担心，只要保证路径正确就不会出问题。<br>现在先熟悉一下项目文件，重点介绍需要使用的文件。</p>
<ul>
<li>data文件夹里面有关于超参数的配置文件，例如分类数，分类名称，是我们需要修改的。</li>
<li>models是关于网络模型的文件夹，YOLOv5在本身算法框架的基础上还诞生了许多特别的网络模型，他们的配置都放在这里，可以进行不同的选择和修改。</li>
<li>runs是结果，包括训练过程的记录和测试结果，也就是最后在这里查看效果。</li>
<li>utils是工具函数，不用修改。</li>
<li>weights是训练完成的权重(如果你了解神经网络就知道是什么)。</li>
<li>detect.py是测试脚本，可以使用训练完成的权重对图片进行测试验证，结果就生成到runs中。</li>
<li>train.py是训练数据集的脚本，训练完成后就可以用detect测试效果了。</li>
<li>requirements.txt是环境配置要求，使用pip对这个文件包含的所有包进行安装，就可以正常运行YOLO了。</li>
</ul>
<p>有所了解以后，先试试能不能跑YOLO。在pycharm右下角添加配置好的虚拟环境解释器(不做详细介绍，可以百度解决)，然后在终端中测试：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS D:\各种文件\项目\口罩检测\yolov5-5.0&gt; python detect.py</span><br></pre></td></tr></table></figure><br>如果没有报错，那么会先下载最新的权重(一个pt文件，我们最后要的权重也是这种文件)，最后显示结果的保存位置(runs/detect/exp)，然后查看结果，应该有两张识别好的图片，检测人物和领带，我们最后得到的识别结果也是这个形式。</p>
<p>YOLOv5除了这些简单介绍实际上有很多原理需要了解，本文只介绍配置方法。</p>
<h1 id="数据集准备"><a href="#数据集准备" class="headerlink" title="数据集准备"></a>数据集准备</h1><p>训练权重之前首先要准备数据集。数据集包含两部分，一是口罩佩戴的图片，而是图片对应的标签。一般来说数据集要自己准备，先找图片，找到足够多的图片了再用某种方式制作标签(例如labelimg)，参考这篇博客教程：<a href="https://blog.csdn.net/didiaopao/article/details/119808973?spm=1001.2014.3001.5501">目标检测—-利用labelimg制作自己的深度学习目标检测数据集</a>。</p>
<p>这里可以直接使用另一位博主标注好的文件：<a href="https://blog.csdn.net/kushe123/article/details/113702225">利用yolov5实现口罩佩戴检测算法(非常详细)</a>这篇文章中有数据集链接，没有找到可以联系我。</p>
<p>数据标注有三种格式，分别是YOLO标签格式用的txt文件，VOC标签格式用的xml文件，createML标签格式用的json格式。标注完成后要将数据分成训练集和测试机，这里用的数据集已经标注成txt格式了，但是根据这两篇博客中提到的，直接根据txt数据集进行分类不好，训练的时候加载数据会出问题，所以先把标注好的txt转化为xml格式，再根据xml标签进行分类，并最终保存为txt文件。</p>
<p>我使用的代码也来自这篇博客：<a href="https://blog.csdn.net/didiaopao/article/details/120022845?spm=1001.2014.3001.5502">目标检测—-数据集格式转化及训练集和验证集划分</a>，里面介绍了整个的方法，简单来说就是先将txt转化成xml，然后直接将xml划分并保存为txt格式的数据集。这里主要是要注意文件层级，要将这个py文件和数据集文件(也就是VOCdevkit)放在一级，不放也行，但是要注意相对路径和绝对路径写法，该文件夹包含自己新建的VOC2007文件夹，文件夹内还有三个文件如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picPath = &quot;VOCdevkit/VOC2007/JPEGImages/&quot;  </span><br><span class="line">txtPath = &quot;VOCdevkit/VOC2007/YOLO/&quot;  </span><br><span class="line">xmlPath = &quot;VOCdevkit/VOC2007/Annotations/&quot;  </span><br></pre></td></tr></table></figure><br>YOLO是txt标签，将下载的数据集里面的标签txt文件移动到这里；JPEGImages中是图片，同样将刚才下载的图片移动到这里。然后就是Annotations，保存转化好的xml文件。除此之外，再把创建的字典改一下，让标签为0的对应没有正确佩戴，为1的对应正确佩戴：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">           &#x27;0&#x27;: &quot;no_mask&quot;,  # 创建字典用来对类型进行转换</span><br><span class="line">           &#x27;1&#x27;: &quot;with_mask&quot;  </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<p>正确修改后保存文件，运行，就可以得到完整的xml标签了，查看文件数量，应该和图片个数一致，这里是7595个。</p>
<p>不过由于其中一个文件标注错了，后面读取数据会报错：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KeyError: &#x27;None</span><br></pre></td></tr></table></figure><br>检查后可以发现是test_306数据的txt标签写成了None，修改成1即可。</p>
<p>完成后再用划分的代码得到训练集和数据集，同样记得把他的分类名改一下，顺序要和上面一致：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classes = [&quot;no_mask&quot;, &quot;with_mask&quot;]</span><br></pre></td></tr></table></figure><br>依然将该py文件放在同级目录，终端运行，结束后查看VOCdevkit文件夹，已经自动生成了图片和标签的训练集和测试集。</p>
<p>将整个文件夹放到YOLOv5的项目文件夹中，可以开始准备训练了。</p>
<h1 id="训练文件配置"><a href="#训练文件配置" class="headerlink" title="训练文件配置"></a>训练文件配置</h1><p>其实口罩检测的任务也比较简单，不用做别的改变，只需要修改下配置文件中的标签和分类数量就行了。</p>
<h2 id="data配置文件"><a href="#data配置文件" class="headerlink" title="data配置文件"></a>data配置文件</h2><p>去data文件夹里面复制一份voc.yaml，重命名为mask.yaml，然后做如下修改：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># download command/URL (optional)</span><br><span class="line"># download: bash data/scripts/get_voc.sh</span><br><span class="line"></span><br><span class="line"># train and val data as 1) directory: path/images/, 2) file: path/images.txt, or 3) list: [path1/images/, path2/images/]</span><br><span class="line">train: ../VOCdevkit/images/train/  # 6291 images</span><br><span class="line">val: ../VOCdevkit/images/val/  # 1668 images</span><br><span class="line"></span><br><span class="line"># number of classes</span><br><span class="line">nc: 2</span><br><span class="line"></span><br><span class="line"># class names</span><br><span class="line">names: [ &#x27;no_mask&#x27;, &#x27;with_mask&#x27; ]</span><br></pre></td></tr></table></figure></p>
<h2 id="model配置文件"><a href="#model配置文件" class="headerlink" title="model配置文件"></a>model配置文件</h2><p>去model文件夹里面复制一份yolov5s.yaml(下载的预训练的权重就是匹配这个模型)，重命名为mask.yaml，修改分类数为2即可：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc: 2  # number of classes</span><br></pre></td></tr></table></figure></p>
<h2 id="train文件配置"><a href="#train文件配置" class="headerlink" title="train文件配置"></a>train文件配置</h2><p>找到train.py提供的接口，需要修改的地方有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预训练权重路径</span><br><span class="line">parser.add_argument(&#x27;--weights&#x27;, type=str, default=&#x27;weights/yolov5s.pt&#x27;, help=&#x27;initial weights path&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模型配置文件修改</span><br><span class="line">parser.add_argument(&#x27;--cfg&#x27;, type=str, default=&#x27;models/mask.yaml&#x27;, help=&#x27;model.yaml path&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据配置文件修改</span><br><span class="line">parser.add_argument(&#x27;--data&#x27;, type=str, default=&#x27;data/mask.yaml&#x27;, help=&#x27;data.yaml path&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每组训练次数（根据电脑自行配置）</span><br><span class="line">parser.add_argument(&#x27;--epochs&#x27;, type=int, default=200)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每组图片数量（根据电脑自行配置）</span><br><span class="line">parser.add_argument(&#x27;--batch-size&#x27;, type=int, default=16, help=&#x27;total batch size for all GPUs&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU工作核心数量（根据电脑自行配置）</span><br><span class="line">parser.add_argument(&#x27;--workers&#x27;, type=int, default=4, help=&#x27;maximum number of dataloader workers&#x27;)</span><br></pre></td></tr></table></figure>
<p>完成这些后，不出意外可以开始训练了。</p>
<h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>终端运行train.py，还可能有一些错误：</p>
<ul>
<li><p>pycharm：页面文件太小，无法完成操作  (我这里没有遇到)<br>找到utils/datasets.py，修改81行参数为0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_workers=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺少SPFF类<br>有些版本的YOLO没有这个类，所以找到新版YOLO的models/conmmon.py文件，将这个类复制到自己项目的common.py文件中去：(位置没有要求，末尾即可)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SPPF(nn.Module):</span><br><span class="line">    # Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher</span><br><span class="line">    def __init__(self, c1, c2, k=5):  # equivalent to SPP(k=(5, 9, 13))</span><br><span class="line">        super().__init__()</span><br><span class="line">        c_ = c1 // 2  # hidden channels</span><br><span class="line">        self.cv1 = Conv(c1, c_, 1, 1)</span><br><span class="line">        self.cv2 = Conv(c_ * 4, c2, 1, 1)</span><br><span class="line">        self.m = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = self.cv1(x)</span><br><span class="line">        with warnings.catch_warnings():</span><br><span class="line">            warnings.simplefilter(&#x27;ignore&#x27;)  # suppress torch 1.9.0 max_pool2d() warning</span><br><span class="line">            y1 = self.m(x)</span><br><span class="line">            y2 = self.m(y1)</span><br><span class="line">            return self.cv2(torch.cat([x, y1, y2, self.m(y2)], 1))</span><br></pre></td></tr></table></figure>
<p>除了这些问题，其他可能就要自己再找找原因了。现在终于可以开始训练，进入目录后在终端输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python train.py</span><br></pre></td></tr></table></figure>
<p>然后等待结果就行了，过程中会更新进度。（这里我用cpu跑7000+张图片，显示需要将近十天，所以很不推荐）<br><img src="/2022/07/04/mask/train.png" alt="YOLOv5"></p>
<h1 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h1><p>训练完成后(没完成也行，权重实时更新)，找到runs/train/exp/weights/best.pt，这就是现在最准确的权重文件，就像之前使用detect.py那样，打开detect文件修改权重路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parser.add_argument(&#x27;--weights&#x27;, nargs=&#x27;+&#x27;, type=str, default=ROOT / &#x27;best.pt&#x27;, help=&#x27;model path(s)&#x27;)</span><br></pre></td></tr></table></figure>
<p>然后修改测试源路径(或者直接把你要测试的图片放到source那里显示的路径中)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parser.add_argument(&#x27;--source&#x27;, type=str, default=ROOT / &#x27;data/images&#x27;, help=&#x27;file/dir/URL/glob, 0 for webcam&#x27;)</span><br></pre></td></tr></table></figure>
<p>脚本会识别文件夹中包含的所有图片，并将结果放到runs/detect/exp中，我测试的结果如下：<br><img src="/2022/07/04/mask/mask1.jpg" alt="mask"><br>可以看到已经能正确识别了，如果你还想调用摄像头实时检测，那么只需要把source修改成下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parser.add_argument(&#x27;--source&#x27;, type=str, default=&#x27;0&#x27;, help=&#x27;file/dir/URL/glob, 0 for webcam&#x27;)# 调用摄像头</span><br></pre></td></tr></table></figure>
<p>然后终端运行py脚本，就完成了。（效果图就不放了）</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>我只是总结了下网上的教程，方便快速地完成这个项目任务，毕竟写博客肯定有没写到的地方或者没遇到的问题。  </p>
</li>
</ul>
<p>另外整个过程中修改过的配置文件和基本能用的权重pt文件都已经放在GitHub了，点下面的链接就能找到；需要数据集也可以联系我，在第一篇博客中有我的微信。</p>
<p>最后还是感谢文中提到两位博主，可以去看一看他们的文章。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Deep Learning</category>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>YOLOv5</tag>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title>鲁棒主成分分析与GNN社交网络链路预测方法</title>
    <url>/2022/07/26/link-prediction/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客将会聚焦社交网络中的链路预测问题，导读 <em>Link prediction via matrix completion</em> 和 <em>Link Prediction Based on Graph Neural Networks</em> 两篇文章中的工作和贡献。<br><span id="more"></span></p>
<h1 id="Link-Prediction-via-Matrix-Comletion"><a href="#Link-Prediction-via-Matrix-Comletion" class="headerlink" title="Link Prediction via Matrix Comletion"></a><em>Link Prediction via Matrix Comletion</em></h1><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>将鲁棒主成分分析法引入到社交网络链路预测中，利用矩阵的稀疏性质和低秩性质，只要社交网络连接地足够紧密（对相对紧密的真实社交网络，对比完全图也是很稀疏的），那么通过RPCA就可以达到较好的预测效果，且对有权和无权网络都适用。</p>
<h2 id="理论和方法"><a href="#理论和方法" class="headerlink" title="理论和方法"></a>理论和方法</h2><p>对一个社交网络的邻接矩阵 <em>G</em> ，提取一定百分比的边作为训练集，剩下的边作为验证集。然后根据RPCA的理论，假设邻接矩阵由两部分组成，一部分是冗余的噪声 <em>E</em> ，其中的正项是网络中虚假的连接，负项表示出现在信息矩阵中的缺失连接（通过后面的方法部分会更理解这里）；另一部分是矩阵中鲁棒的信息矩阵 <em>X*</em> ，包含着整个邻接矩阵的构成信息，并且这部分信息矩阵应该是低秩并且稀疏的（思考一个棋盘格图像，只需要一个秩为2的信息矩阵就能构建任意大小的棋盘格图像）。</p>
<p>因此，社交网络的邻接矩阵 <em>G</em> 就可以通过 <em>E+X</em> 来表示，如果 <em>G</em> 中有缺失的连接，那么它也应当符合信息矩阵传达的矩阵结构，即缺失的连接应该会出现在 <em>X** 中。然后我们当然就可以通过找到网络的信息矩阵 </em>X<strong> ，并提取其中新出现的连接 <em>X</em>（即预测的链路）来构建一个理想的恢复矩阵 *G</strong> ,表示成 <em>X+G</em>。</p>
<p>这几个矩阵之间的关系可以用下图来表示：<br><img src="/2022/07/26/link-prediction/1.jpg" alt="场景"><br>（其中观察矩阵A就是上面说的邻接矩阵G，信息矩阵即骨干矩阵<em>X**，恢复的矩阵G在上面是</em>G**）</p>
<p>这样一来，只要能够找到从邻接矩阵 G 中提取信息矩阵 <em>X** 的方法，就能完成链路预测了。这里文中就引入了RPCA方法（不使用PCA是因为文中说PCA面对严重破坏的数据表现不好），由于 </em>G = E + X<strong> ，并假设 <em>E</em> 是稀疏的（稀疏的社交网络中的噪声必然更加稀疏），且 *X</strong> 是低秩的（类比棋盘格图像的信息矩阵，因为包含规整的结构信息并去除了不规整的噪声所以是低秩的），所以将这个问题转化成一个双目标优化问题，目标是在前面等式约束条件下找到参与 <em>G</em> 表示的最稀疏的矩阵 <em>E</em> 和最低秩的矩阵 <em>X*</em>。其中参数lamda用来平衡矩阵构成的稀疏性和低秩性。</p>
<p><img src="/2022/07/26/link-prediction/3.jpg" alt="场景"></p>
<p>其中“最稀疏的”用零范数量化，“最低秩的”用矩阵的秩计算来量化。但是由于这个优化问题是NP难且非凸的，所以要进一步松弛零范数为一范数，矩阵的秩计算松弛为核范数，从而得到问题的松弛解。这部分在论文 <em>鲁棒主成分分析及其应用</em> 中有更详细的数学理论支持。</p>
<p><img src="/2022/07/26/link-prediction/2.jpg" alt="场景"></p>
<p>找到信息矩阵后，对照原矩阵 <em>G</em> 确认多出来的链路，添加到 <em>G</em> 上，就恢复得到与原本真实网络足够接近的矩阵 <em>G*</em> 了，从而完成了链路预测。</p>
<p>值得注意的是，文中还给出了验证预测正确率的方法。恢复完成后的矩阵每项值为邻接矩阵中该项代表的链路产生连接的可能性，由于先前抹去了网络中一定数量的 <em>L</em> 个链路作为测试集，所以这里也将所有的链路（可以从恢复的矩阵 <em>G** 中选也可以单独从预测的链路 </em>X<em> 中选择）按照降序排列，验证前 </em>L* 个链路中有多少个正确的预测，作为预测的正确率。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>介绍完方法后，文中引用了论文论证使用该方法能预测何种程度的链路缺失。虽然由于网络的稀疏，一般不能满足完全预测恢复的条件，但是所幸社交网络的链路预测并不需要完全精准地恢复矩阵中的所有非零项，因为其中很大一部分仍然是空连接，只有一小部分才是缺失的连接，所以在这种程度上可以忽略（这里不是很明白，原文中说的也比较简略）。</p>
<p>然后提及优化问题中需要确定的超参数lamda，可以通过实验确定，不同的网络会有不同的超参数。</p>
<p>另外，文中还说明了链路预测的时间复杂度为 <em>O(kn^2)</em>, <em>k</em> 是矩阵的估计秩，且得益于稀疏性，<em>k</em> 要比 <em>n</em> (矩阵规模)小很多，体现了算法效率的优越性。</p>
<p>最后，文中还给出”global structure”的定义和计算方式，作为一个衡量网络的指标，并说明全局预测方法应当和这个数值g有关。</p>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>在不同的真实社交网络上进行对比，得到的结果和其他链路预测方法对比，并计算网络的各种指标，得到了较好的结果。</p>
<h2 id="结论与讨论"><a href="#结论与讨论" class="headerlink" title="结论与讨论"></a>结论与讨论</h2><p>使用RPCA完成链路预测是比较好的方法，但是该方法有一定缺陷。对于超参数lamda，可以通过实验确定，对于任何网络都可以将其分成测试集和训练集，反复实验确定最好的超参数后再进行链路预测即可。展望后续工作。</p>
<h1 id="Link-Prediction-Based-on-Graph-Neural-Networks"><a href="#Link-Prediction-Based-on-Graph-Neural-Networks" class="headerlink" title="Link Prediction Based on Graph Neural Networks"></a><em>Link Prediction Based on Graph Neural Networks</em></h1><h2 id="贡献-1"><a href="#贡献-1" class="headerlink" title="贡献"></a>贡献</h2><p>指出启发式预测方法的假设问题，研究一种根据网络自动学习启发式的链路预测方法。首先提出 <em>γ-decaying</em> 理论合并所有的启发式方法统一形式，并证明所有启发式计算可以从局部子图近似得到；然后基于该理论支持完成使用 <em>GNN</em> 从局部子图学习启发式的方法，结果表明这种方法有很好的链路预测效果。</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>首先介绍启发式链路预测方法，这类方法通过计算结点相似性来作为链路预测的依据，并根据计算方法的最大邻居“跳数”（<em>hop of neighbors</em>）可以分为一阶、二阶等。因此定义 <em>h</em> 阶的启发式方法为需要得到 <em>h</em> 跳邻居信息的方法。高阶的启发式方法或许需要知道整个图的信息。</p>
<p>然后指出这类启发式方法的局限，由于假设性太强，所以某种方法往往只适合某一类网络，不够鲁棒。所以实际上这类方式都属于一种更一般化的类别，图结构特征（<em>graph structure features</em>）。这种特征指位于观测的结点和边结构中的特征，能够直接从图中计算出来。所以启发式方法可以看作预先定义的图结构特征，自然会想到能不能自动从网络中学习。前面有人研究过这个问题，也就是 <em>WLNM</em> 方法，用全连接神经网络学习节点对，以节点对的 <em>h</em> 跳子图作为输入，预测是否会产生连接。</p>
<p>再定义“一跳”的封闭子图，即包含一对结点及其一跳范围内邻居的子图，其包含的信息非常丰富，一阶启发式需要的信息都可以通过这个子图计算。不过对于一些高阶的启发式，看起来似乎需要使用非常高的跳数 <em>h</em>，几乎要使用整个网络作为输入。所以通过第一个理论的构建，首先可以证明大多数启发式方法可以用这个理论统一，而且即便是小的 <em>h</em> 也能支持计算高阶特征信息，而不用使用庞大的网络。</p>
<p>除此外，还会提出SEAL框架，从封闭子图中学习一般的图的结构特征。这种框架改进了WLNM的缺陷，首先 <em>GNN</em> （使用的是卷积图神经网络）代替 <em>WLNM</em> 使用的全连接神经网络，改进图特征的获取能力；除此之外，SEAL还允许学习除子图结构外的显式、隐式的结点特征，结合了多种信息。</p>
<h2 id="启发式方法的统一理论"><a href="#启发式方法的统一理论" class="headerlink" title="启发式方法的统一理论"></a>启发式方法的统一理论</h2><p>所有启发式方法的计算都可以归纳成下面的公式框架：<br><img src="/2022/07/26/link-prediction/4.jpg" alt="场景"><br>其中要公式满足：<br><img src="/2022/07/26/link-prediction/6.jpg" alt="场景"><br>那么就可以通过第一个公式进行高阶启发式的近似计算（低阶的能直接计算当然不用管）。</p>
<p>接着论证了三种启发式方法都满足这个框架。</p>
<p>这样统一的理论结果框架说明封闭子图中包含的信息已经足够进行近似计算了，因为它表明在好的启发式方法中或许较远的图结构实际上对链路存在的贡献比较小。链路预测中也应当给离目标较远的结构以较小的权重。</p>
<p>综上，只要提取较小的封闭子图，就能精准计算一阶、二阶启发式信息，并近似得到高阶信息。</p>
<h2 id="SEAL框架"><a href="#SEAL框架" class="headerlink" title="SEAL框架"></a>SEAL框架</h2><p>SEAL不限制学习到的特征是某种特定形式，而是直接学习链路预测的一般图结构特征。</p>
<p>步骤是：提取封闭子图；构建信息矩阵；GNN学习。</p>
<h3 id="提取子图"><a href="#提取子图" class="headerlink" title="提取子图"></a>提取子图</h3><p>信息矩阵是对整体网络结点构建的，对网络中每个边，分为train和test边，对训练的边采用用户定义的h跳数提取子图，边存在则将子图标记为1，否则0，同时提取信息矩阵，将对应结点的信息向量提取出来按列拼接。</p>
<h3 id="信息矩阵"><a href="#信息矩阵" class="headerlink" title="信息矩阵"></a>信息矩阵</h3><p>关键是构建结点信息矩阵，包含三部分：结构标签(Structural Lable)、点的嵌入(Embeeding)、点的属性(Attributes)。</p>
<ul>
<li><p>点的结构标签通过提出的 <em>DRNL</em> 算法完成，给子图中每个点不同的整数标签值。</p>
</li>
<li><p>点嵌入旨在得到点的低维向量表示，使用node2vec算法来获得全图中每个结点的嵌入，然后在提取子图的时候将子图中结点的嵌入向量提取出来。</p>
</li>
<li><p>点的显式显式特征向量，可以在数据中给出，并通过独热编码 (<em>one-hot encoding</em>) 得到唯一向量表示。</p>
</li>
</ul>
<p>然后将点的隐式特征（Embeedings），显示特征（Attributes），拼接起来（按行拼接，每行是一个结点的信息向量），就得到了信息矩阵。而结构标签可以让GNN分辨哪个是要判断存在性的边。</p>
<h3 id="GNN学习"><a href="#GNN学习" class="headerlink" title="GNN学习"></a>GNN学习</h3><p>使用DGCNN训练，得到分类结果。<br>作者指出，<em>DGGNN</em> （一种图神经网络，SEAL也可使用其他GNN）由于会仅通过拟合结点嵌入中包含的链路存在信息进行快速优化，也就是过拟合，导致泛化性不好，所以通过“负注入”来使 <em>DGGNN</em> 不能只拟合这部分信息来分类，在图中加入负连接得到新的图，然后根据新的图再生成嵌入向量，就相当于隐藏了这部分信息，从而提高泛用性。（学习图嵌入可以更好地理解）</p>
<h2 id="仿真-1"><a href="#仿真-1" class="headerlink" title="仿真"></a>仿真</h2><p>在多个网络上进行实验，并同其他方法对比，取得良好结果。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>自动学习合适的启发式是一个新领域的研究，通过这篇文章提出的理论，首先统一了启发式形式，然后还提出了性能领先的SEAL框架，作者希望SEAL不仅仅在链路预测上有突破，在其他问题上一样能得到应用和推广。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>为什么使用GNN：因为我们将每个子图作为样本进行二分类，子图大小总是不一样，如果使用一般的神经网络需要截断子图的邻接矩阵，可能导致信息丢失；</li>
<li>使用负注入：核心是避免过拟合，从而提升泛化性。</li>
</ul>
<h1 id="结点重要性"><a href="#结点重要性" class="headerlink" title="结点重要性"></a>结点重要性</h1><p>DGCNN中直接对结点信息通道降序排序，能不能说明汇聚信息更多，或者自身信息较大的结点更重要，如果能在卷积的同时增加这种重要性，就能进一步帮助排序结点。</p>
<p>另外的论文中提到，三阶邻接矩阵包含了大部分二阶的邻接矩阵信息，同时二阶的邻接矩阵在一些情况下又比一阶的邻接矩阵信息多，既然用一阶的矩阵汇聚得到邻居的信息，那么用三阶邻接矩阵进行汇聚，显然包含了一阶汇聚的信息，同时还有更多的连接权重，能不能将这部分作为汇聚的参考，可能需要进一步验证。</p>
<p>另外，子图最大规模是两跳，三阶的邻接矩阵应该会比较符合文中说明的意思，五跳的信息中会有很多冗余，代表紧密的局部连接。如果子图是一跳的，三跳信息就已经比较冗余了。<br><img src="/2022/07/26/link-prediction/7.jpg" alt="场景"><br>经过验证以后，这样汇聚的结果还是不理想，比原来的结果低1%左右，原因需要进一步分析，也许使用PageRank等方法对结点排序更有说服力。</p>
<h1 id="链路预测评价"><a href="#链路预测评价" class="headerlink" title="链路预测评价"></a>链路预测评价</h1><h2 id="准确率"><a href="#准确率" class="headerlink" title="准确率"></a>准确率</h2><p>计算链路预测正确的比例，直观反应方法性能。</p>
<h2 id="AUC-metric"><a href="#AUC-metric" class="headerlink" title="AUC metric"></a><em>AUC metric</em></h2><p>用于衡量一种方法预测存在连接和非存在连接的性能。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Deep Learning</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>GNN</tag>
        <tag>Link Prediction</tag>
        <tag>SEAL</tag>
        <tag>RPCA</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径算法总结</title>
    <url>/2023/10/16/pathsearch/</url>
    <content><![CDATA[<p>游戏开发经常会问这个问题，因为Unity的导航系统用的是A*算法，并且有时候还需要进一步改进，这里将以这篇<a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">文章</a>为主，介绍几种寻路算法算法。</p>
<span id="more"></span>
<h1 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h1><p>广度优先是最简单的寻路算法了，它从出发点开始，用一个队列存储当前点的邻居点，然后开始迭代，每次出队一个点，再将新点的邻居入队。同时用一个集合存储已经访问过的结点，遍历的时候会跳过这些点避免重复访问。</p>
<p><img src="/2023/10/16/pathsearch/1.png" alt></p>
<p>例如上图中，我们从★源点开始，它的四个邻居标号为1，2，3，4，依次添加到队列中并添加到已访问的结点集合里，然后下一次遍历出队1，将上图中绿色的点入队。不过由于源点已经访问过，所以不会再被入队。伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Declare</span><br><span class="line">Queue&lt;int&gt; q;</span><br><span class="line">Set&lt;int&gt; s;</span><br><span class="line">q.push(start);</span><br><span class="line">s.push(start);</span><br><span class="line">//Start iteration</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">	current = q.pop();</span><br><span class="line">	for(neighbors of current)</span><br><span class="line">	&#123;</span><br><span class="line">		if(s.contain(neighbors) == false)</span><br><span class="line">		&#123;</span><br><span class="line">			q.push(neighbors);</span><br><span class="line">			s.push(neighbors);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是仅仅这样不能找到我们是从哪条路过来的，因为广度优先遍历仅仅是遍历，要想找到路径需要我们进一步手动记录。这里我们修改集合s，让它作为一个哈希表或字典，进一步记录访问过的结点的父结点是谁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Declare</span><br><span class="line">Queue&lt;int&gt; q;</span><br><span class="line">Hash&lt;int&gt; s;</span><br><span class="line">q.push(start);</span><br><span class="line">s[start] = None;</span><br><span class="line">//Start iteration</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">	current = q.pop();</span><br><span class="line">	for(neighbors of current)</span><br><span class="line">	&#123;</span><br><span class="line">		if(s.contain(neighbors) == false)</span><br><span class="line">		&#123;</span><br><span class="line">			q.push(neighbors);</span><br><span class="line">			s[neighbors] = current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当我们遍历到终点时，就可以不断回溯这个哈希表，找到这条路径。而且由于一个点只对应一个父结点，因此路径是唯一确定的。我们通过下面的伪代码找到路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">current = goal;</span><br><span class="line">path = [];</span><br><span class="line">while(current != start)</span><br><span class="line">&#123;</span><br><span class="line">	path.push(current);</span><br><span class="line">	current = s[current];</span><br><span class="line">&#125;</span><br><span class="line">path.push(start);</span><br><span class="line">//reverse so that the first element is start</span><br><span class="line">path.reverse();</span><br></pre></td></tr></table></figure>
<p><img src="/2023/10/16/pathsearch/2.png" alt></p>
<h1 id="单源单目标寻路"><a href="#单源单目标寻路" class="headerlink" title="单源单目标寻路"></a>单源单目标寻路</h1><p>上面我们能找到的是一个点到其它所有点的路径，然而我们其实并不需要这么做，我们只需要找到目标点的路径。因此上面的算法有太多无效计算。当然可以等找到目标点就马上停止，这也是一种改进方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Declare</span><br><span class="line">Queue&lt;int&gt; q;</span><br><span class="line">Hash&lt;int&gt; s;</span><br><span class="line">q.push(start);</span><br><span class="line">s[start] = None;</span><br><span class="line">//Start iteration</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">	current = q.pop();</span><br><span class="line">	//Pay attention here</span><br><span class="line">	if(current == goal) break;</span><br><span class="line">	for(neighbors of current)</span><br><span class="line">	&#123;</span><br><span class="line">		if(s.contain(neighbors) == false)</span><br><span class="line">		&#123;</span><br><span class="line">			q.push(neighbors);</span><br><span class="line">			s[neighbors] = current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="考虑路径花费"><a href="#考虑路径花费" class="headerlink" title="考虑路径花费"></a>考虑路径花费</h1><p>现在我们进一步把结点的花费考虑进来，换句话说移动到不同结点的花费是不同的，我们需要找出其中最小的花费。比如文明中，沙漠中移动需要花费一点行动而跨山、森林需要五点。这里我们采用Dijkastra算法，在前面算法的基础上添加一个名为cost的变量来记录当前路径的花费，并且使用优先队列来记录结点。逻辑上也需要改变，不再将所有邻居放入优先队列，还要当这条新的路径优于原本路径时才添加，使得算法不会轻易选择那些花费较大的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PriorirtQueue&lt;int&gt; q;</span><br><span class="line">Hash&lt;int&gt; s;</span><br><span class="line">Hash&lt;int&gt; cost;</span><br><span class="line"></span><br><span class="line">q.push(start);</span><br><span class="line">s[start] = None;</span><br><span class="line">cost = 0;</span><br><span class="line"></span><br><span class="line">while(s.empty() == false)</span><br><span class="line">&#123;</span><br><span class="line">	currnet = s.pop();</span><br><span class="line">	if(current == goal) break;</span><br><span class="line">	</span><br><span class="line">	for(neighbors of current)</span><br><span class="line">	&#123;</span><br><span class="line">		//Calculate new cost</span><br><span class="line">		newcost = cost[current] + graph.cost(neighbors);</span><br><span class="line">		if(s.contain(neighbors) == false || newcost &lt; cost[neighbors])</span><br><span class="line">		&#123;</span><br><span class="line">			cost[neighbors] = newcost;</span><br><span class="line">			q.push(neighbors, newcost);</span><br><span class="line">			s[neighbors] = current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/10/16/pathsearch/3.png" alt></p>
<p>跟之前的方法相比，现在遍历扩张就考虑了路径代价。注意我们的优先队列出队应返回最小优先级的对象。这可能跟你之前学习的Dijkastra不太像，这里做了一些改变，但是它们都属于一种贪心，即选择当前耗费最少的路径。</p>
<h1 id="启发式方法"><a href="#启发式方法" class="headerlink" title="启发式方法"></a>启发式方法</h1><p>启发式指的是人为构造一个公式计算某个数值，这里用来估计当前点到目标点的距离。文章直接使用棋盘距离作为启发式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int heuristic(a,b)</span><br><span class="line">&#123;</span><br><span class="line">	return abs(a.x-b.x) + abs(a.y-b.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用上面的式子修改之前广度优先算法，优先将具有最小估计距离的点拿出来遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Declare</span><br><span class="line">PriorityQueue&lt;int&gt; q;</span><br><span class="line">Hash&lt;int&gt; s;</span><br><span class="line">q.push(start);</span><br><span class="line">s[start] = None;</span><br><span class="line"></span><br><span class="line">//Start iteration</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">	current = q.pop();</span><br><span class="line">	if(current == goal) break;</span><br><span class="line">	</span><br><span class="line">	for(neighbors of current)</span><br><span class="line">	&#123;</span><br><span class="line">		if(s.contain(neighbors) == false)</span><br><span class="line">		&#123;</span><br><span class="line">			q.push(neighbors, heuristic(goal, next));</span><br><span class="line">			s[neighbors] = current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样路径搜寻会比Dijkastra算法进一步地优先访问距离目标点近的结点，而不是依靠当前的花费决定，我们的方法现在有了目标感。</p>
<p><img src="/2023/10/16/pathsearch/4.png" alt></p>
<p>然而也带来一个问题，当存在障碍物的时候，这个方法用来导航会走弯路。</p>
<p><img src="/2023/10/16/pathsearch/5.png" alt></p>
<p>当然这是可行的，不过并不正确，我们结合上面这两种方法，就是A star算法。</p>
<h1 id="A-star"><a href="#A-star" class="headerlink" title="A star"></a>A star</h1><p>A星算法同时考虑当前的花费和与目标的估计值，它的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PriorirtQueue&lt;int&gt; q;</span><br><span class="line">Hash&lt;int&gt; s;</span><br><span class="line">Hash&lt;int&gt; cost;</span><br><span class="line"></span><br><span class="line">q.push(start);</span><br><span class="line">s[start] = None;</span><br><span class="line">cost = 0;</span><br><span class="line"></span><br><span class="line">while(s.empty() == false)</span><br><span class="line">&#123;</span><br><span class="line">	currnet = s.pop();</span><br><span class="line">	if(current == goal) break;</span><br><span class="line">	</span><br><span class="line">	for(neighbors of current)</span><br><span class="line">	&#123;</span><br><span class="line">		//Calculate new cost</span><br><span class="line">		newcost = cost[current] + graph.cost(neighbors);</span><br><span class="line">		if(s.contain(neighbors) == false || newcost &lt; cost[neighbors])</span><br><span class="line">		&#123;</span><br><span class="line">			cost[neighbors] = newcost;</span><br><span class="line">			//Changed here</span><br><span class="line">			priority = newcost + heuristic(goal, next);</span><br><span class="line">			q.push(neighbors, heuristic);</span><br><span class="line">			s[neighbors] = current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/10/16/pathsearch/6.png" alt></p>
<p>A star算法同时将两种距离考虑进去，既不会像Dijkastra那样无目的地搜索，也不会想启发式方法那样找到非最短路径，它被认为是最好的路径搜索算法。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+next主题配置</title>
    <url>/2022/07/03/test/</url>
    <content><![CDATA[<p>记录博客网站的美化操作，用的是hexo和next主题。<br><span id="more"></span></p>
<h2 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h2><h3 id="hexo配置文件-config-yml"><a href="#hexo配置文件-config-yml" class="headerlink" title="hexo配置文件 _config.yml"></a>hexo配置文件 <em>_config.yml</em></h3><h4 id="修改网站基本配置信息"><a href="#修改网站基本配置信息" class="headerlink" title="修改网站基本配置信息"></a>修改网站基本配置信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site  </span><br><span class="line">title: ANKIIMA  </span><br><span class="line">subtitle: &#x27;Blog&#x27;  </span><br><span class="line">description: &#x27;ANKIIMA的博客&#x27;  </span><br><span class="line">keywords: &#x27;OpenGL CV&#x27;  </span><br><span class="line">author: &#x27;ANKIIMA&#x27;  </span><br><span class="line">language: zh-CN  </span><br><span class="line">timezone: &#x27;&#x27;`  </span><br></pre></td></tr></table></figure>
<h4 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions  </span><br><span class="line">theme: NEXT  </span><br></pre></td></tr></table></figure>
<h2 id="next配置"><a href="#next配置" class="headerlink" title="next配置"></a>next配置</h2><h4 id="选择框架"><a href="#选择框架" class="headerlink" title="选择框架"></a>选择框架</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
<h4 id="dark-mode启用"><a href="#dark-mode启用" class="headerlink" title="dark mode启用"></a>dark mode启用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Dark Mode  </span><br><span class="line">darkmode: false  </span><br></pre></td></tr></table></figure>
<h4 id="网页图标更换（使用此网站创建图标）替换路径为对应图片"><a href="#网页图标更换（使用此网站创建图标）替换路径为对应图片" class="headerlink" title="网页图标更换（使用此网站创建图标）替换路径为对应图片"></a>网页图标更换（使用<a href="https://realfavicongenerator.net/">此网站</a>创建图标）替换路径为对应图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site Information Settings  </span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png  </span><br><span class="line">  medium: /images/favicon-32x32-next.png  </span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png  </span><br><span class="line">  safari_pinned_tab: /images/logo.svg  </span><br><span class="line">  #android_manifest: /manifest.json  `  </span><br></pre></td></tr></table></figure>
<h4 id="菜单设置-自定义添加菜单项"><a href="#菜单设置-自定义添加菜单项" class="headerlink" title="菜单设置 自定义添加菜单项"></a>菜单设置 自定义添加菜单项</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:  </span><br><span class="line">  home: / || fa fa-home  </span><br><span class="line">  # about: /about/ || fa fa-user  </span><br><span class="line">  tags: /tags/ || fa fa-tags  </span><br><span class="line">  categories: /categories/ || fa fa-th  </span><br><span class="line">  archives: /archives/ || fa fa-archive  </span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar  </span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap  </span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat`</span><br></pre></td></tr></table></figure>
<p>next提供上面的可选菜单项，格式最后一项是显示图标，可以在<a href="https://fontawesome.com/">该网站</a>查询对应的值并修改。如果想添加其他菜单项应该也可以按照上面的格式，不过对我来说够用了。</p>
<h3 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h3><h4 id="头像-需要gif格式"><a href="#头像-需要gif格式" class="headerlink" title="头像 需要gif格式"></a>头像 需要gif格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/1.gif</span><br><span class="line">  # If true, the avatar will be displayed in circle.</span><br><span class="line">  rounded: false</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>
<h4 id="其他页面链接"><a href="#其他页面链接" class="headerlink" title="其他页面链接"></a>其他页面链接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/ANKIIMA || fab fa-github</span><br></pre></td></tr></table></figure>
<h3 id="页脚设置"><a href="#页脚设置" class="headerlink" title="页脚设置"></a>页脚设置</h3><h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Icon between year and copyright info.</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in Font Awesome. See: https://fontawesome.com/icons</span><br><span class="line">    name: fa-solid fa-cannabis</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#A9A9A9&quot;</span><br></pre></td></tr></table></figure>
<h4 id="copyright"><a href="#copyright" class="headerlink" title="copyright"></a>copyright</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># If not defined, `author` from Hexo `_config.yml` will be used.</span><br><span class="line">  copyright: ANKIIMA</span><br></pre></td></tr></table></figure>
<h3 id="文章显示设置"><a href="#文章显示设置" class="headerlink" title="文章显示设置"></a>文章显示设置</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>按照<a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">hexo文档</a>的格式在文章中设置摘要部分，否则自动全部显示<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Automatically excerpt description in homepage as preamble text.</span><br><span class="line">excerpt_description: true</span><br></pre></td></tr></table></figure></p>
<h4 id="阅读全文按钮"><a href="#阅读全文按钮" class="headerlink" title="阅读全文按钮"></a>阅读全文按钮</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Read more button</span><br><span class="line"># If true, the read more button will be displayed in excerpt section.</span><br><span class="line">read_more_btn: true</span><br></pre></td></tr></table></figure>
<h4 id="文章末尾标签符号显示"><a href="#文章末尾标签符号显示" class="headerlink" title="文章末尾标签符号显示"></a>文章末尾标签符号显示</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Use icon instead of the symbol # to indicate the tag at the bottom of the post</span><br><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure>
<h4 id="文末推广链接"><a href="#文末推广链接" class="headerlink" title="文末推广链接"></a>文末推广链接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Subscribe through Telegram Channel, Twitter, etc.</span><br><span class="line"># Usage: `Key: permalink || icon` (Font Awesome)</span><br><span class="line">follow_me:</span><br><span class="line">  #QQ: 1667791793 || fa-brands fa-qq</span><br><span class="line">  GitHub: https://github.com/ANKIIMA || fa-brands fa-github</span><br><span class="line">  #Twitter: https://twitter.com/username || fab fa-twitter</span><br><span class="line">  #Telegram: https://t.me/channel_name || fab fa-telegram</span><br><span class="line">  #WeChat: /images/wechat_channel.jpg || fab fa-weixin</span><br></pre></td></tr></table></figure>
<p>上面的icon设置同上</p>
<h3 id="主题其他设定"><a href="#主题其他设定" class="headerlink" title="主题其他设定"></a>主题其他设定</h3><h4 id="颜色设置"><a href="#颜色设置" class="headerlink" title="颜色设置"></a>颜色设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Browser header panel color.</span><br><span class="line">theme_color:</span><br><span class="line">  light: &quot;#222&quot;</span><br><span class="line">  dark: &quot;#222&quot;</span><br></pre></td></tr></table></figure>
<h4 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h4><p>显示在右上角，自动保存读者阅读进度<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Bookmark Support</span><br><span class="line">bookmark:</span><br><span class="line">  enable: true</span><br><span class="line">  # Customize the color of the bookmark.</span><br><span class="line">  color: &quot;#222&quot;</span><br><span class="line">  # If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span><br><span class="line">  # If manual, only save it by clicking the bookmark-icon.</span><br><span class="line">  save: auto</span><br></pre></td></tr></table></figure></p>
<h3 id="添加菜单项页面"><a href="#添加菜单项页面" class="headerlink" title="添加菜单项页面"></a>添加菜单项页面</h3><p>  如果仅在菜单设置中添加选项，点击后由于没有资源所以不会打开页面，所以不用修改配置文件，而应该在博客文件夹中应该使用hexo添加对应的页面资源：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page custom-name</span><br></pre></td></tr></table></figure><br>添加以后博客文件中会出现对应名称的文件夹，包含子集目录index，生成一个md文件。  举例来说，如果添加的是标签和分类页面，那么先进入md文件，在文首的hexo信息栏中添加type关键字，值为对应名称(tags | categories)，然后更新博客就可以看到效果了。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"># tag页面信息栏</span><br><span class="line">title: tags</span><br><span class="line">date: 2022-07-03 22:13:01</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>添加完成后，标签页面和分类页面会自动统计并显示已经存在的标签或类别，不用进一步更改；点击对应标签或类别也会显示对应文章。  </p>
<p>要注意的是，撰写文章的同时也要将对应的标签和分类关键字按照hexo要求写在信息栏中，例如本篇博客：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo+next主题配置</span><br><span class="line">date: 2022-07-03 11:48:55</span><br><span class="line">categories:</span><br><span class="line">- Blog</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">- next</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>  上面是我博客配置的大致信息，更多配置方法可以参考<a href="https://theme-next.js.org">next文档</a>，next在配置文件中给出了一系列配置接口，即使不懂前端知识也能进行个性化设置，还可以在博客页面中添加聊天室、评论等功能，如果以后有精力会再进行记录。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Personal Profile</title>
    <url>/2023/10/02/profile/</url>
    <content><![CDATA[<p>Contact me:</p>
<p>Name:</p>
<p>Ziqin Gao</p>
<p>Email:</p>
<p>anki1667791793@gmail.com</p>
]]></content>
  </entry>
  <entry>
    <title>Unity Shader实现Cook-Torrance模型的光照部分</title>
    <url>/2023/05/23/pbr-unishader/</url>
    <content><![CDATA[<p>本文将使用Unity Shader实现直接光照(无纹理)的Cook-Torrance模型，该模型是一种常见的PBR渲染，但要注意这里实现的模型是只有直接光照的，这意味着纹理贴图、环境光等内容完全不关心，只了解PBR的光照部分是怎么实现的。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>说到这个模型就不得不提到PBR了，PBR就是Physics Based Rendering，基于物理的渲染。虽然它也是上世纪的光照模型，不过从Phong的基础光照到Cook-Torrance代表的PBR光照是巨大的进步，Unity中Standard Shader就是一个完整的PBR实现。</p>
<p>不过要清楚，PBR不仅仅是光照，完整的PBR包括Image Based Lighting，它才是Global Lighting的主要功臣。仅仅是PBR的话，其实我们实现的效果比原来的基础光照没有好特别多，因为没有环境贴图支持IBL。不过也不必担心，IBL的实现比PBR光照要简单多了，实际上IBL也是在PBR光照的基础上采样立方体贴图，所以实现了PBR就可以很轻松地完成IBL。</p>
<p>那么下面我们再梳理一些Cook-Torrance和PBR的关系，PBR是基于物理的渲染，其中有一个非常著名的渲染公式，定义了一个被称为BRDF的函数界定光线照到物体上后，有多少光将会被反射出去。而Cook-Torrance则是在这个BRDF上进行了细致的刻画，通过物理模拟出这个比例函数，于是我们通过解出渲染方程就能得到光照情况。所以下面我们先开始介绍这个著名的渲染方程。</p>
<p>所有的PBR都是基于微平面理论的，必须满足能量守恒，具有物理的BRDF函数。所谓微平面就是将模型表面看成很多微元，也就是我们处理的片元，这可以用来估算平面粗糙对镜面光的影响，我们使用入射方向和观察方向的半程向量来作为量化。</p>
<p><img src="/2023/05/23/pbr-unishader/1.png" alt></p>
<p>而能量守恒则体现在入射和反射光线的比例，由于折射的存在，反射光线的能量一定会小于入射光线，可以将漫反射看作折射光进入物体后又发散出来的表现。但是对于金属材质，折射光将全部被吸收，因此只会显示镜面光而没有漫反射。因此我们建立一个三种光之间的关系，光线入射后，在物体表面的光只有反射形成的ks部分，折射光则是入射光减去反射光剩下的部分，也就是1-ks。</p>
<p>最后就是BRDF函数了，这里需要了解辐射度量学的基本概念，不再赘述，简单来说我们将一条光线能量量化为Radiance，入射光线为Radiance对方向的积分Irradiance，出射光线为Radiance对片元的积分Radiant Intensity，借此我们可以用公式表达光线的反射过程，这就是渲染方程。</p>
<p><img src="/2023/05/23/pbr-unishader/2.png" alt></p>
<p>其中Lo表示反射光线，wo表示反射的方向，p是顶点，Le表示自发光，Li表示wi方向过来的入射光线，fr则是BRDF函数，它表示反射光线的比例；最后一项是法线和入射光线的夹角余弦值。后面积分的意义是对正半球上的所有立体角积分，也就是统计所有入射的光线，得该点p上所有到wo方向的反射光线。</p>
<p>一般情况下，该积分没有解析解，所以不得不采用黎曼和的方式多次采样求平均，不过非常幸运，我们使用Unity Shader在可编程管线中操作这个积分是非常方便的，因为根本不用积分！目前我们使用的是平行光，且只有一个物体，那么片元接受的半球积分上就只有光线方向不为0，对这一个方向计算即可。就算使用了多个方向的光源，也不必担心，通过设置正确的LightMode也能轻松解决，Unity将会对多个光源进行相同的Pass。总之，完全不必担心如何积分的问题，我们可以简单地将wi看作入射光的方向，wo则是观察的方向，按照公式计算片元的颜色并返回即可。从这一点看来，cook-Torrance模型确实和之前的基础光照没有多少不同，只不过该模型进一步解释了漫反射和镜面光背后的原理，以及用物理公式而不是经验来模拟它们，所以不管怎么说，此时光照更加真实了。</p>
<p>最后，我们来看看cook-Torrance如何定义BRDF函数的，下面是该模型的渲染方程：</p>
<p><img src="/2023/05/23/pbr-unishader/3.png" alt></p>
<p>对比上面的一般方程，这里暂不考虑自发光，重点看其中的BRDF函数，前一项为漫反射的比例，c就是漫反射颜色，如果分配后将该值和后面的部分相乘，会发现它其实就是前面基础光照的兰伯特公式，只是多除以了圆周率，因为BRDF积分结果可以看作乘上了pi，我们需要抵消该项。但是我们的具体实现不用积分，所以也并不需要在具体实现中除以pi。kd是漫反射的比例，ks是镜面光比例，它们的和应当为1。</p>
<p>后一项是计算镜面光比例的，D、F、G分别是法线分布函数、菲涅尔方程和几何函数。其中法线分布函数估算法线方向和半程向量一致的微平面的数量，几何函数描述了微平面几何特征，某些光线可能被微平面上的不规则平面遮挡，该函数给出这种遮挡的概率。最后菲涅尔项是描述物理现象的，我们在观察物体表面时，和表面法线的夹角越大，那么反射光线就越强；夹角越小，那么反射光线就越弱。</p>
<p>前两种函数几乎都有不同的实现公式，这里我们选择Trowbridge-Reitz GGX法线分布，Schlick-GGX作为几何函数，它是GGX与Schlick-Beckmann近似的结合体。菲涅尔项一般采用Fresnel-Schlick进行近似计算。</p>
<p><img src="/2023/05/23/pbr-unishader/4.png" alt></p>
<p>法线分布D如上，其中α表示粗糙程度。</p>
<p><img src="/2023/05/23/pbr-unishader/5.png" alt></p>
<p>几何函数G如上，其中k也是和粗糙度有关的参数，由于我们这里只有直接光照，所以我们计算k为(α+1)^2/8。注意，如果存在环境贴图，这里的计算需要变化。</p>
<p><img src="/2023/05/23/pbr-unishader/6.png" alt></p>
<p>最后是菲涅尔项，其中F0是平面的基础反射率，不同材质具有不同的值。最后，我们按照之前Cook-Torrance的公式计算，就是完整的渲染流程了，可以看到实现方式并没有多少不同，我们只是修改了一些公式而已。</p>
<p>不过通常来说，PBR会用到四张不同的纹理，一张规定模型颜色，一张规定高模法线，一张规定金属部分，一张规定粗糙程度，有时还有专门的立方体贴图来保存环境信息，这就是目前常见的渲染过程，但是由于这里是光照部分，所以我们暂时不适用任何贴图，将采用直接光照的方式进行计算。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>经过前面的讲解，我们可以尝试对该模型进行计算了，先整理下我们需要的参数，由于是光照部分所以暂时不使用纹理，我们仅使用方向光作为光源。计算法线分布函数时，需要一个粗糙度Roughness，法线和半程向量的内积nh；计算几何函数，除前面外需要法线和观察方向的内积nv，法线和光源方向的内积nl；最后菲涅尔项需要半程向量和观察方向的内积vh，以及基础反射率Fresnel。对于反射方程，还需要光源方向、强度，然后还有一个漫反射的比例系数ks。总结下就是需要有三个Properties属性，Roughness，ks，Fresnel，再加一个漫反射颜色Color。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties &#123;        </span><br><span class="line">        _Color(&quot;Color&quot;, Color) = (1,1,1,1)         </span><br><span class="line">        fresnel (&quot;Fresnel&quot;, Range(0,1)) = 0.5</span><br><span class="line">        roughness (&quot;Roughness&quot;, Range(0,1)) = 0.5</span><br><span class="line">        ks(&quot;Ks&quot;,Range(0,1))=0.5</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后依然设置渲染模式为前向光照，在Pass中声明所需要的变量，也就是上面的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        #pragma vertex vert</span><br><span class="line">        #pragma fragment frag</span><br><span class="line">        #include &quot;Lighting.cginc&quot; </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        float4 _Color;</span><br><span class="line">        float fresnel;</span><br><span class="line">        float roughness;</span><br><span class="line">        float ks;</span><br></pre></td></tr></table></figure>
<p>下面再分析着色器的任务，这里肯定选择逐像素渲染了，所以顶点着色器的任务是计算世界空间下的法线和顶点坐标，以及必须的裁剪空间坐标变换。所以我们的顶点着色器和基础光照中使用的完全一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct a2f&#123;</span><br><span class="line">            float4 vertex : POSITION;</span><br><span class="line">            float3 normal : NORMAL;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        struct v2f&#123;</span><br><span class="line">            float4 pos:SV_POSITION;</span><br><span class="line">            float4 worldPos:TEXCOORD0;</span><br><span class="line">            float3 worldNormal:TEXCOORD1;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        v2f vert(a2f v)&#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos=UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.worldPos=mul(unity_ObjectToWorld,v.vertex);</span><br><span class="line">            o.worldNormal=normalize(mul(v.normal,(float3x3)unity_WorldToObject));</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>获得信息之后，我们需要在片元着色器中依次获得世界空间下顶点位置，法线，光照方向，观察方向，半程向量，并事先获得nh，vh，nl，nv四个点积方便我们计算BRDF。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float4 frag(v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float4 worldPos=i.worldPos;</span><br><span class="line">            float3 worldNormal=normalize(i.worldNormal);            </span><br><span class="line">            float3 lightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">            float3 viewDir=normalize(_WorldSpaceCameraPos-worldPos).xyz;            </span><br><span class="line">            float3 halfDir=normalize(viewDir+lightDir);</span><br><span class="line"></span><br><span class="line">            float vhDot=saturate( dot(viewDir,halfDir));</span><br><span class="line">            float nhDot=saturate(dot(worldNormal,halfDir));</span><br><span class="line">            float nlDot=saturate(dot(worldNormal,lightDir));</span><br><span class="line">            float nvDot=saturate(dot(worldNormal,viewDir));</span><br><span class="line">            </span><br><span class="line">            //Diffuse</span><br><span class="line">            float3 Idiff=(_Color*_LightColor0*nlDot).xyz;</span><br><span class="line"></span><br><span class="line">            //Specular</span><br><span class="line">            float3 Ispec; </span><br><span class="line">            //F</span><br><span class="line">            float F =pow((1.0-vhDot),5.0);</span><br><span class="line">            F *= (1.0-fresnel);</span><br><span class="line">            F += fresnel;</span><br><span class="line">            //D</span><br><span class="line">            float D = roughness * roughness / pow((nhDot*nhDot)*(roughness*roughness-1)+1,2);</span><br><span class="line">            //G</span><br><span class="line">            float G_k = pow(roughness+1,2)/8;</span><br><span class="line">            float G = nvDot / (nvDot*(1-G_k) + G_k);</span><br><span class="line"></span><br><span class="line">            float Rs=saturate((F*D*G)/(nvDot*nlDot));</span><br><span class="line">            Ispec=Rs*_LightColor0*nlDot;</span><br><span class="line"></span><br><span class="line">            float3 result=(1-ks)*Idiff+ks*Ispec;</span><br><span class="line">             </span><br><span class="line">            return float4(result,1);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意要用saturate函数截断到[0,1]之间。之后正式计算反射方程，分别按照公式计算代表漫反射的折射和代表镜面光的反射。完整的代码在本文最后。</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>由于材质、环境光的缺失，真正的PBR显然会得到比这要好得多的结果，但是我们可以在另一个略微复杂的模型上看看它们之间的区别，Blinn-Phong模型是难以调节诸多视觉效果的，而Cook-Torrance作为时下流行的实时光照，要显得灵活许多，能适应不同材质、模型的粗糙度，调节镜面光比例，以及针对金属着色的菲涅尔项，因此下面我们试着调整材质面板的参数，得到一个具有金属质感的模型。</p>
<p><img src="/2023/05/23/pbr-unishader/7.png" alt></p>
<p>左边是我们的Blinn-Phong模型，右边是Cook-Torrance模型，而且要说明的是，上图中我们并没有改变模型的颜色，之所有右边的渲染会显得这么黑是因为我们假定它是一个金属，而金属的折射不会重新散开到模型表面，所以漫反射比例为0；菲涅尔项的基础反射率也被我们调整到0.5，这基本是铁对应的基础反射率，因此可以大概知道生活中铁为什么也比较黑；我们还调整了粗糙度，假定这个金属工艺品具有平滑的表面，所以设定地很小，就得到了上图中的渲染质感。</p>
<p>想要得到其它金属的效果也是可以的，因为金属颜色的不同就体现在菲涅尔项，它们有不同的基础反射率，并且这个反射率应当用RGB的形式表达，否则只能得到黑白灰的线性结果，也就是铁、银这种金属。像金，铜就必须用RGB形式的基础反射率才能得到较好的效果。</p>
<p>当然，在使用我们前面介绍的四组纹理和环境光(基础光照中的Ambient)之后，将得到更加靠近目前渲染的结果，使用Unity的标准着色器就可以看到它的效果，下面是资源商店中的金属球材质，我们看看它的效果。</p>
<p><img src="/2023/05/23/pbr-unishader/8.png" alt></p>
<p>显然我们实现的Cook-Torrance是一个很简陋的物理光照模型，实现完整的PBR流程还需要伽马矫正，纹理，IBL等相当多的内容，需要进一步学习。在光照模型的发展中，首先是Phong光照模型代表的基础光照，仅仅是一种经验模型，只考虑了局部光照，不具备物理特征；发展到PBR以后考虑了物理实际，并且使全局光照得以发展，得到了更真实的物理光照效果。</p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>这里整理下学习资料。</p>
<p>作为PBR入门来说LearnOpenGL中文站给出的<a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">PBR教程</a>还是比较容易接受的，缺点是缺少公式推导；这篇<a href="https://zhuanlan.zhihu.com/p/21376124">知乎</a>讲解了BRDF的由来，推导了Cook-Torrance模型的公式；《Real-Time Rendering 4th》中也有PBR部分教程，有人说是绝世武功，有大量文章索引指导阅读，公式原理都有适合深入学习；GDC，SIGGRAPH等会议也有不错的演讲和文章。</p>
<p>而毛星云大神的博客中还有<a href="https://zhuanlan.zhihu.com/p/53086060">PBR白皮书系列</a>博客，总结了上面书中的PBR部分和其它论文、会议提到的技术，可惜已经无法再见到更新了…</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>五百行C++理解OpenGL机制(一)</title>
    <url>/2023/07/28/tinyRenderer0/</url>
    <content><![CDATA[<p>TinyRenderer是一个计算机图形学课程项目，旨在通过500行的C++代码来自行编写一个渲染器，它能够读取模型，应用纹理，基础光照，以便深入理解OpenGL的运行机制，而不是讲述如何编写OpenGL的应用程序。课程共分为九部分，这里我会根据个人学习的进度来划分，学过Games101的朋友上手会很快。</p>
<p>到最后，我们会将整个项目集合成一个类似shader语法的渲染器，你就可以为所欲为了。</p>
<span id="more"></span>
<h1 id="课前准备"><a href="#课前准备" class="headerlink" title="课前准备"></a>课前准备</h1><p>尽管说是500行就能完成，实际上因为C++不像C#，Python那样有十分方便的库函数，作者也给出了自己编写的工具类，完成三个任务：读取obj模型文件，提供处理二维、三维向量的重载，提供读写tga格式图片的方法。这里我也简单记录一下，看懂语法和逻辑即可。</p>
<p>源文件都可以在作者的<a href="https://github.com/ssloy/tinyrenderer/">github</a>中找到。</p>
<blockquote>
<p>8.1更新：作者第一次课程给出的下列文件和后续是不一致的，下面贴的是第一次给出的文件，建议直接使用最终的版本，总的代码在我自己的<a href="https://github.com/ANKIIMA/Repeat-for-TinyRenderer">github</a>中，我将每节课的主要内容写成单独的class，但是不包括每节课单独的main函数，在博客中大多记录了当时的main，不过完成class后main已经不是难事了，你完全可以自己编写增加理解。</p>
</blockquote>
<h2 id="obj模型的读取"><a href="#obj模型的读取" class="headerlink" title="obj模型的读取"></a>obj模型的读取</h2><p>obj是一类最简单的三维模型文件格式，一个立方体的模型文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Blender v3.1.2 OBJ File: &#x27;&#x27;</span><br><span class="line"># www.blender.org</span><br><span class="line">mtllib mycube.mtl</span><br><span class="line">o Cube</span><br><span class="line">v 1.000000 1.000000 -1.000000</span><br><span class="line">v 1.000000 -1.000000 -1.000000</span><br><span class="line">v 1.000000 1.000000 1.000000</span><br><span class="line">v 1.000000 -1.000000 1.000000</span><br><span class="line">v -1.000000 1.000000 -1.000000</span><br><span class="line">v -1.000000 -1.000000 -1.000000</span><br><span class="line">v -1.000000 1.000000 1.000000</span><br><span class="line">v -1.000000 -1.000000 1.000000</span><br><span class="line">vt 0.625000 0.500000</span><br><span class="line">vt 0.875000 0.500000</span><br><span class="line">vt 0.875000 0.750000</span><br><span class="line">vt 0.625000 0.750000</span><br><span class="line">vt 0.375000 0.750000</span><br><span class="line">vt 0.625000 1.000000</span><br><span class="line">vt 0.375000 1.000000</span><br><span class="line">vt 0.375000 0.000000</span><br><span class="line">vt 0.625000 0.000000</span><br><span class="line">vt 0.625000 0.250000</span><br><span class="line">vt 0.375000 0.250000</span><br><span class="line">vt 0.125000 0.500000</span><br><span class="line">vt 0.375000 0.500000</span><br><span class="line">vt 0.125000 0.750000</span><br><span class="line">vn 0.0000 1.0000 0.0000</span><br><span class="line">vn 0.0000 0.0000 1.0000</span><br><span class="line">vn -1.0000 0.0000 0.0000</span><br><span class="line">vn 0.0000 -1.0000 0.0000</span><br><span class="line">vn 1.0000 0.0000 0.0000</span><br><span class="line">vn 0.0000 0.0000 -1.0000</span><br><span class="line">usemtl Material</span><br><span class="line">s off</span><br><span class="line">f 1/1/1 5/2/1 7/3/1 3/4/1</span><br><span class="line">usemtl Material.001</span><br><span class="line">f 4/5/2 3/4/2 7/6/2 8/7/2</span><br><span class="line">f 8/8/3 7/9/3 5/10/3 6/11/3</span><br><span class="line">f 6/12/4 2/13/4 4/5/4 8/14/4</span><br><span class="line">f 2/13/5 1/1/5 3/4/5 4/5/5</span><br><span class="line">f 6/11/6 5/10/6 1/1/6 2/13/6</span><br></pre></td></tr></table></figure>
<p>文件以行为单位，第一个字符表明该行的用处：</p>
<ul>
<li><h1 id="开头的表示注释"><a href="#开头的表示注释" class="headerlink" title="开头的表示注释"></a>开头的表示注释</h1></li>
<li>mtllib表示外部材质链接库，后面是材质文件的名称</li>
<li>o表示模型名称</li>
<li>v表示vertices，顶点，后面三个数字表示顶点坐标</li>
<li>vt表示顶点的纹理坐标，后面是二维的纹理坐标</li>
<li>vn表示面法向量，后面是法向量具体的值</li>
<li>usemtl表示使用材质库中的材质的名称</li>
<li>s off表示关闭光滑组</li>
<li>f就是面face，后面每组数字表示一个顶点，正方体每个面有四个顶点所以是四组；其中第一个数字是顶点的编号(从1开始)，第二个是该点对应的vt纹理坐标，第三个是该点对应的vn法向量。</li>
</ul>
<p>在目前使用的模型中，我们需要的只是渲染某个面，所以仅读取这个面对应的顶点，绘制三角形即可，所以我们只关心f中每个组第一个数字，以及对应顶点的坐标即可。给出读取方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Model::<span class="built_in">Model</span>(<span class="type">const</span> <span class="type">char</span> *filename) : <span class="built_in">verts_</span>(), <span class="built_in">faces_</span>() &#123;</span><br><span class="line">    std::ifstream in;</span><br><span class="line">    in.<span class="built_in">open</span> (filename, std::ifstream::in);</span><br><span class="line">    <span class="keyword">if</span> (in.<span class="built_in">fail</span>()) <span class="keyword">return</span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (!in.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">getline</span>(in, line);</span><br><span class="line">        <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line.c_str())</span></span>;</span><br><span class="line">        <span class="type">char</span> trash;</span><br><span class="line">        <span class="comment">//v开头</span></span><br><span class="line">        <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;v &quot;</span>)) &#123;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            Vec3f v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) iss &gt;&gt; v.raw[i];</span><br><span class="line">            verts_.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//f开头</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;f &quot;</span>)) &#123;</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">            <span class="type">int</span> itrash, idx;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            <span class="comment">//只要每个面三个点的第一个数字，代表顶点序号</span></span><br><span class="line">            <span class="keyword">while</span> (iss &gt;&gt; idx &gt;&gt; trash &gt;&gt; itrash &gt;&gt; trash &gt;&gt; itrash) &#123;</span><br><span class="line">                idx--; <span class="comment">// in wavefront obj all indices start at 1, not zero</span></span><br><span class="line">                f.<span class="built_in">push_back</span>(idx);</span><br><span class="line">            &#125;</span><br><span class="line">            faces_.<span class="built_in">push_back</span>(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;# v# &quot;</span> &lt;&lt; verts_.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; f# &quot;</span>  &lt;&lt; faces_.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="几何计算"><a href="#几何计算" class="headerlink" title="几何计算"></a>几何计算</h2><p>向量的计算是C++没有提供的，尽管STL提供了一个vector类，仍然没有诸如点乘之类的向量计算，它实际上就是线性表。所以要想处理二维和三维向量，需要使用自己编写的工具类。这里我们要处理的是二维三维向量，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板结构体</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">t</span>&gt; <span class="keyword">struct</span> <span class="title class_">Vec2</span> &#123;</span><br><span class="line">	<span class="comment">//union共享三种类型数据</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;t u, v;&#125;;</span><br><span class="line">		<span class="keyword">struct</span> &#123;t x, y;&#125;;</span><br><span class="line">		t raw[<span class="number">2</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Vec2</span>() : <span class="built_in">u</span>(<span class="number">0</span>), <span class="built_in">v</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">Vec2</span>(t _u, t _v) : <span class="built_in">u</span>(_u),<span class="built_in">v</span>(_v) &#123;&#125;</span><br><span class="line">	<span class="comment">//内联重载操作符处理二维向量，防止函数栈溢出</span></span><br><span class="line">	<span class="keyword">inline</span> Vec2&lt;t&gt; <span class="keyword">operator</span> +(<span class="type">const</span> Vec2&lt;t&gt; &amp;V) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Vec2</span>&lt;t&gt;(u+V.u, v+V.v); &#125;</span><br><span class="line">	<span class="keyword">inline</span> Vec2&lt;t&gt; <span class="keyword">operator</span> -(<span class="type">const</span> Vec2&lt;t&gt; &amp;V) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Vec2</span>&lt;t&gt;(u-V.u, v-V.v); &#125;</span><br><span class="line">	<span class="keyword">inline</span> Vec2&lt;t&gt; <span class="keyword">operator</span> *(<span class="type">float</span> f)          <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Vec2</span>&lt;t&gt;(u*f, v*f); &#125;</span><br><span class="line">	<span class="comment">//友元函数重载&lt;&lt;方便输出</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> &gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; s, Vec2&lt;t&gt;&amp; v);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和上面类似</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">t</span>&gt; <span class="keyword">struct</span> <span class="title class_">Vec3</span> &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;t x, y, z;&#125;;</span><br><span class="line">		<span class="keyword">struct</span> &#123; t ivert, iuv, inorm; &#125;;</span><br><span class="line">		t raw[<span class="number">3</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">Vec3</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">z</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">Vec3</span>(t _x, t _y, t _z) : <span class="built_in">x</span>(_x),<span class="built_in">y</span>(_y),<span class="built_in">z</span>(_z) &#123;&#125;</span><br><span class="line">	<span class="keyword">inline</span> Vec3&lt;t&gt; <span class="keyword">operator</span> ^(<span class="type">const</span> Vec3&lt;t&gt; &amp;v) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Vec3</span>&lt;t&gt;(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); &#125;</span><br><span class="line">	<span class="keyword">inline</span> Vec3&lt;t&gt; <span class="keyword">operator</span> +(<span class="type">const</span> Vec3&lt;t&gt; &amp;v) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Vec3</span>&lt;t&gt;(x+v.x, y+v.y, z+v.z); &#125;</span><br><span class="line">	<span class="keyword">inline</span> Vec3&lt;t&gt; <span class="keyword">operator</span> -(<span class="type">const</span> Vec3&lt;t&gt; &amp;v) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Vec3</span>&lt;t&gt;(x-v.x, y-v.y, z-v.z); &#125;</span><br><span class="line">	<span class="keyword">inline</span> Vec3&lt;t&gt; <span class="keyword">operator</span> *(<span class="type">float</span> f)          <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Vec3</span>&lt;t&gt;(x*f, y*f, z*f); &#125;</span><br><span class="line">	<span class="keyword">inline</span> t       <span class="keyword">operator</span> *(<span class="type">const</span> Vec3&lt;t&gt; &amp;v) <span class="type">const</span> &#123; <span class="keyword">return</span> x*v.x + y*v.y + z*v.z; &#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">norm</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y+z*z); &#125;</span><br><span class="line">	<span class="function">Vec3&lt;t&gt; &amp; <span class="title">normalize</span><span class="params">(t l=<span class="number">1</span>)</span> </span>&#123; *<span class="keyword">this</span> = (*<span class="keyword">this</span>)*(l/<span class="built_in">norm</span>()); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> &gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; s, Vec3&lt;t&gt;&amp; v);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec2&lt;<span class="type">float</span>&gt; Vec2f;</span><br><span class="line"><span class="keyword">typedef</span> Vec2&lt;<span class="type">int</span>&gt;   Vec2i;</span><br><span class="line"><span class="keyword">typedef</span> Vec3&lt;<span class="type">float</span>&gt; Vec3f;</span><br><span class="line"><span class="keyword">typedef</span> Vec3&lt;<span class="type">int</span>&gt;   Vec3i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">t</span>&gt; std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; s, Vec2&lt;t&gt;&amp; v) &#123;</span><br><span class="line">	s &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">t</span>&gt; std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; s, Vec3&lt;t&gt;&amp; v) &#123;</span><br><span class="line">	s &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.z &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中涉及到使用了模板来实现泛型，使用union共享了三种泛型的数据代表向量的值，还有结构体的构造、析构函数，以及内联运算符的重载。具体内容在代码注释，不懂的可以再搜索关键词。</p>
<p>不过这里好像有点问题，我在使用[]运算符对数据操作时会报错，之后作者换了另一个处理向量的头文件供后续使用，这里篇幅原因也不贴了。</p>
<h2 id="TGA文件的读写"><a href="#TGA文件的读写" class="headerlink" title="TGA文件的读写"></a>TGA文件的读写</h2><p>该读写方法的实现就已经达到四百行的规模了，这里也不打算展开，我自己写了一点简单的注释，感兴趣可以到我github上看一眼，暂时以了解功能为主。</p>
<p>代码提供了图片读写、缩放、翻转，以及最关键的给像素点赋值的功能，翻转主要是因为C++中二维数组存储后从(0,0)开始，写图片是也是从(0,0)开始，该点是图片的左上角，所以经过翻转可以让图片以左下角为原点。</p>
<h1 id="Lesson1-直线"><a href="#Lesson1-直线" class="headerlink" title="Lesson1 直线"></a>Lesson1 直线</h1><p>学习过图形学的朋友都知道著名的Bresenham算法，这里我们也会采用该方法实现，但是能够深入地了解为什么使用它。首先我们自己想办法来画一条直线。</p>
<h2 id="自己想方法"><a href="#自己想方法" class="headerlink" title="自己想方法"></a>自己想方法</h2><p>通常会想到迭代的方法，由于x，y都是整数坐标，所以我们可以每次让x+1，计算一个t值代表此时x的进度，y更新为y0+t*(y1-y0)，将这些点全部绘制出来即可，这样的话x长度就决定了迭代的时间。最后得到的图片如下(代码不放了，很简单而且也没什么意义研究)：</p>
<p><img src="/2023/07/28/tinyRenderer0/1.png" alt></p>
<p>放大后明显看到，红色的直线中间断开了，白色的直线是符合预期的。原因在于，当斜率超过tan(PI/4)时，起点和重点的y差值大于x的差值，因此以x为标准来绘制就会使得很多同一个x值不同y值的点跳过。所以我们还需要判断一下，当y的差值大于x时，以y为基准即可，做法就是直接交换起点和重点的x和y，这样在后续计算的时候自然绘制的应该是交换后的(y,x)处的像素，不必做其它修改；</p>
<p>除此外，还有一个问题是，如果我们给出的两个点并不都满足从左下到右上角，按照我们这里遍历的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x=x0; x&lt;=x1; x++) </span><br></pre></td></tr></table></figure>
<p>显然当x0&gt;x1时就直接终止了，所以我们还要判断下大小，将较小的值交换到x0处。这样我们绘制的直线就已经完美地符合预期了。</p>
<p><img src="/2023/07/28/tinyRenderer0/2.png" alt></p>
<p>但是为什么最后不适用它呢？</p>
<p>答案是效率，这种方式中频繁使用乘除法和浮点数，导致运算时间很长，使用性能分析工具可以发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%   cumulative   self              self     total </span><br><span class="line"> time   seconds   seconds    calls  ms/call  ms/call  name </span><br><span class="line"> 69.16      2.95     2.95  3000000     0.00     0.00  line(int, int, int, int, TGAImage&amp;, TGAColor) </span><br><span class="line"> 19.46      3.78     0.83 204000000     0.00     0.00  TGAImage::set(int, int, TGAColor) </span><br><span class="line">  8.91      4.16     0.38 207000000     0.00     0.00  TGAColor::TGAColor(TGAColor const&amp;) </span><br><span class="line">  1.64      4.23     0.07        2    35.04    35.04  TGAColor::TGAColor(unsigned char, unsigned char, unsigned char, unsigned char) </span><br><span class="line">  0.94      4.27     0.04                             TGAImage::get(int, int)</span><br></pre></td></tr></table></figure>
<p>调用line方法的时间占了70%，我们这时就要想办法优化一下了。</p>
<h2 id="开始优化"><a href="#开始优化" class="headerlink" title="开始优化"></a>开始优化</h2><p>这次我们不计算t了，由于x每次加1，y要不要变化则以当前累加的误差为准，误差每次累加斜率k，当累加达到1就让y变换一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawLine::fourthAttempt</span><span class="params">(<span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1, TGAImage&amp; image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (std::<span class="built_in">abs</span>(x0 - x1) &lt; std::<span class="built_in">abs</span>(y0 - y1)) &#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(x0, y0);</span><br><span class="line">		std::<span class="built_in">swap</span>(x1, y1);</span><br><span class="line">		steep = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x0 &gt; x1) &#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(x0, x1);</span><br><span class="line">		std::<span class="built_in">swap</span>(y0, y1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> dx = x1 - x0;</span><br><span class="line">	<span class="type">int</span> dy = y1 - y0;</span><br><span class="line">	<span class="type">float</span> derror = std::<span class="built_in">abs</span>(dy / <span class="built_in">float</span>(dx));</span><br><span class="line">	<span class="type">float</span> error = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y = y0;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = x0; x &lt;= x1; x++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (steep) &#123;</span><br><span class="line">			image.<span class="built_in">set</span>(y, x, color);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			image.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">		&#125;</span><br><span class="line">		error += derror;</span><br><span class="line">		<span class="keyword">if</span> (error &gt; <span class="number">.5</span>) &#123;</span><br><span class="line">			y += (y1 &gt; y0 ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">			error -= <span class="number">1.</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样已经明显减少了时间，我们还可以再进一步，将浮点数k也修改下，error直接和dx比较：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawLine::fifthAttempt</span><span class="params">(<span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1, TGAImage&amp; image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (std::<span class="built_in">abs</span>(x0 - x1) &lt; std::<span class="built_in">abs</span>(y0 - y1)) &#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(x0, y0);</span><br><span class="line">		std::<span class="built_in">swap</span>(x1, y1);</span><br><span class="line">		steep = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x0 &gt; x1) &#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(x0, x1);</span><br><span class="line">		std::<span class="built_in">swap</span>(y0, y1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> dx = x1 - x0;</span><br><span class="line">	<span class="type">int</span> dy = y1 - y0;</span><br><span class="line">	<span class="type">int</span> derror2 = std::<span class="built_in">abs</span>(dy) * <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> error2 = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y = y0;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = x0; x &lt;= x1; x++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (steep) &#123;</span><br><span class="line">			image.<span class="built_in">set</span>(y, x, color);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			image.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">		&#125;</span><br><span class="line">		error2 += derror2;</span><br><span class="line">		<span class="keyword">if</span> (error2 &gt; dx) &#123;</span><br><span class="line">			y += (y1 &gt; y0 ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">			error2 -= dx * <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许他跟你平常见到的Bresenham算法不太一样，但是原理上就是一致的，在我的另一篇博客《图形学知识目录》收录了几种不同的表示，但根本目的就是避免浮点计算，从而大幅提高运行效率：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%   cumulative   self              self     total </span><br><span class="line"> time   seconds   seconds    calls  ms/call  ms/call  name </span><br><span class="line"> 42.77      0.91     0.91 204000000     0.00     0.00  TGAImage::set(int, int, TGAColor) </span><br><span class="line"> 30.08      1.55     0.64  3000000     0.00     0.00  line(int, int, int, int, TGAImage&amp;, TGAColor) </span><br><span class="line"> 21.62      2.01     0.46 204000000     0.00     0.00  TGAColor::TGAColor(int, int) </span><br><span class="line">  1.88      2.05     0.04        2    20.02    20.02  TGAColor::TGAColor(unsigned char, unsigned char, unsigned char, unsigned char) </span><br></pre></td></tr></table></figure>
<p>下一次课程我们学习如何绘制并填充一个三角形。现在我们再让它有趣一点，绘制一个人像的线框。使用前面的工具类得到模型的顶点和面信息，然后绘制每个三角形面的三条边即可。由于模型顶点是三维的，我们需要将它转换为二维坐标，方法就是忽略代表深度的Z轴，并将xy值从[-1,1]投影到[0,width-1]和[0,height-1]即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;model-&gt;<span class="built_in">nfaces</span>(); i++) &#123; </span><br><span class="line">    <span class="comment">//获取面信息</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; face = model-&gt;<span class="built_in">face</span>(i); </span><br><span class="line">    <span class="comment">//遍历三条边并绘制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123; </span><br><span class="line">        Vec3f v0 = model-&gt;<span class="built_in">vert</span>(face[j]); </span><br><span class="line">        Vec3f v1 = model-&gt;<span class="built_in">vert</span>(face[(j+<span class="number">1</span>)%<span class="number">3</span>]); </span><br><span class="line">        <span class="type">int</span> x0 = (v0.x+<span class="number">1.</span>)*width/<span class="number">2.</span>; </span><br><span class="line">        <span class="type">int</span> y0 = (v0.y+<span class="number">1.</span>)*height/<span class="number">2.</span>; </span><br><span class="line">        <span class="type">int</span> x1 = (v1.x+<span class="number">1.</span>)*width/<span class="number">2.</span>; </span><br><span class="line">        <span class="type">int</span> y1 = (v1.y+<span class="number">1.</span>)*height/<span class="number">2.</span>; </span><br><span class="line">        <span class="built_in">line</span>(x0, y0, x1, y1, image, white); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将该代码添加到main中，并修改以适应自己的代码，得到下面的结果：</p>
<p><img src="/2023/07/28/tinyRenderer0/3.png" alt></p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Graphics API</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>五百行C++理解OpenGL机制(二)</title>
    <url>/2023/07/31/tinyRenderer1/</url>
    <content><![CDATA[<p>这次课程我们来想办法绘制三角形，也就是著名的光栅化，介绍两种方法实现，扫描线法和重心坐标法。Games101中使用的方法和这里介绍的不同，后面再具体说明。</p>
<span id="more"></span>
<h1 id="Lesson2-三角形"><a href="#Lesson2-三角形" class="headerlink" title="Lesson2 三角形"></a>Lesson2 三角形</h1><p>作为最基本的图形学片元，现在学会绘制三角形可以说就已经学会大半图形学基础内容了。因为所有的模型几乎都是采用三角形作为一个面，哪怕是正方体看起来有六个四边形作为面，实际上四边形也可以拆分成两个三角形，这就是为什么三角形如此重要。</p>
<p>我们先学习如何用扫描线绘制三角形，再看看现在普遍的做法。</p>
<h2 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h2><p>顾名思义，我们按行绘制三角形像素，因此每次都要确定三角形的边界在哪里。通过观察不难发现，无论三角形怎么摆放，你始终可以将三角形根据过中间顶点的水平线将三角形分成上下两个部分，除非三角形的某条边保持水平，但即便这样我们依然可以采用该方法。</p>
<p>首先回想我们如何绘制直线的，按照行或列的像素进行迭代，并选择较长的一边为基准，现在我们可以通过绘制三角形的边界来找到每一行对应的边界。</p>
<p>注意，此时我们不需要选择较长的一方作为基准了，因为我们后面会完全填充整个三角形，之前画线可能出现的holes也不会是问题。</p>
<p><img src="/2023/07/31/tinyRenderer1/1.png" alt></p>
<p>具体来说，不论输入顺序如何，将y按升序排列，我们按照y值迭代每行像素，根据此时y的大小分别计算从最低点到中间点、最高点两条边的进度alpha和beta，然后计算该行上两条边的x在什么位置，然后从左绘制到右边，就完成了一行三角形的绘制。</p>
<p>当绘制完下半部分，或者下半部分不存在(底边平行的情况)，就要更改计算边界的方式，因为此时要开始绘制另一条边，而最低点到最高点的边还在继续绘制，不用更改，下面是代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Triangle::old_DrawTriangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage&amp; image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t0.y == t1.y &amp;&amp; t0.y == t2.y) <span class="keyword">return</span>; <span class="comment">// I dont care about degenerate triangles </span></span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t1.y) std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t2.y) std::<span class="built_in">swap</span>(t0, t2);</span><br><span class="line">	<span class="keyword">if</span> (t1.y &gt; t2.y) std::<span class="built_in">swap</span>(t1, t2);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> height = t2.y - t0.y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">bool</span> second_half = i &gt;= t1.y - t0.y;</span><br><span class="line">		<span class="type">int</span> currentHeight = second_half ? t2.y - t1.y : t1.y - t0.y;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//alpha:t0-t2</span></span><br><span class="line">		<span class="comment">//beta:second_half时，i应减去第一段高度并除以第二段的高度</span></span><br><span class="line">		<span class="type">float</span> alpha = (<span class="type">float</span>)i / height;</span><br><span class="line">		<span class="type">float</span> beta = (<span class="type">float</span>)(i - (second_half ? t1.y - t0.y : <span class="number">0</span>)) / currentHeight;</span><br><span class="line">		Vec2i A = t0 + (t2 - t0) * alpha;</span><br><span class="line">		Vec2i B = second_half ? t1 + (t2 - t1) * beta : t0 + (t1 - t0) * beta;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (A.x &gt; B.x)</span><br><span class="line">		&#123;</span><br><span class="line">			std::<span class="built_in">swap</span>(A, B);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = A.x; j &lt;= B.x; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			image.<span class="built_in">set</span>(j, t0.y + i, color);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绘制的三角形如下：</p>
<p><img src="/2023/07/31/tinyRenderer1/2.png" alt></p>
<h2 id="重心坐标法"><a href="#重心坐标法" class="headerlink" title="重心坐标法"></a>重心坐标法</h2><p>然后我们稍微介绍一下重心坐标，对于平面上一点P，必定有三个数$w_1,w_2,w_3$满足$w_1+w_2+w_3=1$，且$P = w_1<em>A+w_2</em>B+w_3*C$，三维向量$(w_1,w_2,w_3)$就是在该三角形上点P的重心坐标。</p>
<p>如果A的质量是$w_1$，B的质量是$w_2$，C的质量是$w_3$，那么在P点提起线来三角形就能平衡住。</p>
<p>重心坐标有很多用处，可以用来计算三角形中各点的各种插值，软光栅化，以及光线追踪，还有这里判断像素点是否在三角形内部。</p>
<p>为什么要判断？该方法的做法是，将三角形的长方形包围盒求出来，我们能快速地找到长方形的左下角和右上角，然后遍历其中每个像素，判断像素是否在三角形中，如果是则光栅化，否则跳过。</p>
<p>给定点P，我们先想办法求出P的重心坐标。根据前面定义我们知道，$w_1=1-w_2-w_3$，又$\vec{AB}=B-A$，可以得到公式$P=A+w_2<em>\vec{AB}+w_3</em>\vec{AC}$，P移项到右边：$w_2<em>\vec{AB}+w_3</em>\vec{AC}+\vec{PA}=0$，它们全是二维向量，也就是说现在有向量$(w_2,w_3,1)$同时和向量$(\vec{AB_x},\vec{AC_x},\vec{PA_x})$，$(\vec{AB_y},\vec{AC_y},\vec{PA_y})$的点积为零，也就是和这两个向量同时垂直。</p>
<p>所以我们计算后面两个向量的叉乘得到它们的法向量，用z轴的值归一化以后就得到$(w_2,w_3,1)$，那么重心坐标就求出来了。</p>
<p>通过重心坐标的定义可以知道，如果P点在三角形内部，那么$(w_1,w_2,w_3)$应当全部大于0，有一个值等于0说明三角形退化了，小于0说明此时重心在三角形外部。</p>
<p>所以我们通过判断重心坐标的正负就判断了P点的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">Triangle::barycentric</span><span class="params">(Vec2i* pts, Vec2i p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ABx = (pts[<span class="number">1</span>].x - pts[<span class="number">0</span>].x);</span><br><span class="line">	<span class="type">int</span> ABy = (pts[<span class="number">1</span>].y - pts[<span class="number">0</span>].y);</span><br><span class="line">	<span class="type">int</span> ACx = (pts[<span class="number">2</span>].x - pts[<span class="number">0</span>].x);</span><br><span class="line">	<span class="type">int</span> ACy = (pts[<span class="number">2</span>].y - pts[<span class="number">0</span>].y);</span><br><span class="line">	<span class="type">int</span> PAx = (pts[<span class="number">0</span>].x - p.x);</span><br><span class="line">	<span class="type">int</span> PAy = (pts[<span class="number">0</span>].y - p.y);</span><br><span class="line"></span><br><span class="line">	Vec3f u = <span class="built_in">Vec3f</span>(ABx, ACx, PAx) ^ <span class="built_in">Vec3f</span>(ABy, ACy, PAy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//z小于1即z=0，此时三角形退化，AB AC在一条直线上</span></span><br><span class="line">	<span class="keyword">if</span> (std::<span class="built_in">abs</span>(u.z) &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">1.f</span> - (u.x + u.y) / u.z, u.x / u.z, u.y / u.z);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Games101中，做法是采用三个叉积来判断，当然不如这里有效率，但是比较直观，当点在三角形内部，三个顶点和它的连线向量以及三条边向量分别的叉积都大于0，否则不在三角形内部，具体可以查看Games101博客中第二篇。</p>
<p>那么判断三角形内部就有两种方法了，重心坐标法是最快的。</p>
<p>回到三角形的光栅化，你已经学会了最关键的步骤，下面的代码就不是难事了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">![<span class="number">3</span>](tinyRenderer1/<span class="number">3.</span>png)<span class="function"><span class="type">void</span> <span class="title">Triangle::new_DrawTriangle</span><span class="params">(Vec2i* pts, TGAImage&amp; image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Vec2i <span class="title">bboxmin</span><span class="params">(image.get_width() - <span class="number">1</span>, image.get_height() - <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">Vec2i <span class="title">bboxmax</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function">Vec2i <span class="title">clamp</span><span class="params">(image.get_width() - <span class="number">1</span>, image.get_height() - <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="comment">//找到bounding box的大小</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		bboxmin.x = std::<span class="built_in">max</span>(<span class="number">0</span>, std::<span class="built_in">min</span>(bboxmin.x, pts[i].x));</span><br><span class="line">		bboxmin.y = std::<span class="built_in">max</span>(<span class="number">0</span>, std::<span class="built_in">min</span>(bboxmin.y, pts[i].y));</span><br><span class="line"></span><br><span class="line">		bboxmax.x = std::<span class="built_in">min</span>(clamp.x, std::<span class="built_in">max</span>(bboxmax.x, pts[i].x));</span><br><span class="line">		bboxmax.y = std::<span class="built_in">min</span>(clamp.y, std::<span class="built_in">max</span>(bboxmax.y, pts[i].y));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐个判断bbox中的像素是否在三角形中</span></span><br><span class="line">	Vec2i p;</span><br><span class="line">	<span class="keyword">for</span> (p.x = bboxmin.x; p.x &lt;= bboxmax.x; p.x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (p.y = bboxmin.y; p.y &lt;= bboxmax.y; p.y++)</span><br><span class="line">		&#123;</span><br><span class="line">			Vec3f bc_screen = <span class="built_in">baricentric</span>(pts, p);</span><br><span class="line">			<span class="keyword">if</span> (bc_screen.x &lt; <span class="number">0</span> || bc_screen.y &lt; <span class="number">0</span> || bc_screen.z &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			image.<span class="built_in">set</span>(p.x, p.y, color);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它得到的效果和刚才我们使用旧方法的效果几乎一致，可以忽略这点略微的不同。</p>
<p><img src="/2023/07/31/tinyRenderer1/3.png" alt></p>
<h2 id="绘制模型的线框"><a href="#绘制模型的线框" class="headerlink" title="绘制模型的线框"></a>绘制模型的线框</h2><p>下面我们让它变得更有意思一些，作者给出了自己的脸部模型，下面我们将要绘制出脸部的模型面。首先用之前介绍的工具类完成模型顶点和面的提取，由于模型是三维的，这里我们渲染正面就不需要z值了(在这里z轴以屏幕为原点向里)，直接忽略并保存xy。xy转换到屏幕坐标也只需要改变它们的映射空间，从[-1,1]修改到[0,width-1]和[0,height-1]，即加一乘以像素宽度/高度并除以2。</p>
<p>让每个三角形的颜色保持随机，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i=0; i&lt;model-&gt;nfaces(); i++) &#123; </span><br><span class="line">    std::vector&lt;int&gt; face = model-&gt;face(i); </span><br><span class="line">    Vec2i screen_coords[3]; </span><br><span class="line">    for (int j=0; j&lt;3; j++) &#123; </span><br><span class="line">        Vec3f world_coords = model-&gt;vert(face[j]); </span><br><span class="line">        screen_coords[j] = Vec2i((world_coords.x+1.)*width/2., (world_coords.y+1.)*height/2.); </span><br><span class="line">    &#125; </span><br><span class="line">    triangle(screen_coords[0], screen_coords[1], screen_coords[2], image, TGAColor(rand()%255, rand()%255, rand()%255, 255)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你需要稍微修改一下以让它适应你自己的代码，得到下面的结果：</p>
<p><img src="/2023/07/31/tinyRenderer1/4.png" alt></p>
<p>它是杂乱无章的，因为没有使用深度测试来消除一些不可见面，渲染完全由顺序主导，下一节我们再解决这个问题。现在我们稍微引入一点光照知识，学过Games101或了解过基础光照的朋友理解起来就很轻松了，这里让光照方向设置为$(0,0,-1)$，也就是垂直屏幕向内，一个面接受的光照强度和该面向外的法向量和光线方向的夹角成反比，也就是点积越大光照越弱。</p>
<p>一个三角形的法向量可以用叉积来计算，这里按照读取出来的顺序计算AC，AB的叉积就是向外的法向量，用它和光照点乘作为光照强度，乘以颜色值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">light_dir</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">2</span> == argc) &#123;</span><br><span class="line">		model = <span class="keyword">new</span> <span class="built_in">Model</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		model = <span class="keyword">new</span> <span class="built_in">Model</span>(<span class="string">&quot;obj/african_head.obj&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">TGAImage <span class="title">image</span><span class="params">(width, height, TGAImage::RGB)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model-&gt;<span class="built_in">nfaces</span>(); i++) &#123;</span><br><span class="line">		<span class="comment">//存储三个顶点编号</span></span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; face = model-&gt;<span class="built_in">face</span>(i);</span><br><span class="line">		Vec2i screen_coords[<span class="number">3</span>];</span><br><span class="line">		Vec3f world_coords[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			<span class="comment">//根据编号返回顶点坐标</span></span><br><span class="line">			Vec3f v = model-&gt;<span class="built_in">vert</span>(face[j]);</span><br><span class="line">			<span class="comment">//转换为二维坐标</span></span><br><span class="line">			screen_coords[j] = <span class="built_in">Vec2i</span>((v.x + <span class="number">1.</span>) * width / <span class="number">2.</span>, (v.y + <span class="number">1.</span>) * height / <span class="number">2.</span>);</span><br><span class="line">			world_coords[j] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		Vec3f normal = (world_coords[<span class="number">2</span>] - world_coords[<span class="number">0</span>]) ^ (world_coords[<span class="number">1</span>] - world_coords[<span class="number">0</span>]);</span><br><span class="line">		normal.<span class="built_in">normalize</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">float</span> intensity = normal * light_dir;</span><br><span class="line">		<span class="keyword">if</span> (intensity &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Triangle::<span class="built_in">new_DrawTriangle</span>(screen_coords, image, <span class="built_in">TGAColor</span>(intensity * <span class="number">255</span>, intensity * <span class="number">255</span>, intensity * <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	image.<span class="built_in">flip_vertically</span>(); <span class="comment">// i want to have the origin at the left bottom corner of the image</span></span><br><span class="line">	image.<span class="built_in">write_tga_file</span>(<span class="string">&quot;output.tga&quot;</span>);</span><br><span class="line">	<span class="keyword">delete</span> model;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样记得修改代码以适应自己的部分。得到效果如下：</p>
<p><img src="/2023/07/31/tinyRenderer1/6.png" alt></p>
<p>注意这里我们没有绘制出模型背面的面，因为在上面的代码中，当光照方向和法线方向的点积为负，也就是光线方向和法线方向的夹角超过180度后，我们简单地抛弃了它们，这就是一种简单的背面剔除。同样因为没有深度测试有地方渲染不正确，而且因为没有插值，和前面一样是Flat着色方式，下一次我们将修复这两个问题。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Graphics API</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>五百行C++理解OpenGL机制(三)</title>
    <url>/2023/08/01/tinyRenderer2/</url>
    <content><![CDATA[<p>继光栅化之后的一大问题是，如何判断每个面谁被渲染，谁被遮挡。前一节的工作中我们绘制了所有的三角形面，但是并没有判断遮挡关系，也没有插值处理像素，这次我们解决这两个问题。</p>
<span id="more"></span>
<h1 id="Lesson-3"><a href="#Lesson-3" class="headerlink" title="Lesson 3"></a>Lesson 3</h1><h2 id="Z-buffer"><a href="#Z-buffer" class="headerlink" title="Z-buffer"></a>Z-buffer</h2><p>我们的渲染器初具规模，现在终于可以学习大名鼎鼎的Z-buffer了。首先我们先简述一下画家算法，它也是一种判断遮挡关系的简单算法，因为我们绘制是直接对像素进行赋值，所以可以想到从后往前绘制的话就能得到相对正确的渲染结果了。但是为什么说是相对正确呢？看下面这个图片：</p>
<p><img src="/2023/08/01/tinyRenderer2/1.png" alt></p>
<p>如果我们从上往下看这个场景，渲染结果应该是这样的：</p>
<p><img src="/2023/08/01/tinyRenderer2/2.png" alt></p>
<p>发现问题了吗？如果使用画家算法，无法处理两个平面交叉时的情况，因为它们的遮挡关系不是不变的，上图中如果使用画家算法，先绘制红色三角形，然后绘制蓝色三角形，最后绘制绿色三角形，显然绿色三角形将会覆盖蓝色三角形，而不会呈现上图中交叉的正确结果。</p>
<p>因此我们需要采用一个buffer来存储具体像素而不是面的深度信息，以屏幕为原点Z轴正方向向里，在绘制像素时，只有当缓冲区中的深度信息大于像素的深度信息，才允许更新当前像素的颜色和深度值。buffer大小为总的像素数，初始化值为最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lesson3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> TGAColor white = <span class="built_in">TGAColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line"><span class="type">const</span> TGAColor red = <span class="built_in">TGAColor</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="type">const</span> TGAColor green = <span class="built_in">TGAColor</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">Model* model = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> width = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> height = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3f <span class="title">light_dir</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3f <span class="title">world2screen</span><span class="params">(Vec3f v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="built_in">int</span>((v.x + <span class="number">1.</span>) * width / <span class="number">2.</span> + <span class="number">.5</span>), <span class="built_in">int</span>((v.y + <span class="number">1.</span>) * height / <span class="number">2.</span> + <span class="number">.5</span>), v.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">2</span> == argc) &#123;</span><br><span class="line">		model = <span class="keyword">new</span> <span class="built_in">Model</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		model = <span class="keyword">new</span> <span class="built_in">Model</span>(<span class="string">&quot;obj/african_head.obj&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化深度缓冲</span></span><br><span class="line">	<span class="type">float</span>* zbuffer = <span class="keyword">new</span> <span class="type">float</span>[width * height];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = width * height; i--; zbuffer[i] = -std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">	<span class="function">TGAImage <span class="title">image</span><span class="params">(width, height, TGAImage::RGB)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model-&gt;<span class="built_in">nfaces</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; face = model-&gt;<span class="built_in">face</span>(i);</span><br><span class="line">		Vec3f pts[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			pts[j] = <span class="built_in">world2screen</span>(model-&gt;<span class="built_in">vert</span>(face[j]));</span><br><span class="line">		&#125;</span><br><span class="line">		Triangle_ZBuffer::<span class="built_in">Triangle</span>(pts, zbuffer, image, <span class="built_in">TGAColor</span>(<span class="built_in">rand</span>() % <span class="number">255</span>, <span class="built_in">rand</span>() % <span class="number">255</span>, <span class="built_in">rand</span>() % <span class="number">255</span>, <span class="number">255</span>), width);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	image.<span class="built_in">flip_vertically</span>(); <span class="comment">// i want to have the origin at the left bottom corner of the image</span></span><br><span class="line">	image.<span class="built_in">write_tga_file</span>(<span class="string">&quot;output.tga&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">delete</span> model;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们修改了一下之前绘制三角形的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Triangle_ZBuffer::Triangle</span><span class="params">(Vec3f* pts, <span class="type">float</span>* zbuffer, TGAImage&amp; image, TGAColor color, <span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Vec2f <span class="title">bboxmin</span><span class="params">(std::numeric_limits&lt;<span class="type">float</span>&gt;::max(), std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br><span class="line">	<span class="function">Vec2f <span class="title">bboxmax</span><span class="params">(-std::numeric_limits&lt;<span class="type">float</span>&gt;::max(), -std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br><span class="line">	<span class="function">Vec2f <span class="title">clamp</span><span class="params">(image.get_width() - <span class="number">1</span>, image.get_height() - <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="comment">//找到bounding box的大小</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">			bboxmin[j] = std::<span class="built_in">max</span>(<span class="number">0.f</span>, std::<span class="built_in">min</span>(bboxmin[j], pts[i][j]));</span><br><span class="line">			bboxmax[j] = std::<span class="built_in">min</span>(clamp[j], std::<span class="built_in">max</span>(bboxmax[j], pts[i][j]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐个判断bbox中的像素是否在三角形中</span></span><br><span class="line">	Vec3f p;</span><br><span class="line">	<span class="keyword">for</span> (p.x = bboxmin.x; p.x &lt;= bboxmax.x; p.x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (p.y = bboxmin.y; p.y &lt;= bboxmax.y; p.y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//p点重心坐标</span></span><br><span class="line">			Vec3f bc_screen = <span class="built_in">barycentric</span>(pts, p);</span><br><span class="line">			<span class="comment">//不在三角形内</span></span><br><span class="line">			<span class="keyword">if</span> (bc_screen.x &lt; <span class="number">0</span> || bc_screen.y &lt; <span class="number">0</span> || bc_screen.z &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			p.z = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//插值计算p的深度，后面会细说</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) p.z += pts[i][<span class="number">2</span>] * bc_screen[i];</span><br><span class="line">			<span class="comment">//深度值大于当前缓存值</span></span><br><span class="line">			<span class="keyword">if</span> (zbuffer[<span class="built_in">int</span>(p.x + p.y * width)] &lt; p.z)</span><br><span class="line">			&#123;</span><br><span class="line">				zbuffer[<span class="built_in">int</span>(p.x + p.y * width)] = p.z;</span><br><span class="line">				image.<span class="built_in">set</span>(p.x, p.y, color);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了深度缓冲之后，我们就可以避免之前的错误渲染顺序了，下面是得到的结果：</p>
<p><img src="/2023/08/01/tinyRenderer2/3.png" alt></p>
<p>如果你想使用上次课程中简单的光照模拟自然也不是问题，计算的方法和上次完全一致：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model-&gt;<span class="built_in">nfaces</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; face = model-&gt;<span class="built_in">face</span>(i);</span><br><span class="line">		Vec3f pts[<span class="number">3</span>];</span><br><span class="line">		Vec3f world_coords[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			pts[j] = <span class="built_in">world2screen</span>(model-&gt;<span class="built_in">vert</span>(face[j]));</span><br><span class="line">			world_coords[j] = model-&gt;<span class="built_in">vert</span>(face[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		Vec3f normal = <span class="built_in">cross</span>(<span class="built_in">Vec3f</span>(world_coords[<span class="number">2</span>] - world_coords[<span class="number">0</span>]), <span class="built_in">Vec3f</span>(world_coords[<span class="number">1</span>] - world_coords[<span class="number">0</span>])).<span class="built_in">normalize</span>();</span><br><span class="line">		<span class="type">float</span> intensity = normal * light_dir;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(intensity &gt; <span class="number">0</span>)</span><br><span class="line">			Triangle_ZBuffer::<span class="built_in">Triangle</span>(pts, zbuffer, image, <span class="built_in">TGAColor</span>(intensity * <span class="number">255</span>, intensity * <span class="number">255</span>, intensity * <span class="number">255</span>, <span class="number">255</span>), width);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>完成的效果是下面这样的，对比上次的结果，我们这次把不同的面都正确绘制出来了，尤其是嘴巴。</p>
<p><img src="/2023/08/01/tinyRenderer2/4.png" alt></p>
<h2 id="插值计算和纹理"><a href="#插值计算和纹理" class="headerlink" title="插值计算和纹理"></a>插值计算和纹理</h2><p>阅读代码后你肯定注意到，前面的部分我们为了获得每个像素单独的深度值，实际上是先计算p的重心坐标，根据这个面上三个顶点的深度值进行插值得到了p点的深度值。这是就不得不说到另一部分重要的知识：纹理。</p>
<p>这里不再具体讲原理了，之前说obj文件格式的时候提到里面存储了一个vt开头的行，就是代表纹理坐标，顶点将读取坐标找到纹理图中的颜色，作为该顶点的颜色。那么有了三个顶点的颜色之后，我们自然可以通过对三个顶点的颜色插值得到像素点的颜色了。注意我们不是对纹理坐标进行插值，我不能确定它是否正确，因为某些模型的纹理坐标并不保证是连续的，对颜色插值是最保险的方法。</p>
<p>这部分是作者给出的作业，并没有实例代码，所以简单说下思路：读取表示obj模型一个面的数据，它的形式大概是：f x/x/x x/x/x x/x/x，第一个x是顶点序号，第二个x是顶点对应的纹理坐标序号，首先要想办法把这个值读出来；之后在main中调用前面写的方法得到纹理坐标，它范围是[0,1]，读取颜色的话需要先用tga读纹理图，出来是一个二维数组，那么纹理坐标的xy分别乘以宽高，得到的就是一个TGAColor值，存储三个顶点的颜色，然后插值，再乘以光照强度，最后就是颜色了。</p>
<p>我们一步一步来实现。</p>
<h3 id="读取纹理坐标"><a href="#读取纹理坐标" class="headerlink" title="读取纹理坐标"></a>读取纹理坐标</h3><p>Model类中原来只写了读取顶点和边的构造函数，我们修改其中的内容，添加私有变量texcoord_，然后同样构造函数中赋值。注意两个地方，第一由于行开头是vt，trash要收集两次；第二obj文件中纹理坐标还是三维的，只不过第三维是0，所以要声明为Vec3f。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Model::<span class="built_in">Model</span>(<span class="type">const</span> <span class="type">char</span> *filename) : <span class="built_in">verts_</span>(), <span class="built_in">faces_</span>() &#123;</span><br><span class="line">    std::ifstream in;</span><br><span class="line">    in.<span class="built_in">open</span> (filename, std::ifstream::in);</span><br><span class="line">    <span class="keyword">if</span> (in.<span class="built_in">fail</span>()) <span class="keyword">return</span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (!in.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">getline</span>(in, line);</span><br><span class="line">        <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line.c_str())</span></span>;</span><br><span class="line">        <span class="type">char</span> trash;</span><br><span class="line">        <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;v &quot;</span>)) &#123;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            Vec3f v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) iss &gt;&gt; v[i];</span><br><span class="line">            verts_.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;f &quot;</span>)) &#123;</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt; ft;</span><br><span class="line">            <span class="type">int</span> itrash, idx, texidx;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            <span class="comment">//f x/x/x</span></span><br><span class="line">            <span class="keyword">while</span> (iss &gt;&gt; idx &gt;&gt; trash &gt;&gt; texidx &gt;&gt; trash &gt;&gt; itrash) &#123;</span><br><span class="line">                idx--; <span class="comment">// in wavefront obj all indices start at 1, not zero</span></span><br><span class="line">                f.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                ft.<span class="built_in">push_back</span>(texidx);</span><br><span class="line">            &#125;</span><br><span class="line">            faces_.<span class="built_in">push_back</span>(f);</span><br><span class="line">            faces_tex_.<span class="built_in">push_back</span>(ft);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vt &quot;</span>)) &#123;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            iss &gt;&gt; trash;</span><br><span class="line">            Vec3f vt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) iss &gt;&gt; vt[i];</span><br><span class="line">            texcoords_.<span class="built_in">push_back</span>(vt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;# v# &quot;</span> &lt;&lt; verts_.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; f# &quot;</span>  &lt;&lt; faces_.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我增加了两个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储面对应的三个纹理坐标序号</span></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; faces_tex_;</span><br><span class="line"><span class="comment">//存储纹理坐标</span></span><br><span class="line">std::vector&lt;Vec3f&gt; texcoords_;</span><br></pre></td></tr></table></figure>
<p>然后给出返回纹理坐标的方法，注意在返回对应纹理坐标序号的纹理坐标时，texidx要减少1，因为obj中序号从1开始，而我们的数组从0开始。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个面三个顶点对应的纹理坐标序号</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">Model::faceTex</span><span class="params">(<span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> faces_tex_[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回对应纹理坐标序号的纹理坐标</span></span><br><span class="line"><span class="function">Vec2f <span class="title">Model::texcoord</span><span class="params">(<span class="type">int</span> texidx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec2f</span>(texcoords_[texidx - <span class="number">1</span>][<span class="number">0</span>], texcoords_[texidx - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回纹理颜色"><a href="#返回纹理颜色" class="headerlink" title="返回纹理颜色"></a>返回纹理颜色</h3><p>阅读TGA读写的方法，其中给出一个get方法用来返回像素(i,j)的颜色，所以我们这里编写一个Texture类，提供返回像素颜色的方法。注意读取图片后我对图片数据进行了垂直反转，因为数据存储颜色从图片的左上角开始，纹理坐标原点是左下角，因此需要将它上下反转。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取纹理图片</span></span><br><span class="line">Texture::<span class="built_in">Texture</span>(<span class="type">const</span> <span class="type">char</span>* filename)</span><br><span class="line">&#123;</span><br><span class="line">	texture.<span class="built_in">read_tga_file</span>(filename);</span><br><span class="line">	texture.<span class="built_in">flip_vertically</span>();</span><br><span class="line">	width = texture.<span class="built_in">get_width</span>();</span><br><span class="line">	height = texture.<span class="built_in">get_height</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回纹理颜色</span></span><br><span class="line">TGAColor Texture:: <span class="built_in">texColor</span>(Vec2f texcoord)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> texture.<span class="built_in">get</span>(<span class="built_in">int</span>(texcoord.x * (width)), <span class="built_in">int</span>(texcoord.y * (height)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插值计算像素颜色"><a href="#插值计算像素颜色" class="headerlink" title="插值计算像素颜色"></a>插值计算像素颜色</h3><p>现在通过调用纹理类，我们可以得到每个面的三个顶点的纹理颜色，对颜色进行插值，最后就能计算当前像素的颜色值了。而插值是在绘制三角形的时候，遍历每个包围盒中的像素，才能得到像素对应的重心坐标，因此现在像素颜色将由绘制三角形的方法决定，我们取消之前传入颜色的做法，将光照强度和该三角形三个顶点的颜色传入，再进行插值。</p>
<p>值得注意的是，常见的方法应该是通过对三个顶点的纹理坐标进行插值，根据插值得到的纹理坐标映射找到纹理颜色，作为像素的颜色。不过这种方法我们后续也会使用，所以这里我选择对颜色进行插值，这种方法得到的结果显然不如纹理映射得到的效果好，特点在于平滑了颜色值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lesson3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> TGAColor white = <span class="built_in">TGAColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line"><span class="type">const</span> TGAColor red = <span class="built_in">TGAColor</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="type">const</span> TGAColor green = <span class="built_in">TGAColor</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">Model* model = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> width = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> height = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3f <span class="title">light_dir</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3f <span class="title">world2screen</span><span class="params">(Vec3f v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="built_in">int</span>((v.x + <span class="number">1.</span>) * width / <span class="number">2.</span> + <span class="number">.5</span>), <span class="built_in">int</span>((v.y + <span class="number">1.</span>) * height / <span class="number">2.</span> + <span class="number">.5</span>), v.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">2</span> == argc) &#123;</span><br><span class="line">		model = <span class="keyword">new</span> <span class="built_in">Model</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		model = <span class="keyword">new</span> <span class="built_in">Model</span>(<span class="string">&quot;obj/african_head.obj&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化深度缓冲</span></span><br><span class="line">	<span class="type">float</span>* zbuffer = <span class="keyword">new</span> <span class="type">float</span>[width * height];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = width * height; i--; zbuffer[i] = -std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">	<span class="function">TGAImage <span class="title">image</span><span class="params">(width, height, TGAImage::RGB)</span></span>;</span><br><span class="line">	<span class="comment">//初始化纹理</span></span><br><span class="line">	<span class="function">Texture <span class="title">tex</span><span class="params">(<span class="string">&quot;obj/african_head/african_head_diffuse.tga&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model-&gt;<span class="built_in">nfaces</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//面对应的顶点序号</span></span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; face = model-&gt;<span class="built_in">face</span>(i);</span><br><span class="line">		<span class="comment">//面对应的纹理序号</span></span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; faceTex = model-&gt;<span class="built_in">faceTex</span>(i);</span><br><span class="line">		<span class="comment">//顶点坐标</span></span><br><span class="line">		Vec3f pts[<span class="number">3</span>];</span><br><span class="line">		<span class="comment">//三个顶点的纹理坐标</span></span><br><span class="line">		Vec2f ptstex[<span class="number">3</span>];</span><br><span class="line">		Vec3f world_coords[<span class="number">3</span>];</span><br><span class="line">		TGAColor vertColors[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			pts[j] = <span class="built_in">world2screen</span>(model-&gt;<span class="built_in">vert</span>(face[j]));</span><br><span class="line">			ptstex[j] = model-&gt;<span class="built_in">texcoord</span>(faceTex[j]);</span><br><span class="line">			world_coords[j] = model-&gt;<span class="built_in">vert</span>(face[j]);</span><br><span class="line"></span><br><span class="line">			vertColors[j] = tex.<span class="built_in">texColor</span>(ptstex[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		Vec3f normal = <span class="built_in">cross</span>(<span class="built_in">Vec3f</span>(world_coords[<span class="number">2</span>] - world_coords[<span class="number">0</span>]), <span class="built_in">Vec3f</span>(world_coords[<span class="number">1</span>] - world_coords[<span class="number">0</span>])).<span class="built_in">normalize</span>();</span><br><span class="line">		<span class="type">float</span> intensity = normal * light_dir;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(intensity &gt; <span class="number">0</span>)</span><br><span class="line">			Triangle_ZBuffer::<span class="built_in">Triangle</span>(pts, zbuffer, image, intensity, width, vertColors);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	image.<span class="built_in">flip_vertically</span>(); <span class="comment">// i want to have the origin at the left bottom corner of the image</span></span><br><span class="line">	image.<span class="built_in">write_tga_file</span>(<span class="string">&quot;output.tga&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">delete</span> model;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后记得修改绘制三角形的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Triangle_ZBuffer::Triangle</span><span class="params">(Vec3f* pts, <span class="type">float</span>* zbuffer, TGAImage&amp; image, <span class="type">float</span> intensity, <span class="type">int</span> width, TGAColor* vertColors)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Vec2f <span class="title">bboxmin</span><span class="params">(std::numeric_limits&lt;<span class="type">float</span>&gt;::max(), std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br><span class="line">	<span class="function">Vec2f <span class="title">bboxmax</span><span class="params">(-std::numeric_limits&lt;<span class="type">float</span>&gt;::max(), -std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br><span class="line">	<span class="function">Vec2f <span class="title">clamp</span><span class="params">(image.get_width() - <span class="number">1</span>, image.get_height() - <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="comment">//找到bounding box的大小</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">			bboxmin[j] = std::<span class="built_in">max</span>(<span class="number">0.f</span>, std::<span class="built_in">min</span>(bboxmin[j], pts[i][j]));</span><br><span class="line">			bboxmax[j] = std::<span class="built_in">min</span>(clamp[j], std::<span class="built_in">max</span>(bboxmax[j], pts[i][j]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐个判断bbox中的像素是否在三角形中</span></span><br><span class="line">	Vec3f p;</span><br><span class="line">	<span class="keyword">for</span> (p.x = bboxmin.x; p.x &lt;= bboxmax.x; p.x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (p.y = bboxmin.y; p.y &lt;= bboxmax.y; p.y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//p点重心坐标</span></span><br><span class="line">			Vec3f bc_screen = <span class="built_in">barycentric</span>(pts, p);</span><br><span class="line">			<span class="comment">//不在三角形内</span></span><br><span class="line">			<span class="keyword">if</span> (bc_screen.x &lt; <span class="number">0</span> || bc_screen.y &lt; <span class="number">0</span> || bc_screen.z &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			p.z = <span class="number">0</span>;</span><br><span class="line">			<span class="function">TGAColor <span class="title">curColor</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)</span></span>;</span><br><span class="line">			<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//插值计算p的深度和颜色</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				p.z += pts[i][<span class="number">2</span>] * bc_screen[i];</span><br><span class="line">				curColor = curColor + vertColors[i] * bc_screen[i];</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//深度值大于当前缓存值</span></span><br><span class="line">			<span class="keyword">if</span> (zbuffer[<span class="built_in">int</span>(p.x + p.y * width)] &lt; p.z)</span><br><span class="line">			&#123;</span><br><span class="line">				zbuffer[<span class="built_in">int</span>(p.x + p.y * width)] = p.z;</span><br><span class="line">				image.<span class="built_in">set</span>(p.x, p.y, curColor * intensity);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，上面我们对TGAColor类型的值使用了+号，文件中没有给出该符号的重载，因此我们也必须手动补充在TGAColor的结构体中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TGAColor <span class="keyword">operator</span>+(<span class="type">const</span> TGAColor tgacolor) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">//默认alpha值是255</span></span><br><span class="line">       <span class="function">TGAColor <span class="title">res</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)</span></span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           res.bgra[i] = <span class="keyword">this</span>-&gt;bgra[i] + tgacolor.bgra[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最后渲染得到的效果就是这样的：</p>
<p><img src="/2023/08/01/tinyRenderer2/6.png" alt></p>
<p>模型还是棱角分明，但如果你看到人物额头部分，就能明白我们已经对三角形进行了平滑，但是由于采样频率太低，也就是每次仅仅对三个顶点的颜色插值，得到的纹理细节不足，单个三角形上能看到平滑的表现，但是不同三角形之间就很难关联了，所以造成这样的结果。对比一下采用坐标插值的结果：</p>
<p><img src="/2023/08/01/tinyRenderer2/7.png" alt></p>
<p>这就是为什么我们要对纹理坐标进行插值，而不是颜色插值。当然对颜色插值或许也有它自己的用途。下节内容我们将回顾MVP变换。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Graphics API</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>五百行C++理解OpenGL机制(四)</title>
    <url>/2023/08/02/tinyRenderer3/</url>
    <content><![CDATA[<p>算上Unity Shader部分，这已经是第三次记录MVP变换的内容了，感兴趣可以翻一翻我关于Unity Shader的部分博客，或者其他地方学习。如果你学过Games101或虎书，这也对你不是难事，我将简述Lesson4的内容，然后快速进入实际应用，不在正交视图而是透视图下绘制之前的人头模型。</p>
<span id="more"></span>
<h1 id="Lesson-4"><a href="#Lesson-4" class="headerlink" title="Lesson 4"></a>Lesson 4</h1><h2 id="仿射变换与齐次坐标"><a href="#仿射变换与齐次坐标" class="headerlink" title="仿射变换与齐次坐标"></a>仿射变换与齐次坐标</h2><p>游戏中我们经常需要对建模的物体进行平移，旋转，缩放的操作，它们统称为仿射变换。使用线性变换矩阵就可以达到目的，假设现在有一个二维的坐标(x,y)，我们通过左乘一个2*2大小的矩阵就能将它进行除平移以外的一切操作，例如旋转、错切、缩放。</p>
<p><img src="/2023/08/02/tinyRenderer3/1.png" alt></p>
<p>其中a，d控制缩放，b，c控制错切，b称为Y沿X方向的错切，c称为X沿Y方向的错切。旋转可以通过Paeth分解为三个错切的组合，而线性变换的乘积可以通过特征值分解或者奇异值分解还原为基本线性变换的组合。不懂的很推荐看看虎书(Fundamentals of Computer Graphics)，里面第六章有详细图文说明。</p>
<p>线性变换是可以通过相同维度的变换矩阵实现的，但是平移不能，想要将坐标整体变化某个值，当然可以直接加减，进一步改写，通过增加一个维度可以用乘法实现平移。因此现在线性变换和平移变换可以采用增加一个维度的方式统一起来，就是齐次坐标，线性变换加一次平移变换称为仿射变换。</p>
<p><img src="/2023/08/02/tinyRenderer3/2.png" alt></p>
<p>齐次坐标除了实现平移外，还能提供一些关于区分点和向量的计算，当z=0，齐次除法以后得到的值无限长，就是一个向量；否则就是一个点。</p>
<h2 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a>Projection</h2><p>感觉TinyRenderer中讲的不好，有时间还是看看虎书吧。简单来说就是将坐标根据远近进行缩放，如果你之前接触过这方面知识会发现这里少了很多复杂的推导，原因是这里我们直接假定视锥体以原点为中心了，所以不必对视锥体进行平移，缩放也是假定不需要。所以给定一个点P，将它投影到Z=0的平面上，只需要考虑用相似三角形将它的坐标进行一次缩放就行了。</p>
<p><img src="/2023/08/02/tinyRenderer3/3.png" alt></p>
<p>图中三角形ABC和三角形ODC相似，所以 |AB|/|AC|=|OD|/|OC| =&gt; x/(c-z) = x’/c，解得x’：</p>
<p><img src="/2023/08/02/tinyRenderer3/4.png" alt></p>
<p>同理得到y’：</p>
<p><img src="/2023/08/02/tinyRenderer3/5.png" alt></p>
<p>用矩阵来表达，变换矩阵就长下面这样：</p>
<p><img src="/2023/08/02/tinyRenderer3/6.png" alt></p>
<p>Lesson4的内容到这里就结束了，都是理论的知识，我还是建议有时间一定要看虎书，不然下次见到那个复杂的透视投影矩阵肯定摸不着头脑，实际上Games101中也进行了一次推导，都可以看看，思考为什么这里的投影矩阵截然不同，毕竟常识中透视投影就和这里一样简洁。</p>
<h1 id="Lesson-5"><a href="#Lesson-5" class="headerlink" title="Lesson 5"></a>Lesson 5</h1><h2 id="ModelView"><a href="#ModelView" class="headerlink" title="ModelView"></a>ModelView</h2><p>第五节内容也差不多，还是MVP变换的内容。不过这里值得一看，因为作者在这里讲解了OpenGL中著名的gluLookAt函数，我们接下来手动编写自己的实现。现在模型的坐标在模型空间中，如果我们想要移动摄像机，等价于反方向移动物体，所以我们假设摄像机是不动的，所有变换均施加在模型自身的坐标上。</p>
<p><img src="/2023/08/02/tinyRenderer3/7.png" alt></p>
<p>那么如果摄像机位于上图中e点，而且我们给定一个向上的方向向量$\vec{u}$，摄像机看向中心点c，它们就是我们需要的全部关键参数。原本的模型坐标系是(x,y,z)，但是由于我们需要从另一个方向观察，就得把该坐标系中的所有坐标变换到新的坐标系(x’,y’,z’)中。</p>
<p>新的坐标系并没有改变原来模型坐标的实际位置，只不过在新的基向量下给出了表示，以c为原点，摄像机在新的基向量(x’,y’,z’)下可以表示为(0,0,e.z)，这就和之前的情况一致了，因此如果要移动摄像机，我们唯一要做的就是将原本的模型变换到新的基向量下。你可以尝试思考移动模型和移动摄像机的区别，从摄像机的视角来看，观察到的图像是一致的。</p>
<p>那如何确定这个变换矩阵？我们用下面的代码来实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookat</span><span class="params">(Vec3f eye, Vec3f center, Vec3f up)</span> </span>&#123;</span><br><span class="line">    Vec3f z = (eye-center).<span class="built_in">normalize</span>();</span><br><span class="line">    Vec3f x = <span class="built_in">cross</span>(up,z).<span class="built_in">normalize</span>();</span><br><span class="line">    Vec3f y = <span class="built_in">cross</span>(z,x).<span class="built_in">normalize</span>();</span><br><span class="line">    ModelView = Matrix::<span class="built_in">identity</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        ModelView[<span class="number">0</span>][i] = x[i];</span><br><span class="line">        ModelView[<span class="number">1</span>][i] = y[i];</span><br><span class="line">        ModelView[<span class="number">2</span>][i] = z[i];</span><br><span class="line">        ModelView[i][<span class="number">3</span>] = -center[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从模型空间开始，(1,0,0)，(0,1,0)和(0,0,1)分别表示xyz轴，e和c，向量$\vec{u}$的坐标也都表示在模型空间中。首先计算新的坐标空间(x’,y’,z’)，其中z’是从c到e的向量，而x’应该和向量$\vec{z}$以及向量$\vec{u}$都垂直，选择图示方向，计算它们的叉积并归一化即可。最后还要计算y’，你可能疑惑y’为什么不等于向量$\vec{u}$的归一化，原因在于$\vec{u}$并不保证和z轴垂直，它作为向上向量仅提供一个大概的方向，最终它应该位于y’cz’面内，但不一定和y’重合。</p>
<p>现在我们得到了(x’,y’,z’)在(x,y,z)下的表示，要想获得从(x,y,z)到(x’,y’,z’)的线性变换矩阵，仅需要将(x’,y’,z’)三个轴在(x,y,z)下的表示按列排列，得到的4*4矩阵就能让坐标轴完成旋转。别忘了还要将中心点移动到-e，因为把相机移动到e和把模型移动到-e才是等价的，所以还要左乘一个移动-e的平移矩阵。</p>
<p>总之，这一步完成的工作是从模型空间到相机空间的变换，跳过了世界空间，也只是多一次变换的事情。</p>
<h2 id="Viewport"><a href="#Viewport" class="headerlink" title="Viewport"></a>Viewport</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x，y是窗口左下角的位置，w，h定义窗口高度；</span></span><br><span class="line"><span class="comment">//窗口不是我们创建的图片，如果xy都是0，wh等于图片大小</span></span><br><span class="line"><span class="comment">//整个图片将会被用于渲染</span></span><br><span class="line"><span class="function">Matrix <span class="title">viewport</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    Matrix m = Matrix::<span class="built_in">identity</span>(<span class="number">4</span>);</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">3</span>] = x+w/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">3</span>] = y+h/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">3</span>] = depth/<span class="number">2.f</span>;</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = w/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">1</span>] = h/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">2</span>] = depth/<span class="number">2.f</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在到视口了，用投影矩阵对上面变换之后的坐标处理，进行了归一化，坐标范围[-1,1]。现在视口需要缩放坐标到适合屏幕大小，上面的代码转化成矩阵是这样：</p>
<p><img src="/2023/08/02/tinyRenderer3/8.png" alt></p>
<p>三维坐标范围从[-1,1]*[-1,1]*[-1,1]被缩放到[x,x+w]*[y,y+h]*[0,d]，其中d是z-buffer的深度/分辨率，作者设定为255方便计算，实际上对z的缩放不影响后续深度测试。至于为什么xy不是缩放到[1,w]和[1,h]，这里作者没写，如果对OpenGL不熟悉很容易误导。OpenGL中的视口变换方法为<a href="https://www.opengl.org/sdk/docs/man/html/glViewport.xhtml">glViewport(GLint , GLint , GLsizei , GLsizei )</a>，前面两个参数对应这里的x和y，实际上是指定了转换后视口的左下角位置(x,y)在窗口中的哪里，它跟我们顶点的坐标没有一点关系！</p>
<h2 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h2><p>介绍了所有的MVP变换矩阵，时候将它们连起来了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Viewport * Projection * View * Model * v</span><br></pre></td></tr></table></figure>
<p>v是模型，Model将模型变换到世界坐标中，然后用View在摄像机坐标系的基向量下表达出来(我们的ModelView矩阵同时完成这两步)，然后投影Projection得到归一化的视体，称为裁剪坐标，最后用Viewport矩阵缩放到合适屏幕坐标。</p>
<h2 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h2><p>最后补充一点知识，我们前面知道除了顶点坐标外，一般顶点的法向量也有提供，但是不能用同样的变换矩阵来对法向量进行变换，因为仿射变换之后法向量和顶点或边的垂直关系会被改变，它并没有在垂直这一条件下进行。也就是说仿射变换后的法向量就不是法向量了，它和原本的顶点没有关系，我们的解决办法是计算新顶点对应的法向量，找到新旧法向量之间的关系。</p>
<p>这里不展开说了，在《Unity Shader入门精要》的第四章和虎书都有介绍，网上博客也有很多推导。结论是法向量的变换矩阵为原顶点变换矩阵的逆转置矩阵。</p>
<p>Lesson6中，我们来用上面的方法重构代码，编写自己的渲染器。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Graphics API</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>五百行C++理解OpenGL机制(六)</title>
    <url>/2023/08/04/tinyRenderer5/</url>
    <content><![CDATA[<p>关于软渲染器，框架已经差不多了，现在让我们进入新的内容，阴影。今天我们尝试给模型加上硬阴影，注意不是软阴影。这就是最后一节内容。</p>
<span id="more"></span>
<h1 id="Lesson-7"><a href="#Lesson-7" class="headerlink" title="Lesson 7"></a>Lesson 7</h1><p>即便Shader中阴影通常也不会放在基础部分，不过既然有现成的代码，我们也不客气了。作者给出一个使用Phong渲染后的图：</p>
<p><img src="/2023/08/04/tinyRenderer5/1.png" alt></p>
<p>观察一下可以发现，虽然Phong模型模拟了光照情况，但是没有模拟遮挡情况。上面的模型中，光源在右上角，那么右边肩膀上应该被挡住了才对。这就是为什么我们需要单独处理阴影。这里介绍一种最简单的思路，我们先把相机放到和光源相同的位置看模型，做一次深度测试渲染一个深度图，里面存储着从光源方向看哪些地方能够被照亮。然后我们在渲染一次，这次根据深度图的信息在给一次光照，就能得到正确的结果。这个信息实际上就是一个浮点数，我们通过将两个图中的片元匹配起来获得这个值，让最后的颜色乘以这个值，就能得到想要的结果。</p>
<p>例如上面这个图，第一次渲染深度后得到图片：</p>
<p><img src="/2023/08/04/tinyRenderer5/2.png" alt></p>
<p>其中的颜色为(255,255,255,255)*Depth，然后我们再次渲染，光强乘以片元对应的Depth，得到下面的结果：</p>
<p><img src="/2023/08/04/tinyRenderer5/3.png" alt></p>
<p>我并没有在作者的项目中找到这个模型，后面我们用另一个给出的模型来观察效果。上面关键问题在于，如何让两个视角图中的像素匹配起来？我们仍然通过变换实现，在第二次渲染的Fragment着色器中，我们可以使用的是从光源位置渲染的图片的像素坐标和当前片元在屏幕上的像素坐标，目标是从后者找到前者的坐标，也就是从当前片元的屏幕坐标变换到深度图中的屏幕坐标。</p>
<p>深度图中的像素坐标首先从模型空间开始，经过Model矩阵变换到位于光源的摄像机的空间，经过Projection变换到[-1,1]的标准坐标系，然后经过Viewport变换到最终的像素坐标。我们在第一次渲染的时候保存这个变换，因为第二次渲染需要重新初始化MVP矩阵。这下你可能知道怎么办了，我们先用当前的MVP矩阵还原现在的点，然后用第一次保存的大矩阵将它转换到深度图中，就得到了匹配的坐标。下面是代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tgaimage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;model.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;our_gl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Model *model        = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">float</span> *shadowbuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> width  = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> height = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3f <span class="title">light_dir</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Vec3f       <span class="title">eye</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Vec3f    <span class="title">center</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Vec3f        <span class="title">up</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shader</span> : <span class="keyword">public</span> IShader &#123;</span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="type">float</span>&gt; uniform_M;   <span class="comment">//  Projection*ModelView</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="type">float</span>&gt; uniform_MIT; <span class="comment">// (Projection*ModelView).invert_transpose()</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="type">float</span>&gt; uniform_Mshadow; <span class="comment">// transform framebuffer screen coordinates to shadowbuffer screen coordinates</span></span><br><span class="line">    mat&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="type">float</span>&gt; varying_uv;  <span class="comment">// triangle uv coordinates, written by the vertex shader, read by the fragment shader</span></span><br><span class="line">    mat&lt;<span class="number">3</span>,<span class="number">3</span>,<span class="type">float</span>&gt; varying_tri; <span class="comment">// triangle coordinates before Viewport transform, written by VS, read by FS</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Shader</span>(Matrix M, Matrix MIT, Matrix MS) : <span class="built_in">uniform_M</span>(M), <span class="built_in">uniform_MIT</span>(MIT), <span class="built_in">uniform_Mshadow</span>(MS), <span class="built_in">varying_uv</span>(), <span class="built_in">varying_tri</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="type">int</span> iface, <span class="type">int</span> nthvert)</span> </span>&#123;</span><br><span class="line">        varying_uv.<span class="built_in">set_col</span>(nthvert, model-&gt;<span class="built_in">uv</span>(iface, nthvert));</span><br><span class="line">        Vec4f gl_Vertex = Viewport*Projection*ModelView*<span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(model-&gt;<span class="built_in">vert</span>(iface, nthvert));</span><br><span class="line">        varying_tri.<span class="built_in">set_col</span>(nthvert, <span class="built_in">proj</span>&lt;<span class="number">3</span>&gt;(gl_Vertex/gl_Vertex[<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">return</span> gl_Vertex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//插值得到像素的屏幕坐标，变换到深度图中</span></span><br><span class="line">        Vec4f sb_p = uniform_Mshadow*<span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(varying_tri*bar); <span class="comment">// corresponding point in the shadow buffer</span></span><br><span class="line">        <span class="comment">//齐次除法，虽然embed扩展后w=1，经过逆变换到深度图中w不等于1</span></span><br><span class="line">        sb_p = sb_p/sb_p[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">int</span>(sb_p[<span class="number">0</span>]) + <span class="built_in">int</span>(sb_p[<span class="number">1</span>])*width; <span class="comment">// index in the shadowbuffer array</span></span><br><span class="line">        <span class="type">float</span> shadow = <span class="number">.3</span>+<span class="number">.7</span>*(shadowbuffer[idx]&lt;sb_p[<span class="number">2</span>]); <span class="comment">// magic coeff to avoid z-fighting</span></span><br><span class="line">        Vec2f uv = varying_uv*bar;                 <span class="comment">// interpolate uv for the current pixel</span></span><br><span class="line">        Vec3f n = <span class="built_in">proj</span>&lt;<span class="number">3</span>&gt;(uniform_MIT*<span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(model-&gt;<span class="built_in">normal</span>(uv))).<span class="built_in">normalize</span>(); <span class="comment">// normal</span></span><br><span class="line">        Vec3f l = <span class="built_in">proj</span>&lt;<span class="number">3</span>&gt;(uniform_M  *<span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(light_dir        )).<span class="built_in">normalize</span>(); <span class="comment">// light vector</span></span><br><span class="line">        Vec3f r = (n*(n*l*<span class="number">2.f</span>) - l).<span class="built_in">normalize</span>();   <span class="comment">// reflected light</span></span><br><span class="line">        <span class="type">float</span> spec = <span class="built_in">pow</span>(std::<span class="built_in">max</span>(r.z, <span class="number">0.0f</span>), model-&gt;<span class="built_in">specular</span>(uv));</span><br><span class="line">        <span class="type">float</span> diff = std::<span class="built_in">max</span>(<span class="number">0.f</span>, n*l);</span><br><span class="line">        TGAColor c = model-&gt;<span class="built_in">diffuse</span>(uv);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) color[i] = std::<span class="built_in">min</span>&lt;<span class="type">float</span>&gt;(<span class="number">20</span> + c[i]*shadow*(<span class="number">1.2</span>*diff + <span class="number">.6</span>*spec), <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将光源位置的摄像机深度信息存入图片中</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DepthShader</span> : <span class="keyword">public</span> IShader &#123;</span><br><span class="line">    mat&lt;<span class="number">3</span>,<span class="number">3</span>,<span class="type">float</span>&gt; varying_tri;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DepthShader</span>() : <span class="built_in">varying_tri</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="type">int</span> iface, <span class="type">int</span> nthvert)</span> </span>&#123;</span><br><span class="line">        Vec4f gl_Vertex = <span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(model-&gt;<span class="built_in">vert</span>(iface, nthvert)); <span class="comment">// read the vertex from .obj file</span></span><br><span class="line">        gl_Vertex = Viewport*Projection*ModelView*gl_Vertex;          <span class="comment">// transform it to screen coordinates</span></span><br><span class="line">        varying_tri.<span class="built_in">set_col</span>(nthvert, <span class="built_in">proj</span>&lt;<span class="number">3</span>&gt;(gl_Vertex/gl_Vertex[<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">return</span> gl_Vertex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">        Vec3f p = varying_tri*bar;</span><br><span class="line">        color = <span class="built_in">TGAColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)*(p.z/depth);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> *zbuffer = <span class="keyword">new</span> <span class="type">float</span>[width*height];</span><br><span class="line">    shadowbuffer   = <span class="keyword">new</span> <span class="type">float</span>[width*height];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=width*height; --i; ) &#123;</span><br><span class="line">        zbuffer[i] = shadowbuffer[i] = -std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model = <span class="keyword">new</span> <span class="built_in">Model</span>(<span class="string">&quot;obj/diablo3_pose.obj&quot;</span>);</span><br><span class="line">    light_dir.<span class="built_in">normalize</span>();</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// rendering the shadow buffer</span></span><br><span class="line">        <span class="function">TGAImage <span class="title">depth</span><span class="params">(width, height, TGAImage::RGB)</span></span>;</span><br><span class="line">        <span class="built_in">lookat</span>(light_dir, center, up);</span><br><span class="line">        <span class="built_in">viewport</span>(width/<span class="number">8</span>, height/<span class="number">8</span>, width*<span class="number">3</span>/<span class="number">4</span>, height*<span class="number">3</span>/<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">projection</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        DepthShader depthshader;</span><br><span class="line">        Vec4f screen_coords[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;model-&gt;<span class="built_in">nfaces</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">                screen_coords[j] = depthshader.<span class="built_in">vertex</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">triangle</span>(screen_coords, depthshader, depth, shadowbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        depth.<span class="built_in">flip_vertically</span>(); <span class="comment">// to place the origin in the bottom left corner of the image</span></span><br><span class="line">        depth.<span class="built_in">write_tga_file</span>(<span class="string">&quot;depth.tga&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//保存深度图使用的变换矩阵</span></span><br><span class="line">    Matrix M = Viewport*Projection*ModelView;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// rendering the frame buffer</span></span><br><span class="line">        <span class="function">TGAImage <span class="title">frame</span><span class="params">(width, height, TGAImage::RGB)</span></span>;</span><br><span class="line">        <span class="built_in">lookat</span>(eye, center, up);</span><br><span class="line">        <span class="built_in">viewport</span>(width/<span class="number">8</span>, height/<span class="number">8</span>, width*<span class="number">3</span>/<span class="number">4</span>, height*<span class="number">3</span>/<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">projection</span>(<span class="number">-1.f</span>/(eye-center).<span class="built_in">norm</span>());</span><br><span class="line"></span><br><span class="line">        <span class="function">Shader <span class="title">shader</span><span class="params">(ModelView, (Projection*ModelView).invert_transpose(), M*(Viewport*Projection*ModelView).invert())</span></span>;</span><br><span class="line">        Vec4f screen_coords[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;model-&gt;<span class="built_in">nfaces</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">                screen_coords[j] = shader.<span class="built_in">vertex</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">triangle</span>(screen_coords, shader, frame, zbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        frame.<span class="built_in">flip_vertically</span>(); <span class="comment">// to place the origin in the bottom left corner of the image</span></span><br><span class="line">        frame.<span class="built_in">write_tga_file</span>(<span class="string">&quot;framebuffer.tga&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> model;</span><br><span class="line">    <span class="keyword">delete</span> [] zbuffer;</span><br><span class="line">    <span class="keyword">delete</span> [] shadowbuffer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>理解代码后重新查看上面的渲染结果，发现出现了很多空洞，这被称为z-fighting，深度冲突。原理是在使用深度缓存比较深度值的时候，远离摄像机的地方因为透视投影，深度值被压缩到较小的一个范围，深度值不精确，导致比较可能出错，有的片元被保留，有的被抛弃了，就导致这样的结果。而靠近摄像机的地方深度值不会受到这样大的压缩影响，所以影响比较小。</p>
<p>结合代码来看，回忆之前的光栅化，每个片元的深度值是对三角形三个顶点的插值，并且还要做齐次除法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec3f c = <span class="built_in">barycentric</span>(<span class="built_in">proj</span>&lt;<span class="number">2</span>&gt;(pts[<span class="number">0</span>]/pts[<span class="number">0</span>][<span class="number">3</span>]), <span class="built_in">proj</span>&lt;<span class="number">2</span>&gt;(pts[<span class="number">1</span>]/pts[<span class="number">1</span>][<span class="number">3</span>]), <span class="built_in">proj</span>&lt;<span class="number">2</span>&gt;(pts[<span class="number">2</span>]/pts[<span class="number">2</span>][<span class="number">3</span>]), <span class="built_in">proj</span>&lt;<span class="number">2</span>&gt;(P));</span><br><span class="line">         <span class="type">float</span> z = pts[<span class="number">0</span>][<span class="number">2</span>]*c.x + pts[<span class="number">1</span>][<span class="number">2</span>]*c.y + pts[<span class="number">2</span>][<span class="number">2</span>]*c.z;</span><br><span class="line">         <span class="type">float</span> w = pts[<span class="number">0</span>][<span class="number">3</span>]*c.x + pts[<span class="number">1</span>][<span class="number">3</span>]*c.y + pts[<span class="number">2</span>][<span class="number">3</span>]*c.z;</span><br><span class="line">         <span class="type">int</span> frag_depth = z/w;</span><br></pre></td></tr></table></figure>
<p>注意我们这里原因是在于深度图的比较，而不是第二次渲染的空间中比较出现的问题。不过z-fighting是原理是类似的。我们用Shader中的这行代码来缓解问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// float shadow = .3+.7*(shadowbuffer[idx]&lt;sb_p[2]); // magic coeff to avoid z-fighting</span></span><br><span class="line"><span class="type">float</span> shadow = <span class="number">.3</span>+<span class="number">.7</span>*(shadowbuffer[idx]&lt;sb_p[<span class="number">2</span>]+<span class="number">43.34</span>); <span class="comment">// magic coeff to avoid z-fighting</span></span><br></pre></td></tr></table></figure>
<p>原本当在深度图空间中，片元的z值大于深度图中存储的值，说明片元排在前面(不用等于是因为浮点数一般无法比较是否相等，这也是不精确的原因之一)，那么shadow就是0.3+0.7=1，不精确的比较导致后面这个0.7不一定加得上去。我们用自己的图片得到效果：</p>
<p><img src="/2023/08/04/tinyRenderer5/4.png" alt></p>
<p>尤其是左腿上，出现了很多抖动。更改代码，将阴影值直接加上某些值，看到明显的变化：</p>
<p><img src="/2023/08/04/tinyRenderer5/5.png" alt></p>
<p>腿部的渲染还是不尽人意，因为那里的模型凹凸不一，比较复杂，但是左手得到了极大改善。你可以尝试修改这个值观察效果。个人理解上面的代码就是简单地将一些可能会因为不准确的比较而被惩罚的像素救回来了，加上一个之让它有保底，或者另一种方法将后面两个值括起来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">.3</span> + <span class="number">.7</span> * (shadowbuffer[idx] &lt; (sb_p[<span class="number">2</span>] + <span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<p>这样也是类似的，可能被抛弃的片元都会被保留下来，代价就是随着这个值的增大，也会导致非阴影的部分越来越多，与我们期望的结果稍有出入。总之这个方法显然不是根本的解决，Shader中写阴影有很多其他方案，以后再学习。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>作者后面还有两次课程，不过这两次我认为看一看就可以了，一次是关于全局光照环境光的介绍，一次是关于如何编写OpenGL应用的介绍，尤其全局光照不算基础内容了，先用高级语言实现它再回过来看也许会有其它理解，总之不必浪费时间在它们身上。这个项目最好的地方还是对光栅化的实现，并且还封装成Shader类似的样子，做完前六节课你会对基本的渲染管线有更深刻的理解，而不只是知道其中某个部分大致在干什么。</p>
<p>接下来我们得停下来用虎书系统整理下图形学的基本知识，接着继续学习Unity Shader，做一些常见的视觉效果如水、雾、海量草等很重要的解决方案。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Graphics API</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity GameFramework框架笔记(一) Procedure是什么？</title>
    <url>/2023/10/25/ugf1/</url>
    <content><![CDATA[<p>这个系列记录一下ugf框架的学习，一个比较知名的unity游戏框架，先从作者给出的实例demo开始学习。</p>
<span id="more"></span>
<h1 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h1><p>作者写的这个demo叫做<a href="https://github.com/EllanJiang/StarForce">Star-Force</a>，我们克隆下来之后还要记得克隆子模块，这里作者将自己的框架链接成git的submodule了，不弄的话会报错，所以要注意。都拉下来之后直接用Unity打开，我是用的版本是2020.3.45f1c1，这个应该影响不大，文档烂但是代码还是很好的。</p>
<p>首先看到框架入口，也就是Game Entry脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">GameEntry</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitBuiltinComponents();</span><br><span class="line">            InitCustomComponents();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个部分类，只有一个Start函数，调用了两个方法，分别对框架内部的组件和我们自己添加的组件进行初始化。接下来如果点开InitBuiltinComponents()，会发现该静态方法定义在该类的另一个部分类中，主要是对框架自己定义的一些组件进行初始化，这个暂时不管，我们先看CustomComponents()。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitCustomComponents</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            BuiltinData = UnityGameFramework.Runtime.GameEntry.GetComponent&lt;BuiltinDataComponent&gt;();</span><br><span class="line">            HPBar = UnityGameFramework.Runtime.GameEntry.GetComponent&lt;HPBarComponent&gt;();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>寥寥两行代码貌似也不足以让游戏运行起来，第一行代码又是关于框架的调用，第二行代码也似乎只是将血条进行了初始化而已，那么我们可以判断该方法真的只是进行了初始化而已，关于进一步的介绍还要看作者的叙述。<a href="http://www.benmutou.com/archives/2486">木头大佬</a>提到，框架的顺序执行应该和流程有关，作者介绍流程如下：</p>
<ul>
<li><strong>流程 (Procedure)</strong> - 是贯穿游戏运行时整个生命周期的有限状态机。通过流程，将不同的游戏状态进行解耦将是一个非常好的习惯。对于网络游戏，你可能需要如检查资源流程、更新资源流程、检查服务器列表流程、选择服务器流程、登录服务器流程、创建角色流程等流程，而对于单机游戏，你可能需要在游戏选择菜单流程和游戏实际玩法流程之间做切换。如果想增加流程，只要派生自 ProcedureBase 类并实现自己的流程类即可使用。</li>
</ul>
<p>那么打开GameFramework的子对象列表，可以看到BuiltIn含有二十个子对象，除了Reference Pool外，其余十九个对象正是作者简介中列出来的框架组件。</p>
<p><img src="/2023/10/25/ugf1/1.png" alt></p>
<p>因此我们点开Procedure，发现挂载的脚本上有一个列表：</p>
<p><img src="/2023/10/25/ugf1/2.png" alt></p>
<p>这里意思应该是，勾选后可以启用该流程，并且下面还有一个Entrance Procedure代表从那个Procedure进入。根据作者描述，我们应该能在其中添加自己的Procedure，方法就是继承ProcedureBase 类，之后我们自己创建的方法就应该会被收集到这个地方。我们先看看它这些类是如何实现的，我尝试搜索ProcedureMain脚本，然后打开：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProcedureMain</span> : <span class="title">ProcedureBase</span></span><br></pre></td></tr></table></figure>
<p>和作者描述的一致，那我再尝试新建一个自己的脚本继承以下这个Base：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StarForce</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProcedureTest</span> : <span class="title">ProcedureBase</span></span><br><span class="line">	&#123;  </span><br><span class="line">	        <span class="comment">//要求必须实现继承的抽象方法</span></span><br><span class="line">	        <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> UseNativeDialog =&gt; <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里还需要将基类的抽象方法实现，这个应该是后来添加的，作者注释说用来决定获取流程是否使用原生对话框，在一些特殊的流程（如游戏逻辑对话框资源更新完成前的流程）中，可以考虑调用原生对话框进行消息提示行为。（我看不懂所以搬的原话）</p>
<p>总之参考其它类里面的选项，返回false就行了。接着回到Unity中，找到Procedure对象，发现这个方法真的被识别进去了！</p>
<p><img src="/2023/10/25/ugf1/3.png" alt></p>
<p>那么我们就了解了Procedure的基本逻辑。那么其中的方法是以什么顺序执行？进一步查看，第一个方法是UseNativeDialog，必须实现的静态方法；下面就是OnEnter方法。看到这个方法很容易想到这应该和状态机类似，在进入该流程的时候要执行一些方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">ProcedureOwner procedureOwner</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnEnter(procedureOwner);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建信息：发布版本时，把一些数据以 Json 的格式写入 Assets/GameMain/Configs/BuildInfo.txt，供游戏逻辑读取</span></span><br><span class="line">    GameEntry.BuiltinData.InitBuildInfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语言配置：设置当前使用的语言，如果不设置，则默认使用操作系统语言</span></span><br><span class="line">    InitLanguageSettings();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变体配置：根据使用的语言，通知底层加载对应的资源变体</span></span><br><span class="line">    InitCurrentVariant();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声音配置：根据用户配置数据，设置即将使用的声音选项</span></span><br><span class="line">    InitSoundSettings();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认字典：加载默认字典文件 Assets/GameMain/Configs/DefaultDictionary.xml</span></span><br><span class="line">    <span class="comment">// 此字典文件记录了资源更新前使用的各种语言的字符串，会随 App 一起发布，故不可更新</span></span><br><span class="line">    GameEntry.BuiltinData.InitDefaultDictionary();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文档内搜索以下，BuiltIn的两个方法和OnEnter都是框架其它地方的内部方法，而中间三个方法则是写在这个类里面的私有方法，它们应该就是执行主要逻辑的方法。具体就不列出来了，另外还有个OnUpdate方法，猜测是和Unity的Update类似，所以打开了Base类，看到它其实又继承状态机给了五个方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">GameFramework.Procedure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">//     流程基类。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ProcedureBase</span> : <span class="title">FsmState</span>&lt;<span class="title">IProcedureManager</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     状态初始化时调用。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 参数:</span></span><br><span class="line">        <span class="comment">//   procedureOwner:</span></span><br><span class="line">        <span class="comment">//     流程持有者。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params">IFsm&lt;IProcedureManager&gt; procedureOwner</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnInit(procedureOwner);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     进入状态时调用。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 参数:</span></span><br><span class="line">        <span class="comment">//   procedureOwner:</span></span><br><span class="line">        <span class="comment">//     流程持有者。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">IFsm&lt;IProcedureManager&gt; procedureOwner</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnEnter(procedureOwner);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     状态轮询时调用。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 参数:</span></span><br><span class="line">        <span class="comment">//   procedureOwner:</span></span><br><span class="line">        <span class="comment">//     流程持有者。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   elapseSeconds:</span></span><br><span class="line">        <span class="comment">//     逻辑流逝时间，以秒为单位。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   realElapseSeconds:</span></span><br><span class="line">        <span class="comment">//     真实流逝时间，以秒为单位。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params">IFsm&lt;IProcedureManager&gt; procedureOwner, <span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnUpdate(procedureOwner, elapseSeconds, realElapseSeconds);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     离开状态时调用。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 参数:</span></span><br><span class="line">        <span class="comment">//   procedureOwner:</span></span><br><span class="line">        <span class="comment">//     流程持有者。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   isShutdown:</span></span><br><span class="line">        <span class="comment">//     是否是关闭状态机时触发。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnLeave</span>(<span class="params">IFsm&lt;IProcedureManager&gt; procedureOwner, <span class="built_in">bool</span> isShutdown</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnLeave(procedureOwner, isShutdown);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     状态销毁时调用。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 参数:</span></span><br><span class="line">        <span class="comment">//   procedureOwner:</span></span><br><span class="line">        <span class="comment">//     流程持有者。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params">IFsm&lt;IProcedureManager&gt; procedureOwner</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnDestroy(procedureOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们基本就清楚Procedure了，如果进一步查看会发现，它本质上是一个状态机，继承自FsmState类，就和动画状态机一样，方便我们管理游戏事件。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
        <category>GameFramework</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>五百行C++理解OpenGL机制(五)</title>
    <url>/2023/08/03/tinyRenderer4/</url>
    <content><![CDATA[<p>我已经迫不及待进入渲染器的实现了，上一节简述了各种原理，要记住它们十分重要，值得反复理解。接下来的工作就是重构代码，让它更加灵活，更加可用。包括之前一节遗留了一些问题，下面也会做出解释。</p>
<span id="more"></span>
<h1 id="Lesson-6"><a href="#Lesson-6" class="headerlink" title="Lesson 6"></a>Lesson 6</h1><p>话不多说，我们已经掌握编写软渲染器需要的全部知识了(或许有一天还有硬渲染器hh)。现在思考这样一个问题，OpenGL，或者如果你接触过Shader Language，它们是怎样工作的呢？先前我们编写、学习了很多内容，但它们都还没有达到现在我们常说的渲染管线，所以并不具备很好的功能，下面我们来了解并编写我们自己的渲染管线。</p>
<h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>我们以OpenGL2的渲染管线为例进行说明，实际上其它的Shader、Graphics API也有着差不多的管线，更重要的是它们原理相通。下图是从顶点数据到像素的部分管线(有时还有很多其它步骤或Shaders)。</p>
<p><img src="/2023/08/03/tinyRenderer4/9.png" alt></p>
<p>回想之前我们如何渲染模型，首先读取模型的面，面是一组由顶点序号构成的数组，存储这个面由哪些顶点构成，这些顶点的法线、纹理坐标是多少，它们就是图中的Vertex Data。另外渲染管线中不是所有部分我们都可以进行编程，因为现在为了实现更快速的渲染，有很多部分被设计在硬件之中，它们是不可编程或更改的，对应上图中蓝色部分，所以我们一般无需关心它们。这一点在Unity Shader入门精要中有更通俗的说明。</p>
<p>而Shader就是可编程的一部分管线，它们通常能够提供关键的作用，对它们进行编程就是我们使用图形API或者Shader Language完成的事情了。上图中Rasterizer也是不可编程的，尽管我们之前实现过自己的光栅化，所以你很清楚它的原理。</p>
<ul>
<li>Primitive Processing对应我们自己的main函数，它接受顶点数据之后调用Vertex Shader；</li>
<li>顶点着色器：计算顶点坐标的转换，以及法线等信息</li>
<li>Primitive Assembly根据顶点信息将不同顶点组合成一个三角形进行下一步；</li>
<li>Rasterizer：对三角形进行光栅化，也就是我们编写的Triangles函数，对每一个包围盒中的像素调用片元着色器；</li>
<li>片元着色器：Fragment是单个像素对应的一系列数据的计算，包括深度、颜色、法线等；</li>
<li>Depth &amp; Stencil：简单理解为深度测试即可，牵扯到<a href="https://blog.csdn.net/sinat_24229853/article/details/48710027">进一步的内容</a></li>
<li>Color Buffer Blend：有时还要使用混合处理透明的渲染，对颜色缓存中的内容进行混合操作；</li>
<li>Dither：抖动，一种图像处理方法；</li>
<li>Frame Buffer：帧缓存，记录下一帧要显示的像素信息，其实就是颜色。</li>
</ul>
<p>如果你不理解除了黄色的两个着色器外的内容，都无关紧要，因为它们全部不可编程，等你学会了操作Shader再理解会更好。下面我们就要开始动手了，要重构之前的代码。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="our-gl"><a href="#our-gl" class="headerlink" title="our_gl"></a>our_gl</h3><p>我们把MVP变换、顶点着色器、片元着色器、光栅化程序全都放到这里。讲解在代码注释里。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OUR_GL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OUR_GL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tgaimage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//extern关键字声明为全局变量</span></span><br><span class="line"><span class="keyword">extern</span> Matrix ModelView;</span><br><span class="line"><span class="keyword">extern</span> Matrix Viewport;</span><br><span class="line"><span class="keyword">extern</span> Matrix Projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">viewport</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">projection</span><span class="params">(<span class="type">float</span> coeff=<span class="number">0.f</span>)</span></span>; <span class="comment">// coeff = -1/c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookat</span><span class="params">(Vec3f eye, Vec3f center, Vec3f up)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IShader</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IShader</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="type">int</span> iface, <span class="type">int</span> nthvert)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangle</span><span class="params">(Vec4f *pts, IShader &amp;shader, TGAImage &amp;image, TGAImage &amp;zbuffer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//__OUR_GL_H__</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;our_gl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Matrix ModelView;</span><br><span class="line">Matrix Viewport;</span><br><span class="line">Matrix Projection;</span><br><span class="line"></span><br><span class="line">IShader::~<span class="built_in">IShader</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和之前视口矩阵一样，xy是左下角，wh是宽高</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">viewport</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    Viewport = Matrix::<span class="built_in">identity</span>();</span><br><span class="line">    Viewport[<span class="number">0</span>][<span class="number">3</span>] = x+w/<span class="number">2.f</span>;</span><br><span class="line">    Viewport[<span class="number">1</span>][<span class="number">3</span>] = y+h/<span class="number">2.f</span>;</span><br><span class="line">    Viewport[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">255.f</span>/<span class="number">2.f</span>;</span><br><span class="line">    Viewport[<span class="number">0</span>][<span class="number">0</span>] = w/<span class="number">2.f</span>;</span><br><span class="line">    Viewport[<span class="number">1</span>][<span class="number">1</span>] = h/<span class="number">2.f</span>;</span><br><span class="line">    Viewport[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">255.f</span>/<span class="number">2.f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//之前也说过了，这个系数由物体和摄像机的距离决定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">projection</span><span class="params">(<span class="type">float</span> coeff)</span> </span>&#123;</span><br><span class="line">    Projection = Matrix::<span class="built_in">identity</span>();</span><br><span class="line">    Projection[<span class="number">3</span>][<span class="number">2</span>] = coeff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ModelView变换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookat</span><span class="params">(Vec3f eye, Vec3f center, Vec3f up)</span> </span>&#123;</span><br><span class="line">    Vec3f z = (eye-center).<span class="built_in">normalize</span>();</span><br><span class="line">    Vec3f x = <span class="built_in">cross</span>(up,z).<span class="built_in">normalize</span>();</span><br><span class="line">    Vec3f y = <span class="built_in">cross</span>(z,x).<span class="built_in">normalize</span>();</span><br><span class="line">    ModelView = Matrix::<span class="built_in">identity</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        ModelView[<span class="number">0</span>][i] = x[i];</span><br><span class="line">        ModelView[<span class="number">1</span>][i] = y[i];</span><br><span class="line">        ModelView[<span class="number">2</span>][i] = z[i];</span><br><span class="line">        ModelView[i][<span class="number">3</span>] = -center[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和我们编写的一致，不用修改</span></span><br><span class="line"><span class="function">Vec3f <span class="title">barycentric</span><span class="params">(Vec2f A, Vec2f B, Vec2f C, Vec2f P)</span> </span>&#123;</span><br><span class="line">    Vec3f s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i--; ) &#123;</span><br><span class="line">        s[i][<span class="number">0</span>] = C[i]-A[i];</span><br><span class="line">        s[i][<span class="number">1</span>] = B[i]-A[i];</span><br><span class="line">        s[i][<span class="number">2</span>] = A[i]-P[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Vec3f u = <span class="built_in">cross</span>(s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">abs</span>(u[<span class="number">2</span>])&gt;<span class="number">1e-2</span>) <span class="comment">// dont forget that u[2] is integer. If it is zero then triangle ABC is degenerate</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// in this case generate negative coordinates, it will be thrown away by the rasterizator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//光栅化器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangle</span><span class="params">(Vec4f *pts, IShader &amp;shader, TGAImage &amp;image, TGAImage &amp;zbuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//包围盒</span></span><br><span class="line">    <span class="function">Vec2f <span class="title">bboxmin</span><span class="params">( std::numeric_limits&lt;<span class="type">float</span>&gt;::max(),  std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="function">Vec2f <span class="title">bboxmax</span><span class="params">(-std::numeric_limits&lt;<span class="type">float</span>&gt;::max(), -std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++) &#123;</span><br><span class="line">            bboxmin[j] = std::<span class="built_in">min</span>(bboxmin[j], pts[i][j]/pts[i][<span class="number">3</span>]);</span><br><span class="line">            bboxmax[j] = std::<span class="built_in">max</span>(bboxmax[j], pts[i][j]/pts[i][<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Vec2i P;</span><br><span class="line">    TGAColor color;</span><br><span class="line">    <span class="comment">//遍历每个像素</span></span><br><span class="line">    <span class="keyword">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class="line">            <span class="comment">//计算重心坐标，其中proj&lt;2&gt;是重载的方法，返回对象的前两个值，也就是xy；还有齐次除法</span></span><br><span class="line">            Vec3f c = <span class="built_in">barycentric</span>(<span class="built_in">proj</span>&lt;<span class="number">2</span>&gt;(pts[<span class="number">0</span>]/pts[<span class="number">0</span>][<span class="number">3</span>]), <span class="built_in">proj</span>&lt;<span class="number">2</span>&gt;(pts[<span class="number">1</span>]/pts[<span class="number">1</span>][<span class="number">3</span>]), <span class="built_in">proj</span>&lt;<span class="number">2</span>&gt;(pts[<span class="number">2</span>]/pts[<span class="number">2</span>][<span class="number">3</span>]), <span class="built_in">proj</span>&lt;<span class="number">2</span>&gt;(P));</span><br><span class="line">            <span class="comment">//插值得到深度</span></span><br><span class="line">            <span class="type">float</span> z = pts[<span class="number">0</span>][<span class="number">2</span>]*c.x + pts[<span class="number">1</span>][<span class="number">2</span>]*c.y + pts[<span class="number">2</span>][<span class="number">2</span>]*c.z;</span><br><span class="line">            <span class="comment">//插值得到w后面齐次除法</span></span><br><span class="line">            <span class="type">float</span> w = pts[<span class="number">0</span>][<span class="number">3</span>]*c.x + pts[<span class="number">1</span>][<span class="number">3</span>]*c.y + pts[<span class="number">2</span>][<span class="number">3</span>]*c.z;</span><br><span class="line">            <span class="comment">//计算齐次除法后的深度值</span></span><br><span class="line">            <span class="type">int</span> frag_depth = std::<span class="built_in">max</span>(<span class="number">0</span>, std::<span class="built_in">min</span>(<span class="number">255</span>, <span class="built_in">int</span>(z/w+<span class="number">.5</span>)));</span><br><span class="line">            <span class="keyword">if</span> (c.x&lt;<span class="number">0</span> || c.y&lt;<span class="number">0</span> || c.z&lt;<span class="number">0</span> || zbuffer.<span class="built_in">get</span>(P.x, P.y)[<span class="number">0</span>]&gt;frag_depth) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//对每个片元调用片元着色器</span></span><br><span class="line">            <span class="type">bool</span> discard = shader.<span class="built_in">fragment</span>(c, color);</span><br><span class="line">            <span class="keyword">if</span> (!discard) &#123;</span><br><span class="line">                zbuffer.<span class="built_in">set</span>(P.x, P.y, <span class="built_in">TGAColor</span>(frag_depth));</span><br><span class="line">                image.<span class="built_in">set</span>(P.x, P.y, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tgaimage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;model.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;our_gl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Model *model     = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> width  = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> height = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec3f <span class="title">light_dir</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Vec3f       <span class="title">eye</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Vec3f    <span class="title">center</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Vec3f        <span class="title">up</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本次使用的简单着色器，GouraudShading方式在下面会说</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GouraudShader</span> : <span class="keyword">public</span> IShader &#123;</span><br><span class="line">    Vec3f varying_intensity; <span class="comment">// written by vertex shader, read by fragment shader</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="type">int</span> iface, <span class="type">int</span> nthvert)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//embed扩展数据到4维</span></span><br><span class="line">        Vec4f gl_Vertex = <span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(model-&gt;<span class="built_in">vert</span>(iface, nthvert)); <span class="comment">// read the vertex from .obj file</span></span><br><span class="line">        gl_Vertex = Viewport*Projection*ModelView*gl_Vertex;     <span class="comment">// transform it to screen coordinates</span></span><br><span class="line">        varying_intensity[nthvert] = std::<span class="built_in">max</span>(<span class="number">0.f</span>, model-&gt;<span class="built_in">normal</span>(iface, nthvert)*light_dir); <span class="comment">// get diffuse lighting intensity</span></span><br><span class="line">        <span class="keyword">return</span> gl_Vertex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> intensity = varying_intensity*bar;   <span class="comment">// interpolate intensity for the current pixel</span></span><br><span class="line">        color = <span class="built_in">TGAColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)*intensity; <span class="comment">// well duh</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                              <span class="comment">// no, we do not discard this pixel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span>==argc) &#123;</span><br><span class="line">        model = <span class="keyword">new</span> <span class="built_in">Model</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model = <span class="keyword">new</span> <span class="built_in">Model</span>(<span class="string">&quot;obj/african_head.obj&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备变换矩阵</span></span><br><span class="line">    <span class="built_in">lookat</span>(eye, center, up);</span><br><span class="line">    <span class="built_in">viewport</span>(width/<span class="number">8</span>, height/<span class="number">8</span>, width*<span class="number">3</span>/<span class="number">4</span>, height*<span class="number">3</span>/<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">projection</span>(<span class="number">-1.f</span>/(eye-center).<span class="built_in">norm</span>());</span><br><span class="line">    light_dir.<span class="built_in">normalize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化图片和深度缓存</span></span><br><span class="line">    <span class="function">TGAImage <span class="title">image</span>  <span class="params">(width, height, TGAImage::RGB)</span></span>;</span><br><span class="line">    <span class="function">TGAImage <span class="title">zbuffer</span><span class="params">(width, height, TGAImage::GRAYSCALE)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化shader</span></span><br><span class="line">    GouraudShader shader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;model-&gt;<span class="built_in">nfaces</span>(); i++) &#123;</span><br><span class="line">        Vec4f screen_coords[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//遍历每个顶点，调用shader</span></span><br><span class="line">            screen_coords[j] = shader.<span class="built_in">vertex</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//光栅化</span></span><br><span class="line">        <span class="built_in">triangle</span>(screen_coords, shader, image, zbuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    image.  <span class="built_in">flip_vertically</span>(); <span class="comment">// to place the origin in the bottom left corner of the image</span></span><br><span class="line">    zbuffer.<span class="built_in">flip_vertically</span>();</span><br><span class="line">    image.  <span class="built_in">write_tga_file</span>(<span class="string">&quot;output.tga&quot;</span>);</span><br><span class="line">    zbuffer.<span class="built_in">write_tga_file</span>(<span class="string">&quot;zbuffer.tga&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> model;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其余的文件都没有改变过，到这里我们编译运行，得到下图的结果：</p>
<p><img src="/2023/08/03/tinyRenderer4/1.png" alt></p>
<p>这里再简单说一下Gouraud Shading，着色方式有三种，其中Flat着色是逐面计算一次光照颜色，Gouraud着色是逐顶点计算一次光照后对顶点颜色插值，Phong着色是插值得到像素的法向量再计算颜色，效果递增，这里就是对顶点计算一次光照，然后插值平滑颜色。</p>
<h2 id="修改Shader"><a href="#修改Shader" class="headerlink" title="修改Shader"></a>修改Shader</h2><h3 id="修改Fragment-Shader"><a href="#修改Fragment-Shader" class="headerlink" title="修改Fragment Shader"></a>修改Fragment Shader</h3><p>当前我们对片元的光照计算是连续的，intensity通过插值进行了平滑。不过在非真实渲染中，通常需要光照强度不那么平滑，我们通过限制光照强度的值来达到这一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> intensity = varying_intensity*bar;</span><br><span class="line">    <span class="keyword">if</span> (intensity&gt;<span class="number">.85</span>) intensity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (intensity&gt;<span class="number">.60</span>) intensity = <span class="number">.80</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (intensity&gt;<span class="number">.45</span>) intensity = <span class="number">.60</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (intensity&gt;<span class="number">.30</span>) intensity = <span class="number">.45</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (intensity&gt;<span class="number">.15</span>) intensity = <span class="number">.30</span>;</span><br><span class="line">    <span class="keyword">else</span> intensity = <span class="number">0</span>;</span><br><span class="line">    color = <span class="built_in">TGAColor</span>(<span class="number">255</span>, <span class="number">155</span>, <span class="number">0</span>)*intensity;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，我们对intensity的范围进行了划分，一共有六种值作为光强，最后得到的效果是：</p>
<p><img src="/2023/08/03/tinyRenderer4/2.png" alt></p>
<p>我们并没有修改其它任何地方，现在你能一定程度上了解着色器有多灵活了吧。</p>
<h3 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h3><p>还记得我们之前自己实现的纹理吗？当时我们的做法是对颜色进行插值，现在我们来对纹理坐标进行插值，这样能得到更好的效果。当然目前的代码中并没有添加这一部分，我们得自己想办法补充。首先我们得修改着色器结构，让它能够传递纹理坐标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shader</span> : <span class="keyword">public</span> IShader &#123;</span><br><span class="line">    Vec3f          varying_intensity; <span class="comment">// written by vertex shader, read by fragment shader</span></span><br><span class="line">    mat&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="type">float</span>&gt; varying_uv;        <span class="comment">// same as above</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="type">int</span> iface, <span class="type">int</span> nthvert)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//uv找到顶点纹理坐标，按列赋值给矩阵</span></span><br><span class="line">        varying_uv.<span class="built_in">set_col</span>(nthvert, model-&gt;<span class="built_in">uv</span>(iface, nthvert));</span><br><span class="line">        <span class="comment">//计算顶点的切线，找到顶点对应的光强</span></span><br><span class="line">        varying_intensity[nthvert] = std::<span class="built_in">max</span>(<span class="number">0.f</span>, model-&gt;<span class="built_in">normal</span>(iface, nthvert)*light_dir); <span class="comment">// get diffuse lighting intensity</span></span><br><span class="line">        Vec4f gl_Vertex = <span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(model-&gt;<span class="built_in">vert</span>(iface, nthvert)); <span class="comment">// read the vertex from .obj file</span></span><br><span class="line">        <span class="keyword">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class="comment">// transform it to screen coordinates</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> intensity = varying_intensity*bar;   <span class="comment">// interpolate intensity for the current pixel</span></span><br><span class="line">        Vec2f uv = varying_uv*bar;                 <span class="comment">// interpolate uv for the current pixel</span></span><br><span class="line">        color = model-&gt;<span class="built_in">diffuse</span>(uv)*intensity;      <span class="comment">// well duh</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                              <span class="comment">// no, we do not discard this pixel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码中添加了一个2行3列的纹理坐标矩阵，每列是一个顶点的纹理坐标，将它右乘3*1的重心坐标，插值得到2*1的片元纹理坐标，然后调用diffuse方法找到纹理颜色，该方法和我们之前实现的方法类似，它直接使用TGAColor中的get方法返回颜色值。效果在下面：</p>
<p><img src="/2023/08/03/tinyRenderer4/3.png" alt></p>
<h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h3><p>除了纹理外，法线贴图也是常见的模型贴图，它能在不改变模型本身几何形状的条件下通过对法线值的修改，影响光照情况的计算，从而让模型看起来凹凸不平，增强立体感。在世界空间下的法线贴图是下面这样的：</p>
<p><img src="/2023/08/03/tinyRenderer4/4.png" alt></p>
<p>它的RGB值存储了该坐标上对应的法线值。但是我们一般使用切线空间下的法线图：</p>
<p><img src="/2023/08/03/tinyRenderer4/5.png" alt></p>
<p>切线空间和世界空间不同，它的z轴和法线方向一致，x轴以建模时uv展开的方向为准，y轴则通过xz的叉积计算。上面图中多数地方是蓝色的，这就是因为多数地方法线的扰动不强，而RGB的B存储的是和法线方向一致的z轴的值，因此多数地方就表现为蓝色，这意味着它们没有受到xy的干扰，xy分量很小。</p>
<p>为什么常用切线空间？相比于世界空间下的法线图，它存储的信息更少了，因为多数地方的扰动都不强。上面的例子中，世界空间下的法线图大小为1.91MB，而切线空间下的法线图为1.68MB，节省了存储空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shader</span> : <span class="keyword">public</span> IShader &#123;</span><br><span class="line">    mat&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="type">float</span>&gt; varying_uv;  <span class="comment">// same as above</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="type">float</span>&gt; uniform_M;   <span class="comment">//  Projection*ModelView</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="type">float</span>&gt; uniform_MIT; <span class="comment">// (Projection*ModelView).invert_transpose()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="type">int</span> iface, <span class="type">int</span> nthvert)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找到纹理坐标</span></span><br><span class="line">        varying_uv.<span class="built_in">set_col</span>(nthvert, model-&gt;<span class="built_in">uv</span>(iface, nthvert));</span><br><span class="line">        Vec4f gl_Vertex = <span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(model-&gt;<span class="built_in">vert</span>(iface, nthvert)); <span class="comment">// read the vertex from .obj file</span></span><br><span class="line">        <span class="keyword">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class="comment">// transform it to screen coordinates</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//插值纹理坐标</span></span><br><span class="line">        Vec2f uv = varying_uv*bar;                 <span class="comment">// interpolate uv for the current pixel</span></span><br><span class="line">        <span class="comment">//使用世界坐标的法线，变换法线到裁剪空间</span></span><br><span class="line">        Vec3f n = <span class="built_in">proj</span>&lt;<span class="number">3</span>&gt;(uniform_MIT*<span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(model-&gt;<span class="built_in">normal</span>(uv))).<span class="built_in">normalize</span>();</span><br><span class="line">        <span class="comment">//变换光照到裁剪空间</span></span><br><span class="line">        Vec3f l = <span class="built_in">proj</span>&lt;<span class="number">3</span>&gt;(uniform_M  *<span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(light_dir        )).<span class="built_in">normalize</span>();</span><br><span class="line">        <span class="type">float</span> intensity = std::<span class="built_in">max</span>(<span class="number">0.f</span>, n*l);</span><br><span class="line">        color = model-&gt;<span class="built_in">diffuse</span>(uv)*intensity;      <span class="comment">// well duh</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                              <span class="comment">// no, we do not discard this pixel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们选择在经过模型、透视变换之后再计算光照情况，但这里的方法并不唯一，一般情况为了方便其它值的计算，我们实际编写Shader的时候直接在世界空间或者切线空间中进行计算，省去了一次变换，最终要的结果是它们两个的点积，所以无论在哪个空间中，它们的余弦值不会改变，得到的效果基本相同，有时因为浮点数之类的精度问题可能有少许差别，但是总体没什么变化。</p>
<p>上面声明了两个uniform变量，它们在GLSL中是一个声明的关键词，允许将常数值传递给Shader使用。这里我们要记得在main中对它们初始化一次，因为它们只需要计算一次即可，正是我们想要的常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shader shader;</span><br><span class="line">   shader.uniform_M   =  Projection*ModelView;</span><br><span class="line">   shader.uniform_MIT = (Projection*ModelView).<span class="built_in">invert_transpose</span>();</span><br></pre></td></tr></table></figure>
<p>法线变换就不说了，前面介绍过，使用变换矩阵的逆转置矩阵。</p>
<p><img src="/2023/08/03/tinyRenderer4/6.png" alt></p>
<p>明显看到人物脸上的疤痕变深了，这就是法线贴图的作用，它也被称为Bump Map。</p>
<h3 id="Phong光照"><a href="#Phong光照" class="headerlink" title="Phong光照"></a>Phong光照</h3><p>一切准备就绪，是时候把基础光照补上了。原理还是不介绍，主要说一下Phong和Blinn-Phong的区别，Phong计算反射光的方向，而Blinn-Phong计算半程向量的方向，这里采用Phong光照模型，更复杂的光照建议在Shader中编写，这里以软渲染器实现为主。</p>
<p>另外，这里Specular还是用了高光贴图，像素读取对应的高光值Glossiness作为高光计算的幂次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shader</span> : <span class="keyword">public</span> IShader &#123;</span><br><span class="line">    mat&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="type">float</span>&gt; varying_uv;  <span class="comment">// same as above</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="type">float</span>&gt; uniform_M;   <span class="comment">//  Projection*ModelView</span></span><br><span class="line">    mat&lt;<span class="number">4</span>,<span class="number">4</span>,<span class="type">float</span>&gt; uniform_MIT; <span class="comment">// (Projection*ModelView).invert_transpose()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec4f <span class="title">vertex</span><span class="params">(<span class="type">int</span> iface, <span class="type">int</span> nthvert)</span> </span>&#123;</span><br><span class="line">        varying_uv.<span class="built_in">set_col</span>(nthvert, model-&gt;<span class="built_in">uv</span>(iface, nthvert));</span><br><span class="line">        Vec4f gl_Vertex = <span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(model-&gt;<span class="built_in">vert</span>(iface, nthvert)); <span class="comment">// read the vertex from .obj file</span></span><br><span class="line">        <span class="keyword">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class="comment">// transform it to screen coordinates</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fragment</span><span class="params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class="line">        Vec2f uv = varying_uv*bar;</span><br><span class="line">        Vec3f n = <span class="built_in">proj</span>&lt;<span class="number">3</span>&gt;(uniform_MIT*<span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(model-&gt;<span class="built_in">normal</span>(uv))).<span class="built_in">normalize</span>();</span><br><span class="line">        Vec3f l = <span class="built_in">proj</span>&lt;<span class="number">3</span>&gt;(uniform_M  *<span class="built_in">embed</span>&lt;<span class="number">4</span>&gt;(light_dir        )).<span class="built_in">normalize</span>();</span><br><span class="line">        Vec3f r = (n*(n*l*<span class="number">2.f</span>) - l).<span class="built_in">normalize</span>();   <span class="comment">// reflected light</span></span><br><span class="line">        <span class="type">float</span> spec = <span class="built_in">pow</span>(std::<span class="built_in">max</span>(r.z, <span class="number">0.0f</span>), model-&gt;<span class="built_in">specular</span>(uv));</span><br><span class="line">        <span class="type">float</span> diff = std::<span class="built_in">max</span>(<span class="number">0.f</span>, n*l);</span><br><span class="line">        TGAColor c = model-&gt;<span class="built_in">diffuse</span>(uv);</span><br><span class="line">        color = c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) color[i] = std::<span class="built_in">min</span>&lt;<span class="type">float</span>&gt;(<span class="number">5</span> + c[i]*(diff + <span class="number">.6</span>*spec), <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和前面一个Shader相比，我们唯一添加的内容就是Specular，原本我们对Phong光照的Ambient，Diffuse，Specular都有直接的输入，不过这里将它们简化成一个浮点数模拟光强，其中反射光线的z值表示反射光是否对准了摄像机，因此可以进一步简化，而没有常规地比较反射光和观察方向的夹角，也能达到不错的效果。</p>
<p>人物现在更加真实了：</p>
<p><img src="/2023/08/03/tinyRenderer4/7.png" alt></p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Graphics API</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity GameFramework框架笔记(二)</title>
    <url>/2023/10/25/ugf2/</url>
    <content><![CDATA[<p>了解了Procedure的基本用法，得继续往下看看游戏如何开始运行的。</p>
<span id="more"></span>
<h1 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h1><p>回顾一下，被Procedure设置为Entrance Procedure的ProcudureLaunch脚本重写了OnEnter方法和OnUpdate方法，其中OnEnter方法执行的都是一些初始化的操作，对我们的游戏场景没有影响。那应该就是OnUpdate方法起了作用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params">ProcedureOwner procedureOwner, <span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnUpdate(procedureOwner, elapseSeconds, realElapseSeconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行一帧即切换到 Splash 展示流程</span></span><br><span class="line">    ChangeState&lt;ProcedureSplash&gt;(procedureOwner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Base类的OnUpdate方法是空的，那肯定是这个ChangeState方法将目前的流程改变了，改到了这个名为ProcedureSplash的流程。所以我们结束对Launch的探索，看看Splash是干嘛的。它重写了一个OnUpdate方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params">ProcedureOwner procedureOwner, <span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnUpdate(procedureOwner, elapseSeconds, realElapseSeconds);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 这里可以播放一个 Splash 动画</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (GameEntry.Base.EditorResourceMode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 编辑器模式</span></span><br><span class="line">                Log.Info(<span class="string">&quot;Editor resource mode detected.&quot;</span>);</span><br><span class="line">                ChangeState&lt;ProcedurePreload&gt;(procedureOwner);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (GameEntry.Resource.ResourceMode == ResourceMode.Package)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 单机模式</span></span><br><span class="line">                Log.Info(<span class="string">&quot;Package resource mode detected.&quot;</span>);</span><br><span class="line">                ChangeState&lt;ProcedureInitResources&gt;(procedureOwner);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 可更新模式</span></span><br><span class="line">                Log.Info(<span class="string">&quot;Updatable resource mode detected.&quot;</span>);</span><br><span class="line">                ChangeState&lt;ProcedureCheckVersion&gt;(procedureOwner);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到该方法根据当前游戏运行的状态输出一个Log，然后跳转到不同的状态。根据之前显示的”Editor resource mode detected.”，那我们跳转的应该是ProcedurePreload状态，也就是编辑器内运行。</p>
<p><img src="/2023/10/25/ugf2/4.png" alt></p>
<p>看名字这应该是一个加载资源的流程，其中重写了OnEnter、OnLeave、OnUpdate方法，进入状态时执行OnEnter方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">ProcedureOwner procedureOwner</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnEnter(procedureOwner);</span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">            GameEntry.Event.Subscribe(LoadConfigSuccessEventArgs.EventId, OnLoadConfigSuccess);</span><br><span class="line">            GameEntry.Event.Subscribe(LoadConfigFailureEventArgs.EventId, OnLoadConfigFailure);</span><br><span class="line">            GameEntry.Event.Subscribe(LoadDataTableSuccessEventArgs.EventId, OnLoadDataTableSuccess);</span><br><span class="line">            GameEntry.Event.Subscribe(LoadDataTableFailureEventArgs.EventId, OnLoadDataTableFailure);</span><br><span class="line">            GameEntry.Event.Subscribe(LoadDictionarySuccessEventArgs.EventId, OnLoadDictionarySuccess);</span><br><span class="line">            GameEntry.Event.Subscribe(LoadDictionaryFailureEventArgs.EventId, OnLoadDictionaryFailure);</span><br><span class="line"></span><br><span class="line">            m_LoadedFlag.Clear();</span><br><span class="line"></span><br><span class="line">            PreloadResources();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>里面订阅了六个事件，分别对应加载配置成功和失败、加载表格数据成功和失败、加载字典成功和失败。此外还初始化了一下成员m_LoadedFlag，它是一个Dictionary<string, bool>的字典，标志着名称为string的资源是否加载完成。</string,></p>
<ul>
<li><strong>事件</strong>(Event) - 游戏逻辑监听、抛出事件的机制。Game Framework 中的很多模块在完成操作后都会抛出内置事件，监听这些事件将大大解除游戏逻辑之间的耦合。用户也可以定义自己的游戏逻辑事件。</li>
</ul>
<p>这里我们学习到另一个重要工具-事件的使用。事件主要是为了接触耦合提出的，这就涉及到委托特性了，这里相当于封装好了一套订阅事件的方法，首先需要一个id标记事件，我们进一步查看，发现这个id定义在<strong>LoadConfigSuccessEventArgs</strong>类中，它继承了<strong>GameEventArgs</strong>，进一步查看它是这里封装的事件基类，真正继承的是<strong>GameFrameworkEventArgs</strong>，id实际上就是这个类的哈希值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> EventId = <span class="keyword">typeof</span>(LoadConfigSuccessEventArgs).GetHashCode();</span><br></pre></td></tr></table></figure>
<p>那么我们六个事件实际上就需要定义六个类继承自GameEventArgs。可是为什么这个类名称都带有Args呢？它是什么Arguments吗？我们先看到还需要一个指定的委托作为订阅方法的第二个参数，当前面id标识的事件触发后，连带着调用后面订阅的方法，而不需要主动调用。问题就在这里，你可能会疑惑这里为什么不用传递委托方法需要的参数，而是直接写了参数名，原因在于使用了C#的EventArgs，它是前面<strong>GameFrameworkEventArgs</strong>的真正的基类，事件参数类，它规定了事件必须具备两个参数，一个是发布者sender，一个就是参数类args，这也是前面的类名带有args的原因。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被订阅的事件方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnLoadConfigSuccess</span>(<span class="params"><span class="built_in">object</span> sender, GameEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            LoadConfigSuccessEventArgs ne = (LoadConfigSuccessEventArgs)e;</span><br><span class="line">            <span class="keyword">if</span> (ne.UserData != <span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m_LoadedFlag[ne.ConfigAssetName] = <span class="literal">true</span>;</span><br><span class="line">            Log.Info(<span class="string">&quot;Load config &#x27;&#123;0&#125;&#x27; OK.&quot;</span>, ne.ConfigAssetName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数类中封装的方法，实际在添加委托的时候执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoadConfigSuccessEventArgs <span class="title">Create</span>(<span class="params">ReadDataSuccessEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            LoadConfigSuccessEventArgs loadConfigSuccessEventArgs = ReferencePool.Acquire&lt;LoadConfigSuccessEventArgs&gt;();</span><br><span class="line">            loadConfigSuccessEventArgs.ConfigAssetName = e.DataAssetName;</span><br><span class="line">            loadConfigSuccessEventArgs.Duration = e.Duration;</span><br><span class="line">            loadConfigSuccessEventArgs.UserData = e.UserData;</span><br><span class="line">            <span class="keyword">return</span> loadConfigSuccessEventArgs;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>用第一个事件为例，OnLoadConfigSuccess在配置成功的时候被调用，具有两个规定的参数，它们是使用EventArgs必须的，sender发布者就是拥有该事件的类对象，事件参数类就是LoadConfigSuccessEventArgs，它层层包装，继承自EventArgs，类内定义了Create方法返回LoadConfigSuccessEventArgs类型的值，从而完成参数的传递。刚方法在添加委托的时候被执行，发布者发布事件的时候需要用类似泛型声明的方式来指定使用这个类，剩下的就是内部类的工作了，能将发布者类和参数类匹配到等待赋值的sender和e上面，就完成了参数的传递。</p>
<p>在<a href="https://learn.microsoft.com/zh-cn/dotnet/standard/events/">微软文档</a>中关于需要使用参数的事件是这么介绍的：</p>
<p><img src="/2023/10/25/ugf2/1.png" alt></p>
<p>我们还是以框架为主，C#相关内容尽量减少。OnEnter最后紧接着调用类中定义的私有方法做数据加载的操作PreloadResources()：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PreloadResources</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Preload configs</span></span><br><span class="line">            LoadConfig(<span class="string">&quot;DefaultConfig&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Preload data tables</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">string</span> dataTableName <span class="keyword">in</span> DataTableNames)</span><br><span class="line">            &#123;</span><br><span class="line">                LoadDataTable(dataTableName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Preload dictionaries</span></span><br><span class="line">            LoadDictionary(<span class="string">&quot;Default&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Preload fonts</span></span><br><span class="line">            LoadFont(<span class="string">&quot;MainFont&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>它首先调用类内私有方法LoadConfig：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadConfig</span>(<span class="params"><span class="built_in">string</span> configName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> configAssetName = AssetUtility.GetConfigAsset(configName, <span class="literal">false</span>);</span><br><span class="line">            m_LoadedFlag.Add(configAssetName, <span class="literal">false</span>);</span><br><span class="line">            GameEntry.Config.ReadData(configAssetName, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法首先调用AssetUtility.GetConfigAsset将传入的字符串拼接成本地路径，然后将这个路径放到字典里面，接着读取这个路径的资源文件，这里ReadData方法没找到方法体在哪里，后面再说。</p>
<p>遍历dataTableName中的每一个数据表名称，然后加载它们，相应的OnLeave方法里面就取消这些事件的订阅。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnLeave</span>(<span class="params">ProcedureOwner procedureOwner, <span class="built_in">bool</span> isShutdown</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GameEntry.Event.Unsubscribe(LoadConfigSuccessEventArgs.EventId, OnLoadConfigSuccess);</span><br><span class="line">            GameEntry.Event.Unsubscribe(LoadConfigFailureEventArgs.EventId, OnLoadConfigFailure);</span><br><span class="line">            GameEntry.Event.Unsubscribe(LoadDataTableSuccessEventArgs.EventId, OnLoadDataTableSuccess);</span><br><span class="line">            GameEntry.Event.Unsubscribe(LoadDataTableFailureEventArgs.EventId, OnLoadDataTableFailure);</span><br><span class="line">            GameEntry.Event.Unsubscribe(LoadDictionarySuccessEventArgs.EventId, OnLoadDictionarySuccess);</span><br><span class="line">            GameEntry.Event.Unsubscribe(LoadDictionaryFailureEventArgs.EventId, OnLoadDictionaryFailure);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">base</span>.OnLeave(procedureOwner, isShutdown);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>我们再看Update里面：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params">ProcedureOwner procedureOwner, <span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnUpdate(procedureOwner, elapseSeconds, realElapseSeconds);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt; loadedFlag <span class="keyword">in</span> m_LoadedFlag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!loadedFlag.Value)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            procedureOwner.SetData&lt;VarInt32&gt;(<span class="string">&quot;NextSceneId&quot;</span>, GameEntry.Config.GetInt(<span class="string">&quot;Scene.Menu&quot;</span>));</span><br><span class="line">            ChangeState&lt;ProcedureChangeScene&gt;(procedureOwner);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>Update对m_LoadedFlag中的每个元素进行了判断，如果加载没成功就返回，否则判断到完成了资源加载，之后用 procedureOwner.SetData方法来设置下一个场景的编号，跳转到Menu中。最后还要改变流程到ProcedureChangeScene。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
        <category>GameFramework</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity GameFramework框架笔记(三)</title>
    <url>/2023/11/07/ugf3/</url>
    <content><![CDATA[<p>上一节学习了事件。</p>
<span id="more"></span>
<p>ProcedureChangeScene是一个中间流程，</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
        <category>GameFramework</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity和Shader入门（一）</title>
    <url>/2023/04/11/uni-shader1/</url>
    <content><![CDATA[<p>用冯乐乐大神的《Unity Shader入门精要》入门，记录个人整理的知识点和代码。Unity的Shader并不是真正意义上的Shader，实际上更像一种Shader的高级语言，因此常说是shader of Unity。而这个系列的博客主要是Shader的学习笔记，Unity的使用在Unity初始和入门系列博客中。本篇博客介绍渲染流水线和Unity Shader的概念。</p>
<span id="more"></span>
<h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><h2 id="概念流水线"><a href="#概念流水线" class="headerlink" title="概念流水线"></a>概念流水线</h2><p>学过图形学的同学肯定知道一般来说图形从定义顶点、颜色等信息开始到显示在屏幕上会经过渲染管线这个东西，其实也叫做渲染流水线，在另外一本著作《Real-Time Rendering》中，作者将渲染管线分成三个部分：</p>
<ul>
<li>Application Stage;</li>
<li>Geometry Stage;</li>
<li>Rasterizer Stage;</li>
</ul>
<p>应用阶段进行数据准备，包括模型、摄像机、光源，可见面剔除，材质，纹理，使用的Shader，总的来说就是处理好渲染需要的集合信息，称为渲染图元(rendering primitives)，传递给几何阶段；</p>
<p>几何阶段用于绘制渲染图元，把上一个阶段的坐标变换到屏幕空间，输出各个顶点的二维坐标，深度值，着色信息，传递给下一个阶段；</p>
<p>光栅化阶段通过几何阶段传来的信息，进行插值，光栅化等操作，控制屏幕上的像素绘制出最终的图形。</p>
<h2 id="CPU执行（应用阶段）"><a href="#CPU执行（应用阶段）" class="headerlink" title="CPU执行（应用阶段）"></a>CPU执行（应用阶段）</h2><p>这一阶段主要是程序员绝对控制数据，在Unity开发中体现为导入资产，地形编辑，设置材质等操作，主要是CPU在执行，大致分为三个阶段：</p>
<ul>
<li>加载数据到显存中；</li>
<li>设置渲染状态；</li>
<li>调用Draw Call；</li>
</ul>
<p>学习过操作系统或组成原理可以知道，要将数据存放到GPU的显存中，先要读取硬盘中的数据到内存中，在让数据流向GPU，因为多数GPU不能直接访问内存，而且对显存的访问很快。</p>
<p>渲染状态是，定义场景中的网格怎么渲染，绑定Shader，材质，光源等内容。</p>
<p>做好准备后，CPU调用渲染命令Draw Call通知GPU开始渲染，这个命令指向一个待渲染的图元列表，不包括任何材质信息，因为材质在渲染状态中已经定义了。</p>
<h2 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h2><p>GPU的渲染过程就是GPU流水线，它实现了几何阶段和光栅化阶段，不能完全被程序员掌控，但是GPU也开放了很多控制权。下面我们详细说明几何阶段和光栅阶段中数据经历了什么变换。</p>
<p>在之前Games101课程的笔记中，曾经记录了一个大致的渲染管线，我当时以为它就是完整的，但是现在看来它只不过是我们这里介绍的后两个阶段的概述，图形学中介绍了这部分知识，仍然不完整，因此值得从头到尾梳理一下。（下面这个图本来是彩色的，书到了补上，不同颜色表示该阶段的可编程性）</p>
<p><img src="/2023/04/11/uni-shader1/1.png" alt></p>
<h3 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h3><p>顶点数据由应用阶段中CPU加载到显存中，再由Draw Call指定，依次经过：</p>
<ul>
<li>顶点着色器(Vertex Shader)：完全可编程，实现顶点变换，着色等功能；</li>
</ul>
<blockquote>
<p>处理来自CPU的顶点数据，但是只是单个顶点，不包括顶点之间的关系，从而方便并行处理每个顶点；这一阶段的主要任务是：坐标变换和逐顶点光照。</p>
<ul>
<li>坐标变换：对顶点坐标进行变换，从而进行水面、布料等模拟效果，实现动画效果，最基本的是将顶点坐标从模型空间转换到齐次裁剪空间，也就是得到归一化设备坐标(Normalized Devices Coordinates，NDC)</li>
</ul>
</blockquote>
<ul>
<li><p>曲面系分着色器(Tessellation Shader)：可选，用于细分图元；</p>
</li>
<li><p>几何着色器(Geometry Shader)：可选，执行逐图元的着色操作或者产生更多图元；</p>
</li>
<li>裁剪(Clipping)：可配置，将不可见的顶点和面片剔除；</li>
</ul>
<blockquote>
<p>图元不一定都在屏幕中，在屏幕外的图元要抛弃，在屏幕内的图元就传递下去，但是对于一部分在屏幕内一部分在屏幕外的图元就需要裁剪，这一步不可编程，但是可以定义裁剪操作来进行配置</p>
</blockquote>
<ul>
<li>屏幕映射(Screen Mapping)：不可编程和配置，将图元坐标转换为屏幕坐标系；</li>
</ul>
<blockquote>
<p>将归一化的坐标缩放到屏幕坐标(x，y)，对z轴不处理，一起输入光栅化阶段</p>
</blockquote>
<h3 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h3><ul>
<li>三角形设置(Triangle Setup)：不可编程，固定函数；</li>
</ul>
<blockquote>
<p>由三角性的顶点数据计算三角形各条边的坐标，给下一个阶段做准备；</p>
</blockquote>
<ul>
<li>三角形遍历(Triangle Traversal)：不可编程，固定函数；</li>
</ul>
<blockquote>
<p>根据上一个阶段的数据，检查一个像素会不会被三角形覆盖，如果覆盖，就生成一个片元Fragment，还要插值计算整个覆盖区域的的像素，以及片元的深度值。输出一个片元序列，片元不是像素，而是包括该像素位置上的很多状态信息，例如屏幕深度，坐标，法线等</p>
</blockquote>
<ul>
<li>片元着色器(Fragment Shader)：完全可编程，实现逐片元的着色操作；</li>
</ul>
<blockquote>
<p>根据上一步插值得到的数据计算该片元的输出颜色，纹理映射就是这个阶段实现的，而且每个片元的颜色相互独立</p>
</blockquote>
<ul>
<li>逐片元操作(Per-Fragment Operations)：可配置，实现修改颜色、深度缓冲、混合等操作；</li>
</ul>
<blockquote>
<p>决定片元的可见性，模板测试和深度测试；如果都通过了，将片元的颜色值同已经存储在缓冲区中的颜色进行混合或者合并，不透明物体不用开启混合。很多时候为了优化性能，测试也会在片元着色器之前计算，防止计算无效的片元颜色</p>
</blockquote>
<h1 id="什么是Shader？"><a href="#什么是Shader？" class="headerlink" title="什么是Shader？"></a>什么是Shader？</h1><p>现在我们明白，Shader就是渲染流水线中高度可编程的阶段，最终编译结果会运行在GPU上，而且存在特定的着色器，如顶点、片元着色器，前者用来顶点变换、传递数据，后者用来进行逐像素渲染。</p>
<p>Unity提供的Shader并不是HLSL或者GLSL，GC这样的更接近GPU的Shader语言，而是更高级的编辑工具，既方便了着色器编写，又可以设置渲染状态。</p>
<h1 id="Unity-Shader基础"><a href="#Unity-Shader基础" class="headerlink" title="Unity Shader基础"></a>Unity Shader基础</h1><p>没有Unity Shader时，为了渲染一个模型会是这样的代码：</p>
<p><img src="/2023/04/11/uni-shader1/2.png" alt></p>
<p><img src="/2023/04/11/uni-shader1/3.png" alt></p>
<p><img src="/2023/04/11/uni-shader1/4.png" alt></p>
<p>Unity Shader方便了上面繁琐的过程，不用使用代码管理多个文件和函数。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="材质和Unity-Shader"><a href="#材质和Unity-Shader" class="headerlink" title="材质和Unity Shader"></a>材质和Unity Shader</h3><p>在Unity中我们需要配合使用材质和Shader才能达到需要的效果，使用步骤是：</p>
<ul>
<li>创建材质</li>
<li>创建Unity Shader并赋给材质</li>
<li>材质赋给渲染对象</li>
<li>在材质面板中调整Unity Shader属性控制效果</li>
</ul>
<p><img src="/2023/04/11/uni-shader1/5.png" alt></p>
<p>Unity Shader定义的属性，会和脚本定义的属性一样显示在窗口中。</p>
<p>材质的创建：</p>
<ul>
<li>Assets或者Project窗口/Create/Material；</li>
<li>将这个Material文件拖拽到场景中目标物体或者在物体的Mseh Renderer组件中赋值；</li>
</ul>
<p>默认情况下，新建材质会使用Standard Shader，一种基于物理模拟的渲染。</p>
<p>Unity Shader的创建：</p>
<ul>
<li>Assets或者Project窗口/Create/Shader；</li>
</ul>
<blockquote>
<p>Unity提供四种Unity Shader模板，Standard Surface Shader包含标准光照模型，Unlit Shader产生一个不含光照但包含烟雾的基本着色器，Image Effect Shader提供实现各种屏幕后处理效果的基本模板，Compute Shader提供典型的表面着色器的实现方法，这本书主要用Unlit Shader</p>
</blockquote>
<ul>
<li>在材质的属性菜单中选择使用的Shader；</li>
</ul>
<p>选中一个Shader后，Inspector窗口中会显示该Unity Shader相关的信息。</p>
<h3 id="ShaderLab和Unity-Shader"><a href="#ShaderLab和Unity-Shader" class="headerlink" title="ShaderLab和Unity Shader"></a>ShaderLab和Unity Shader</h3><p>ShaderLab是Unity Shader使用的Shader跨平台抽象语言，后面我们会知道，在Pass中编写的ShaderLab语言其实和Cg/HLSL两种语言是差不多的，但是ShaderLab本身于其他Shader代码来说就如同Python于C语言一样，当然这个比喻可能不是十分恰当。通过{}作为语义标识来描述Shader文件的结构，一般来说，一个Shader可以由下面的例子来说明它的结构：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">shader <span class="string">&quot;Custom/Simple Shader&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color(<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>)</span><br><span class="line">        _Boundary(<span class="string">&quot;Boundary&quot;</span>, Float) = <span class="number">100</span></span><br><span class="line">		_K(<span class="string">&quot;Max Iteration&quot;</span>, Int) = <span class="number">256</span></span><br><span class="line">        _p(<span class="string">&quot;Offset of x&quot;</span>, Float) = <span class="number">-1</span></span><br><span class="line">        _q(<span class="string">&quot;Offset of y&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="built_in">float</span> _Boundary;</span><br><span class="line">			<span class="built_in">int</span> _K;</span><br><span class="line">            <span class="built_in">float</span> _p;</span><br><span class="line">            <span class="built_in">float</span> _q;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">                float3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">a2v v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                o.color = v.normal * <span class="number">0.5</span> + fixed3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">fixed2 <span class="title">iteration</span>(<span class="params">fixed2 pos</span>)</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">fixed</span> x2 = pos.x * pos.x;</span><br><span class="line">				<span class="keyword">fixed</span> y2 = pos.y * pos.y;</span><br><span class="line">				<span class="keyword">fixed</span> xy = pos.x * pos.y;</span><br><span class="line">				<span class="keyword">fixed</span> rx = (x2 - y2);</span><br><span class="line">				<span class="keyword">fixed</span> ry = (<span class="number">2</span> * xy);</span><br><span class="line">				fixed2 result = fixed2(rx + _p, ry + _q);</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="function">fixed4 <span class="title">fractal</span>(<span class="params">fixed2 pos, fixed4 cor</span>)</span></span><br><span class="line">			&#123;</span><br><span class="line">				fixed2 pos1 = pos;</span><br><span class="line">				fixed2 posF = pos;</span><br><span class="line">				<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _K; i++) &#123;</span><br><span class="line">					posF = iteration(posF);</span><br><span class="line">                    <span class="keyword">fixed</span> r = (posF.x * posF.x + posF.y * posF.y);</span><br><span class="line">                    <span class="keyword">if</span>(r &gt; _Boundary)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> cor;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i == _K<span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> fixed4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line">                    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> cor;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 curCol = fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">                fixed2 pos = i.vertex;</span><br><span class="line">                <span class="built_in">float</span> width = <span class="number">1980</span>;</span><br><span class="line">                <span class="built_in">float</span> height = <span class="number">1080</span>;</span><br><span class="line">                <span class="built_in">float</span> dx = <span class="number">2</span> / (width<span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">float</span> dy = <span class="number">2</span> / (height - <span class="number">1</span>);</span><br><span class="line">                fixed2 complexPos = fixed2(<span class="number">-1</span> + pos.x * dx, <span class="number">-1</span> + pos.y * dy);</span><br><span class="line">                curCol = fractal(complexPos, curCol);</span><br><span class="line">                <span class="keyword">return</span> curCol * _Color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Properties：可以添加需要出现在材质面板中的属性，包括数值、纹理等，在这里创建的属性需要到Pass中声明才能引用；</li>
<li><p>SubShader：一个Unity Shader中可能包含多个SubShader，Unity会选择第一个能够运行的SubShader执行，如果一个都不能执行，Unity将会选择Fallback指定的着色器；一个SubShader可能含有多个Pass，这些Pass将全部被执行；在SubShader顶部可以使用可选的Tags和RenderSetup来指定使用的渲染设置；</p>
</li>
<li><p>指定如果没有可运行的SubShader时选择什么着色器；</p>
</li>
</ul>
<p>你不需要完全了解其中的含义，只要知道Shader由这三个结构组成即可，后面我们会了解这个Shader的作用，它使用了除Tags和RenderSetup以外的所有Shader结构，在屏幕上绘制一个Julia集合。此外，我们还要知道这个Shader使用了顶点和片元着色器，它们是我们接下来学习的重点，#pragma语句指定了哪个函数作为着色器使用。可以看到，Pass中是我们重点要编写的代码，它定义了一次完整的渲染流程。</p>
<p>下一篇开始我们将正式进入学习。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity和Shader入门（三）</title>
    <url>/2023/05/20/uni-shader3/</url>
    <content><![CDATA[<p>用冯乐乐大神的《Unity Shader入门精要》入门，记录个人整理的知识点和代码。现在我们进入光照部分，原理见Games101，这里注重实现不再赘述原理；纹理基础也在这一篇博客中。</p>
<span id="more"></span>
<h1 id="Phong光照模型-基础光照"><a href="#Phong光照模型-基础光照" class="headerlink" title="Phong光照模型-基础光照"></a>Phong光照模型-基础光照</h1><p>光照=环境光+漫反射+镜面光是Phong模型的基本假设，下面给出Unity Shader实现的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Shader &quot;Learn/Specular Pixel-Level&quot;</span><br><span class="line">&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Diffuse (&quot;Diffuse&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_Specular (&quot;Specular&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_Gloss (&quot;Gloss&quot;, Range(8.0,256)) = 20</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line">			#pragma vertex vert</span><br><span class="line">			#pragma fragment frag</span><br><span class="line"></span><br><span class="line">			#include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">			fixed4 _Diffuse;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			float _Gloss;</span><br><span class="line"></span><br><span class="line">			struct a2v&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f&#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v)&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">				return o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line"></span><br><span class="line">				//ambient</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">				fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">				//diffuse</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">				//specular</span><br><span class="line">				fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line">				fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">				return fixed4( ambient + diffuse + specular, 1.0);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们定义三个属性，Diffuse是材质漫反射的颜色，Specular是镜面光反射的颜色，Gloss则是容忍度，控制镜面光的大小。然后在v2f中我们声明了worldNormal为世界坐标系下片元的法线矢量，worldPos是片元在世界坐标系下的坐标，然后vert顶点着色器中我们对worldNomal右乘了一个截断为3x3的变换矩阵，该矩阵是从世界坐标系到模型坐标系的变换矩阵，这里你可能有疑惑，为什么是右乘，而且为什么是世界到模型而不是模型到世界？为什么截断？由于我们要对一个矢量进行变换，可以知道矢量的位移是没有意义的，因此可以截断齐次坐标矩阵的3x3对矢量进行变换。下面扩展阅读中解释了这个原因，本质上还是数学变换的内容。</p>
<blockquote>
<p>对法线进行变换和对一般矢量进行变换不同，对于模型上一个切线矢量来说，由于它是两个顶点做差得到的，所以对顶点的变化也适用于切线变换；但是法线不行，如果直接使用一样的变换矩阵变换法线，得到的法线和可能和变换后的顶点不垂直。</p>
<p><img src="/2023/05/20/uni-shader3/1.png" alt></p>
<p>非同一缩放就是xyz轴不等地缩放，通过之前学习我们可以知道，一个变换矩阵只有仅包含旋转、统一缩放的时候才是正交矩阵，其转置等于逆，我们后面再说。这里问题在于法线变换的时候没考虑约束，即法线N和切线T垂直，我们既然知道切线可以直接变换，那么应用这个垂直关系推导法线变换G：</p>
<p><img src="/2023/05/20/uni-shader3/2.png" alt></p>
<p>也就是说只要$M_{A-&gt;B}^TG = I$，也就是说法线的变换为顶点变换矩阵的逆的转置。当顶点变换矩阵正交，两者就是相同的。所以这里我们通过右乘来表示转置，模型到世界的逆变换自然就是世界到模型了。</p>
</blockquote>
<p>下面vert还计算了世界坐标系下顶点的位置worldPos，后面我们需要它来计算观察方向。在frag片元着色器中，首先用语义获取了ambient，然后读取存储在v2f中的世界坐标系下的法线矢量。使用WorldSpaceLightPos0.xyz语义获取世界坐标系下平行光源的位置作为光源方向，可以将位置看作从原点到光源位置的方向矢量，注意这个方式并不通用。之后首先计算漫反射，LightColor0.rgb是光照强度，Diffuse.rgb是我们定义的漫反射颜色，然后saturate函数可以将数值限定在[0,1]中，得到法线和光照的余弦值，其实就是按照公式计算了Diffuse。</p>
<p>然后是镜面反射，我们要计算反射光矢量，由于内置的reflect函数要求光线方向为从光源指向和法线的交点，所以这里取反计算，观察方向则是用世界坐标系下摄像机位置减去片元位置得到的，也就是指向片元。</p>
<p>之后也是按照公式计算，使用了pow函数来做幂次运算。</p>
<p><img src="/2023/05/20/uni-shader3/3.png" alt></p>
<h2 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h2><p>和Phong模型唯一的区别就是修改了镜面光的计算，使用半程向量进行了简化，所以我们修改frag函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line"></span><br><span class="line">				//ambient</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">				fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">				//diffuse</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">				//specular</span><br><span class="line">				fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">				fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">				return fixed4( ambient + diffuse + specular, 1.0);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>就得到Blinn-Phong的代码了。</p>
<p><img src="/2023/05/20/uni-shader3/4.png" alt></p>
<p>最后我们说明，代码中使用ForwardBase的光照模式，称为前向渲染，只需要知道只有在该模式下才能通过语义获取默写光照相关的信息。此外，我们这里计算是从原理出发的做法，实际编写时Unity提供了很多内置函数来完成复杂的运算，我们以后再使用，这并不代表不需要清楚原理。这里基础光照就结束了，其实可以发现还是原理重要，具体实现依靠原理，学起来也就容易多了。</p>
<p>基础光照到这里就完成了，我的另一篇博客中还进一步实现了最简单的PBR光照，看过Games101的光线追踪推导就可以移步查看，很容易看懂，PBR以后还会继续记录，LearnOpenGL中文站上给出的PBR教程对原理讲解十分清晰。</p>
<h1 id="纹理基础"><a href="#纹理基础" class="headerlink" title="纹理基础"></a>纹理基础</h1><p>下面我们将使用纹理配合光照，除了光照的颜色外，我们需要在漫反射和ambient的计算中乘上纹理的颜色，就得到增加纹理的光照了，这就是单张纹理，为此我们需要声明两个用于控制纹理的变量，一个是属性中的MainTex，它存储纹理采样的对象，也就是纹理本身；另一个是MainTex_ST，它不需要声明在Properties中，系统会将_ST识别为对应名称纹理的缩放和平移，使用.xy获取缩放，使用.zw获取平移，这两个值在材质面板中可以调节，我们后面再细说。</p>
<p>之前的两个结构体也需要更改，添加存储纹理的成员变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties</span><br><span class="line">  &#123;</span><br><span class="line">      _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line">      _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">      _Specular (&quot;Specular&quot;, Color) = (1,1,1,1)</span><br><span class="line">      _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fixed4 _Color;</span><br><span class="line">      sampler2D _MainTex;</span><br><span class="line">      float4 _MainTex_ST;</span><br><span class="line">      fixed4 _Specular;</span><br><span class="line">      float _Gloss;</span><br><span class="line">      </span><br><span class="line">struct a2v&#123;</span><br><span class="line">          float4 vertex : POSITION;</span><br><span class="line">          float3 normal : NORMAL;</span><br><span class="line">          float4 texcoord : TEXCOORD0;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      struct v2f&#123;</span><br><span class="line">          float4 pos : SV_POSITION;</span><br><span class="line">          float3 worldNormal : TEXCOORD0;</span><br><span class="line">          float3 worldPos : TEXCOORD1;</span><br><span class="line">          float2 uv : TEXCOORD2;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
<p>a2v中使用TEXCOORD0语义将第一组纹理坐标存储到texcoord中。那v2f中的TEXCOORD又是怎么回事呢？实际上当我们使用该语义后，文档中解释说Unity会将纹理的不同套坐标存储到对应的变量中，因为建模出来的模型上一个顶点很可能含有多套坐标，用于不同的计算，例如光照、凹凸、法线等，但是其实任意高精度数据都可以使用TEXCOORD指定，类似的对于低精度范围在0和1之间的值可以用COLOR指定。</p>
<p>因此我们这里v2f中虽然使用了这个语义，但是实际上并没有真正使用，存储的值还是原本的意义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">            o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">            return o;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>顶点着色器中，除了计算裁剪空间、世界空间的顶点位置，还有世界空间的顶点法线外，我们还计算了纹理坐标uv，使用a2v的texcoord.xy读取了该顶点的纹理映射坐标，然后乘以缩放值MainTex_ST.xy，加上偏移MainTex_ST.zw，下面会详细说明这个属性。最终才得到顶点真正的纹理坐标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">            fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">            fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">            fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">            fixed3 diffuse = _LightColor0.rgb * albedo * max(0,dot(worldNormal, worldLightDir));</span><br><span class="line">            fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">            fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">            fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">            return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>片元着色器中则是常规的Blinn-Phong光照了，只不过我们在漫反射和ambient的计算中添加了纹理采样的颜色albedo，这个颜色通过函数tex2D(_MainTex, i.uv)得到，它接受纹理和采样坐标作为参数，返回该点纹理值。保存后得到下面的例子(使用的纹理在入门精要的<a href="https://github.com/candycat1992/Unity_Shaders_Book">github</a>中有)。</p>
<p><img src="/2023/05/20/uni-shader3/5.png" alt></p>
<h3 id="纹理属性的使用"><a href="#纹理属性的使用" class="headerlink" title="纹理属性的使用"></a>纹理属性的使用</h3><p>Unity中导入一个纹理后，可以在Inspector中查看属性：</p>
<p><img src="/2023/05/20/uni-shader3/6.png" alt></p>
<p>Texture Type指定了纹理的类型，这里Default就是普通纹理，还有Normal map，Cube map等选项，以后再说。选择正确的纹理类型可以让Unity正确处理和优化。其余属性在纹理导入设置的<a href="https://docs.unity3d.com/cn/2021.3/Manual/class-TextureImporter.html">文档</a>中查询，这里着重说明Wrap Mode和Filter Mode。</p>
<p>我们知道顶点的纹理坐标会被归一化到[0,1]中，有时候也会有超过这个范围的纹理坐标，就需要通过Wrap Mode来设置具体如何对它进行处理。如果选择Repeat模式，那么纹理将会不断重复，也就是舍弃纹理的整数部分，仍然视为是[0,1]内的纹理坐标；如果选择Clamp，那么将截取纹理坐标到[0,1]之间，大于1的视为1，小于0的视为0。</p>
<p>至于Filter Mode，三种模式Point、Bilinear、Trilinear分别对应Games中介绍的Nearest，Bilinear，Bicubic，简单来说就是对纹理的缩小和放大采用的模式，可以移步阅读。</p>
<p>除了导入设置外，我们还可以在材质面板中设置纹理的Tiling和Offset属性：</p>
<p><img src="/2023/05/20/uni-shader3/8.png" alt></p>
<p>其中Offset指明了纹理坐标的偏移，顶点实际uv会加上上面设置的值；Tiling可以看作为纹理的缩放，指明使用纹理的右上角的坐标，例如设置xy值为0.5将仅使用纹理的左下角四分之一区域进行映射，当uv坐标超过这个值后，根据Wrap Mode的设置会使用边界点的值或者循环到起始点。</p>
<p>所以上面的代码中你会看到，在声明纹理属性时我们除了纹理本身外，还会额外声明一个float4变量，并且命名为纹理名称_ST。</p>
<h2 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a>凹凸映射</h2><p>Games中简单提了一下做法，就是使用法线纹理，实际上我们还可以直接使用高度纹理存储模型的高度变化来直接计算，不过无疑会加大计算。所以凹凸纹理一般就采用法线纹理计算。</p>
<p>法线纹理可以是和普通纹理一样直接存储在模型空间中的纹理，这样由于顶点法线变化，得到的法线纹理就会是五颜六色的。而实际我们查看法线纹理的时候会发现通常是大片的蓝色，这是因为一般制作中我们使用的是切线空间的纹理。切线空间是以顶点原来的的法线为z轴，切线方向为x轴，两者叉积得到的负切线作为y轴。其中切线与法线垂直，并且方向根据uv坐标的u值方向确定，可以看这篇<a href="https://zhuanlan.zhihu.com/p/103546030">知乎</a>。</p>
<p>那么就很好解释为什么有大片蓝色，切线空间中如果法线纹理的值和原来的法线方向一致，那么就是(0,0,1)，对应RGB为蓝色。所以切线空间的纹理显示了法线扰动的程度，蓝色代表该点法线并不扰动。使用切线空间有以下好处：</p>
<ul>
<li>自由度高，可以应用一个法线纹理到不同模型上；</li>
<li>可以进行UV动画；</li>
<li>可以重用，例如砖块纹理只需要一块的法线纹理就行；</li>
<li>可以压缩，因为法线z总是和切线、副切线的xy垂直，可以只存储xy；</li>
</ul>
<p>这些原因导致切线空间的法线纹理更加受欢迎。</p>
<p>下面我们分别练习在切线空间和世界空间中实现凹凸映射的光照。</p>
<h3 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h3><p>这种方式让我们在顶点着色器中就完成光照和视角到切线空间的变换，效率比较高。首先我们在顶点着色器完成变换，片元着色器通过采样得到切线空间下的法线，然后与切线空间的视角方向、光照方向进行计算。如何得到模型空间到切线空间的矩阵？</p>
<p>通过数学原理(书中4.6.2的内容)，将切线方向、副切线方向、法线方向在模型空间下的矢量坐标按列排列，得到一个3*3矩阵，就是从切线空间到模型空间的变换矩阵，由于该矩阵仅包含旋转(三维不能表达平移，变换中也没有缩放)，所以是一个正交矩阵，它的逆矩阵为转置矩阵，那么将前面的三个方向矢量按行排列就得到了从模型到切线空间的变换。</p>
<p>下面我们开始编写Shader。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, 2D) = &quot;White&quot; &#123;&#125;</span><br><span class="line">		_BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">		_BumpScale (&quot;BumpScale&quot;, Float) = 1.0</span><br><span class="line">		_Specular (&quot;Specular&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_Gloss (&quot;Gloss&quot;, Range(8.0,256)) = 20</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这次我们额外声明了BumpMap和BumpScale，前者存储法线纹理图，后者调节纹理的凹凸程度。同样的，我们需要给BumpMap声明它的ST变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 _Color;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line">float4 _BumpMap_ST;</span><br><span class="line">float _BumpScale;</span><br><span class="line">fixed4 _Specular;</span><br><span class="line">float _Gloss;</span><br><span class="line"></span><br><span class="line">struct a2v&#123;</span><br><span class="line">	float4 vertex : POSITION;</span><br><span class="line">	float3 normal : NORMAL;</span><br><span class="line">	float4 tangent : TANGENT;</span><br><span class="line">	float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f&#123;</span><br><span class="line">	float4 pos : SV_POSITION;</span><br><span class="line">	float4 uv : TEXCOORD0;</span><br><span class="line">	float3 lightDir : TEXCOORD1;</span><br><span class="line">	float3 viewDir : TEXCOORD2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后是a2v结构体，我们使用tangent : TANGENT可以存储顶点的切线矢量，texcoord : TEXCOORD0存储了第一组uv坐标，因为通常来说纹理uv和法线uv是同一组uv坐标。于是在v2f中，我们还需要将切线空间中的光照方向和观察方向存进去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				//xy存普通uv，zw存法线uv</span><br><span class="line">				o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">				o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">				//计算副切线，乘以v.tangent.w以确定取哪个方向的副切线</span><br><span class="line">				float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w;</span><br><span class="line">				float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span><br><span class="line">				//TANGENT_SPACE_ROTATION;</span><br><span class="line"></span><br><span class="line">				o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">				o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line">				</span><br><span class="line">				return o;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>使用纹理的ST值计算了偏移和缩放，下面要计算顶点的副切线方向，我们用叉积函数得到法线和切线的结果，但是因为和它们垂直的方向有两个，所以还要通过切线的w分量控制副切线采用那个方向，取决于建模时采用哪个方向。之后就是按行排列得到模型到切线空间的变换矩阵，这一步可以通过内置函数TANGENT_SPACE_ROTATION完成，之前计算模型空间下副切线的方向也是这个目的。之后将模型空间中的光照和观察方向左乘这个变换矩阵，就得到了最后切线空间中的光照和观察方向，顶点着色器仅计算了这两个方向。</p>
<p>于是片元着色器中，只需获取切线空间的光照、观察方向，采样并计算切线空间的法线方向，就可以进行光照了。前两个已经计算，归一化后直接赋值。后一个我们需要先用采样函数和uv的zw值对法线纹理采样，图片像素的颜色值是[0,1]的，所以要转换到法线分量的范围[-1,1]之间，通过对z值的计算归一化为单位矢量，才能应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				fixed3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">				fixed3 tangentViewDir = normalize(i.viewDir);</span><br><span class="line">				//采样法线纹理值</span><br><span class="line">				fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">				fixed3 tangentNormal;</span><br><span class="line">				//计算法线纹理值，图片中的[0,1]变换到[-1,1]，还要乘以凹凸程度</span><br><span class="line">				tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span><br><span class="line">				//因为是单位矢量，计算归一化的z值</span><br><span class="line">				tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">				</span><br><span class="line">				//也是计算切线空间法线纹理，使用内置函数UnpackNormal</span><br><span class="line">				//tangentNormal.xy = UnpackNormal(packedNormal);</span><br><span class="line">				//tangentNormal.xy *= _BumpScale;</span><br><span class="line">				//tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line">				//光照Blinn-Phong</span><br><span class="line">				fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * max(0,dot(tangentNormal, tangentLightDir));</span><br><span class="line">				fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(tangentNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">				return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>这里计算z值没有太理解，个人觉得一个是法线必须为单位矢量，此外切线空间下xy值代表了法线的扰动程度，因为z是原来的法线方向，z值越大那么扰动就越小，xy值就越大，所以只给xy乘以BumpScale才能调节凹凸程度，否则BumpScale是没有作用的。</p>
<p>注意，这里如果计算切线空间的法线分量时，导入的法线纹理没设置为法线贴图，那么才能像上面一样手动Unpack，否则必须使用内置函数，此时采样的BumpMap的rgb值就不是切线空间法线的xyz值了。</p>
<p><img src="/2023/05/20/uni-shader3/7.png" alt></p>
<h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>现在通过修改代码，我们尝试在世界空间中计算这些值，那么顶点着色器的任务就是计算切线空间到世界空间的变换矩阵，传递给片元对法线进行转换。</p>
<p>修改v2f如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct v2f&#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float4 uv : TEXCOORD0;</span><br><span class="line">				float4 TtoW0 : TEXCOORD1;</span><br><span class="line">				float4 TtoW1 : TEXCOORD2;</span><br><span class="line">				float4 TtoW2 : TEXCOORD3;</span><br><span class="line">			&#125;;</span><br></pre></td></tr></table></figure>
<p>我们要使用三个四维向量存储变换矩阵，之所以是四维是由于我们需要w来存储顶点位置，进而在片元着色器中使用内置函数得到该点的光照和观察方向。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				//xy存普通uv，zw存法线uv</span><br><span class="line">				o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">				o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">				float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				float3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				float3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">				float3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">				o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">				o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">				o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line">				return o;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>顶点着色器中，计算纹理坐标，计算世界坐标系下的法线、切线、副切线坐标，用它们按列排放组成变换矩阵。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line"></span><br><span class="line">				fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">				fixed3 ViewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">				fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">				bump.xy *= _BumpScale;</span><br><span class="line">				bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy)));</span><br><span class="line"></span><br><span class="line">				bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line">				</span><br><span class="line">				//光照</span><br><span class="line">				fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * max(0,dot(bump, lightDir));</span><br><span class="line">				fixed3 halfDir = normalize(lightDir + ViewDir);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(bump, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">				return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>最后顶点着色器中获取世界坐标系下的观察和光照方向，然后采样法线纹理值，用v2f中存储的变换矩阵将他从切线空间变换到世界空间，之后进行光照计算。观察得到的结果，几乎是没有差别的，不过这种做法更加通用，因为有时我们不得不在世界坐标系中计算一些其它值。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity和Shader入门（二）</title>
    <url>/2023/05/19/uni-shader2/</url>
    <content><![CDATA[<p>用冯乐乐大神的《Unity Shader入门精要》入门，记录个人整理的知识点和代码。本篇博客本来应该讲到数学基础，不过由于在Games101系列第一篇博客笔记中已经有一致的内容，这里就不复习了，如有看客可以移步标签查找。本篇博客会先举例说明变换的作用，就直接进入Shader的编写了。</p>
<span id="more"></span>
<h1 id="Unity中坐标空间的变换"><a href="#Unity中坐标空间的变换" class="headerlink" title="Unity中坐标空间的变换"></a>Unity中坐标空间的变换</h1><p>通过学习我们知道，图形学中有五个用来实现变换的坐标系，也了解了如何使用矩阵对它们进行变换。（不清楚请看Games101的笔记博客）</p>
<ul>
<li><em>MODEL</em>首先是物体坐标系，或者说模型坐标系，这个坐标系用来给物体进行建模，定义复杂物体的各种几何属性；</li>
<li><em>WORLD</em>世界坐标系，建模完成的物体在世界坐标系中进行变换，从而移动到不同的位置和朝向；</li>
<li><em>VIEW</em>视图坐标系，将世界坐标系中的物体再进行视图变换，使其符合摄像机的观察(“符合”同样会在后面解释)；</li>
<li><em>CLIP</em>裁剪坐标系，投影变换再次对物体进行处理，这时让整个可见空间的坐标范围缩放到标准的单位大小；</li>
<li><em>SCREEN</em>屏幕坐标系，透视投影已经让物体从三维变换到二维上了，所以可以根据屏幕大小再次缩放可见图形，在根据Z轴提供的深度关系，就完成了整个变换。</li>
</ul>
<p>我们的变换目标就是从讲将体从以自己为准的空间中变换到屏幕上，这个过程实际上就是图形学的原理，下面我们通过例子来看如何实现。现在有一个🐂，它的Transform组件显示Position为[5,0,25]，Rotation为[0,150,0]，Scale为[2,2,2]，它还有一个子对象鼻子，坐标是[0,2,4]，缩放和旋转均为0。此外，我们或许还要用到摄像机的变换信息，Position为[0,10,-10]，Rotation为[30,0,0]，Scale为[1,1,1]。Unity使用的变换顺序是缩放旋转平移，那么这个🐂的鼻子会如何变换到屏幕上？</p>
<h2 id="MODEL-gt-WORLD"><a href="#MODEL-gt-WORLD" class="headerlink" title="MODEL-&gt;WORLD"></a>MODEL-&gt;WORLD</h2><p>第一步，我们从MODEL变换到WORLD中，Unity中的子对象位置坐标是在父对象的模型坐标系下的，所以我们可以根据🐂的变换和鼻子的位置坐标将它变换到世界中，先放大2倍，然后绕y轴旋转30度，最后平移到[5,0,25]。🐂的变换矩阵应该是这样的：</p>
<p><img src="/2023/05/19/uni-shader2/1.png" alt></p>
<p>也就是说，该模型下的所有子对象都会被施加这个变换。那么鼻子的位置坐标右乘就得到鼻子在世界坐标系中的位置：</p>
<p><img src="/2023/05/19/uni-shader2/2.png" alt></p>
<h2 id="WORLD-gt-VIEW"><a href="#WORLD-gt-VIEW" class="headerlink" title="WORLD-&gt;VIEW"></a>WORLD-&gt;VIEW</h2><p>之前理解VIEW空间比较难，现在知道Unity中的摄像机对象就清楚多了，要做的就是将世界坐标系中的物体再次变换到摄像机的观察空间中，这里需要主要，Unity中相机的观察空间使用的是右手坐标系，而世界空间使用的是左手坐标系，也就是Z轴方向相反，这两种标准的坐标系是不能通过平移、旋转转换的，你可以试着将左手和右手比成坐标系并尝试，肯定会发现它们总是有一个轴是相对的。唯一的方式就是将Z轴取反，统一到右手坐标系下，然后才能使用平移和旋转变换。</p>
<p>VIEW空间使用的坐标系以摄像机为原点，摄像机的后方、上方、右方分别作为z轴、y轴、x轴的正方向，原本我们游戏对象的前方是z轴正方向。为了得知这个变化矩阵，我们先考虑摄像机目前的情况，它从世界坐标系中的原点开始，先绕x轴旋转30度，然后平移到[0,10,-10]，那么一开始物体在世界坐标系中，此时观察坐标和世界坐标重合，在物体位置不变的情况下，我们把摄像机在世界坐标下旋转+30度，那么物体相对于摄像机就旋转了-30度，平移同理，所以把摄像机的变换逆向过来就是世界坐标变换到观察坐标了。</p>
<p><img src="/2023/05/19/uni-shader2/3.png" alt></p>
<p>此时记得Z轴取反，这一步放在前面也行：</p>
<p><img src="/2023/05/19/uni-shader2/4.png" alt></p>
<p>最后还是右乘本来鼻子的世界坐标，就得到鼻子在观察空间中的位置了。</p>
<p><img src="/2023/05/19/uni-shader2/5.png" alt></p>
<h2 id="VIEW-gt-CLIP"><a href="#VIEW-gt-CLIP" class="headerlink" title="VIEW-&gt;CLIP"></a>VIEW-&gt;CLIP</h2><p>这里是透视投影和正交投影，推导还是在前面说的博客中。但是这里稍有不同，因为我们又一次改变了旋向性，回到了左手坐标系。此时靠近摄像机的点具有更小的z值。</p>
<p><img src="/2023/05/19/uni-shader2/6.png" alt></p>
<p>对应Unity摄像机的参数如下：</p>
<p><img src="/2023/05/19/uni-shader2/7.png" alt></p>
<p>书中给出的是正交投影下的结果。正交是缩放加平移，最终矩阵如下：</p>
<p><img src="/2023/05/19/uni-shader2/8.png" alt></p>
<p>对应Unity摄像机的参数如下：</p>
<p><img src="/2023/05/19/uni-shader2/9.png" alt></p>
<p>我们代入上面设置中的值计算，得到鼻子在裁剪空间中的坐标：</p>
<p><img src="/2023/05/19/uni-shader2/10.png" alt></p>
<p>不过为了匹配不同的设备，对透视投影来说还要进行齐次除法，也就是除以最后一个分量，此时坐标变换到称为NDC的空间，坐标值在[-1,1]中，而正交投影由于已经缩放了所以不起作用。</p>
<h2 id="CLIP-gt-SCREEN"><a href="#CLIP-gt-SCREEN" class="headerlink" title="CLIP-&gt;SCREEN"></a>CLIP-&gt;SCREEN</h2><p>投影后我们得到的是标准的[-1,1]，此时需要进一步映射到屏幕像素上，这里就比较简单了，对xy使用下面的公式：</p>
<p><img src="/2023/05/19/uni-shader2/11.png" alt></p>
<p>此时屏幕左下角是(0,0)，右上角和分辨率有关，其中$clip_w$实际上就是齐次除法。对于z分量我们需要进行深度测试之类的工作，所以还是要保留。最终得到鼻子在400*300屏幕上的像素位置：</p>
<p><img src="/2023/05/19/uni-shader2/12.png" alt></p>
<p>最后，我们以后还会用到法线变换，这里暂且不说。当然使用Unity Shader后我们不必自己编写这么复杂的过程了，Unity提供了一系列的变换函数，调用它们即可。阅读书中补充内容深感这部分内容复杂，还是要抽空看虎书，由于后面很多内容都是变换，这些空间及其坐标发生了什么变化非常有必要清楚地认识，例如在某个阶段顶点或片元的齐次坐标取值范围如何。在没有大的影响下，我们还是先认识如何写Shader。</p>
<h1 id="开始使用Unity-Shader"><a href="#开始使用Unity-Shader" class="headerlink" title="开始使用Unity Shader"></a>开始使用Unity Shader</h1><h2 id="顶点和片元着色器的创建"><a href="#顶点和片元着色器的创建" class="headerlink" title="顶点和片元着色器的创建"></a>顶点和片元着色器的创建</h2><p>Unity中使用ShaderLab作为跨平台Shader开发的语言体系，提供了许多封装好的工具函数处理底层逻辑。通过使用Unity Shader编写ShaderLab，可以方便地修改可编程管线。</p>
<p>要编写Shader Lab，首先需要建立材质，然后让材质使用当前的Unity Shader。材质是体现物体对光照反射的数据集，读取材质信息后Shader才能实现光照信息的交互。因此要使用Shader必须有一个材质，而材质又体现在实际的游戏对象上。因此我们先在Unity中创建场景，将Window/Lighting/Skybox设置为None，然后进行以下步骤：</p>
<p><img src="/2023/05/19/uni-shader2/13.png" style="zoom:75%;"></p>
<ul>
<li>在Assets或者Project窗口/Create/Material，命名为SimpleShaderMat；在场景中创建一个Sphere，将这个SimpleShaderMat文件拖拽到场景中目标物体或者在物体的Mseh Renderer组件中赋值；默认情况下，新建材质会使用Standard Shader，一种基于物理模拟的渲染。</li>
</ul>
<p><img src="/2023/05/19/uni-shader2/14.png" alt></p>
<ul>
<li><p>Assets或者Project窗口/Create/Shader；Unity提供四种Unity Shader模板，Standard Surface Shader包含标准光照模型，Unlit Shader产生一个不含光照但包含烟雾的基本着色器，Image Effect Shader提供实现各种屏幕后处理效果的基本模板，Compute Shader提供典型的表面着色器的实现方法，这里我们不适用模板，创建后命名为SimpleShader，删除文件中所有内容。在材质的属性菜单中选择使用的Shader；</p>
</li>
<li><p>然后我们重新打开Simple Shader，输入下面的代码：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.	shader &quot;Custom/Simple Shader&quot;</span><br><span class="line">2.	&#123;</span><br><span class="line">3.	 SubShader</span><br><span class="line">4.	 &#123;</span><br><span class="line">5.	       Pass</span><br><span class="line">6.	        &#123;</span><br><span class="line">7.	            CGPROGRAM</span><br><span class="line">8.	            #pragma vertex vert</span><br><span class="line">9.	            #pragma fragment frag</span><br><span class="line">10.	</span><br><span class="line">11.	            float4 vert (float4 v : POSITION) : SV_POSITION</span><br><span class="line">12.	            &#123;</span><br><span class="line">13.	                return mul(UNITY_MATRIX_MVP,v);</span><br><span class="line">14.	            &#125;</span><br><span class="line">15.	</span><br><span class="line">16.	            fixed4 frag ( ) : SV_Target</span><br><span class="line">17.	            &#123;</span><br><span class="line">18.	                return fixed4(1.0,1.0,1.0,1.0);</span><br><span class="line">19.	            &#125;</span><br><span class="line">20.	            ENDCG</span><br><span class="line">21.	        &#125;</span><br><span class="line">22.	 &#125;</span><br><span class="line">23.	 FallBack &quot;Diffuse&quot;</span><br><span class="line">24.	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>保存后回到Unity，看到场景中的球体变成了白色，材质球也是白色的。其中，第一行定义了Shader的名称，””定义在Shader栏中出现的位置。接下来是SubShader，其中定义一个Pass语义块，使用CGPROGRAM和ENDCG包裹了CG代码。然后#开头的两个字符指定了顶点着色器和片元着色器对应的函数。这里语法类似C语言，不过vert函数的参数我们使用了语义POSITION和SV_POSITION，前者表示将顶点的坐标填充到输入参数v中，后者表示该函数输出是一个系统值，顶点着色器处理后应该是裁剪空间中的顶点坐标。该函数只有一行代码，就是使用MVP变换矩阵，将顶点从模型空间转换到裁剪空间。</p>
<p>frag函数没有输入，SV_Target表示这个函数的输出是系统值，要将这个值存储到一个渲染目标中，这里对应默认帧缓存，可以说是像素的值。该函数返回一个fixed4类型的变量，代表颜色值。</p>
<p>最后是FallBack语句，告诉Unity如果没有可用的SubShader就采用漫反射这个简单的着色器。</p>
<p><img src="/2023/05/19/uni-shader2/15.png" alt></p>
<h2 id="使用Properties和语义"><a href="#使用Properties和语义" class="headerlink" title="使用Properties和语义"></a>使用Properties和语义</h2><p>之前我们知道材质面板中会显示能够修改的属性，它们和Unity脚本中的序列化很类似，设置属性后就可以才材质面板中实时调节，观察效果。我们修改代码为下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.	shader &quot;Custom/Simple Shader&quot;</span><br><span class="line">2.	&#123;</span><br><span class="line">3.	 Properties&#123;</span><br><span class="line">4.	  _Color(&quot;Color Tint&quot;, Color) = (1.0,1.0,1.0,1.0)</span><br><span class="line">5.	 &#125;</span><br><span class="line">6.	</span><br><span class="line">7.	 SubShader</span><br><span class="line">8.	 &#123;</span><br><span class="line">9.	          Pass</span><br><span class="line">10.	        &#123;</span><br><span class="line">11.	            CGPROGRAM</span><br><span class="line">12.	            #pragma vertex vert</span><br><span class="line">13.	            #pragma fragment frag</span><br><span class="line">14.	            fixed4 _Color;</span><br><span class="line">15.	</span><br><span class="line">16.	            struct a2v</span><br><span class="line">17.	            &#123;</span><br><span class="line">18.	                float4 vertex : POSITION;</span><br><span class="line">19.	                float2 uv : TEXCOORD0;</span><br><span class="line">20.	                float3 normal : NORMAL;</span><br><span class="line">21.	            &#125;;</span><br><span class="line">22.	</span><br><span class="line">23.	            struct v2f</span><br><span class="line">24.	            &#123;</span><br><span class="line">25.	                float2 uv : TEXCOORD0;</span><br><span class="line">26.	                float4 vertex : SV_POSITION;</span><br><span class="line">27.	                float3 color : COLOR;</span><br><span class="line">28.	            &#125;;</span><br><span class="line">29.	</span><br><span class="line">30.	</span><br><span class="line">31.	            v2f vert (a2v v)</span><br><span class="line">32.	            &#123;</span><br><span class="line">33.	                v2f o;</span><br><span class="line">34.	                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">35.	                o.uv = v.uv;</span><br><span class="line">36.	                o.color = v.normal * 0.5 + fixed3(0.5,0.5,0.5);</span><br><span class="line">37.	                return o;</span><br><span class="line">38.	            &#125;</span><br><span class="line">39.	</span><br><span class="line">40.	            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">41.	            &#123;</span><br><span class="line">42.	                fixed4 curCol = fixed4(i.color, 1.0);</span><br><span class="line">43.	                return curCol * _Color;</span><br><span class="line">44.	            &#125;</span><br><span class="line">45.	            ENDCG</span><br><span class="line">46.	        &#125;</span><br><span class="line">47.	 &#125;</span><br><span class="line">48.	</span><br><span class="line">49.	 FallBack &quot;Diffuse&quot;</span><br><span class="line">50.	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们使用Properties语义块定义了一个属性_Clolor，它的性质是一个颜色拾取器，然后我们进一步在Pass中用同样的名字命名，就可以在CG代码块中访问了。此外可以看到，我们使用了两个结构体来存储顶点和片元的一些属性，方式是使用语义，Unity会根据这些语义来填充结构体的成员，vert函数作为顶点着色器，负责将顶点数据传递给片元，我们通过流水线知道这其中发生了插值，一个片元对应三个顶点，它们的重心插值就是片元的值，所以不论其中如何，顶点着色器中仍然给v2f赋值了，在片元着色器中我们返回这个顶点着色器中计算的颜色值，就得到了下面的图像，你可以思考下其中的流程。</p>
<p><img src="/2023/05/19/uni-shader2/16.png" alt></p>
<p>那什么是语义？它实际上就是赋值给Shader输入和输出的字符串，表达这个参数对应什么。有一些语义使用SV开头，代表System Value，这些值不可随意赋值，具有特殊含义，因为流水线会使用它们进行计算，DX10中更新了这些SV语义，也导致一些平台上的差异，例如前面POSITION在PS4上就必须指明是SV_POSITION才行。下面是一些常用语义的含义：</p>
<p><img src="/2023/05/19/uni-shader2/17.png" alt></p>
<p><img src="/2023/05/19/uni-shader2/18.png" alt></p>
<p><img src="/2023/05/19/uni-shader2/19.png" alt></p>
<p>读懂上面的代码后，我们可以正式进入光照部分了。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity和Shader入门（四）</title>
    <url>/2023/05/23/uni-shader4/</url>
    <content><![CDATA[<p>前面我们学习了基础纹理和法线纹理，现在我们认识到纹理就是顶点的某种数据，我们下面将学习渐变纹理和遮罩纹理。之后我们再补充一些透明的基本做法，那么入门精要的基础篇就完成了。</p>
<span id="more"></span>
<h1 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h1><p>渐变纹理是用来控制物体漫反射的，我们本来计算漫反射是采用兰伯特公式计算：</p>
<p><img src="/2023/05/23/uni-shader4/3.jpg" alt="场景"></p>
<p>不过曾经有人提出一种基于冷到暖色调变化进行着色的技术，使物体的轮廓线比直接使用漫反射更加明显，而且具有多种色调的变化，卡通渲染中大多使用这种技术。原理就是修改上面公式中的最后一项$n \cdot l$，我们将用这个值扩展得到的二维向量$(n \cdot l, n \cdot l)$来作为uv坐标，使用特定的渐变纹理进行采样，得到需要的颜色并返回到上面公式中作为最后一项。</p>
<p>因此实现渐变纹理只需要轻微改变漫反射即可。我们使用半兰伯特光照模型的漫反射，看看它的效果如何。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Learn/Ramp Texture&quot;</span><br><span class="line">&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color(&quot;Color Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_RampTex(&quot;Ramp Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Specular(&quot;Specular&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_Gloss(&quot;Gloss&quot;, Range(8.0,256)) = 20</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line">			#pragma vertex vert</span><br><span class="line">			#pragma fragment frag</span><br><span class="line">			#include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			sampler2D _RampTex;</span><br><span class="line">			float4 _RampTex_ST;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			float _Gloss;</span><br><span class="line"></span><br><span class="line">			struct a2v&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f&#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">				float2 uv : TEXCOORD2;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v)&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);</span><br><span class="line"></span><br><span class="line">				return o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">				fixed3 worldPos = normalize(i.worldPos);</span><br><span class="line">				fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line"></span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">				fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5;</span><br><span class="line">				//需要修改的地方</span><br><span class="line">				fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br><span class="line"></span><br><span class="line">				fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">				fixed3 halfDir = normalize(worldNormal + viewDir);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">				return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了漫反射外，其它地方完全不用修改，得到下面的结果：</p>
<p><img src="/2023/05/23/uni-shader4/1.png" alt></p>
<p>我们看到了明显的颜色变化，而非之前平滑的颜色过渡了，这就是渐变纹理，书中还提供了其它纹理，可以查看它们的不同效果。</p>
<h1 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h1><p>在前面的学习中，我们可能会苦恼于镜面光的位置无法控制，因为物体表面不同部分对光的反射各不相同，使用统一的计算显然无法得到不同的结果。但是使用遮罩纹理就可以实现这一点，遮罩纹理可以保护某些区域，在采样的时候将得到一个矢量，它的RGBA通道可能存储了不同的数据，那么在计算中我们让光照乘以其中某个值，让这个通道原本的光照值被改变，就能完成对模型不同表面的遮罩。</p>
<p>具体实现上，让顶点根据默认的uv坐标，对遮罩纹理进行采样，然后直接和镜面光相乘，就可以了，因为我们这里使用的遮罩纹理很简单，它的每个通道都是相同的值，全部表示镜面光强度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Learn/MaskTexture&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line">        _MainTex(&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BumpScale(&quot;Bump Scale&quot;, Float) = 1.0</span><br><span class="line">        _SpecularMask(&quot;Specular Mask&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _SpecularScale(&quot;Specular Scale&quot;, Float) = 1.0</span><br><span class="line">        _Specular(&quot;Specular&quot;, Color) = (1,1,1,1)</span><br><span class="line">        _Gloss(&quot;Gloss&quot;, Range(8.0,256)) = 20</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float _BumpScale;</span><br><span class="line">            sampler2D _SpecularMask;</span><br><span class="line">            float _SpecularScale;</span><br><span class="line">            float4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 lightDir : TEXCOORD1;</span><br><span class="line">                float3 viewDir : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">                fixed3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = normalize(i.viewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">				//修改镜面光计算</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码中我们使用主纹理的缩放、平移对所有纹理进行了操作，这意味着调整主纹理的属性能影响到其它纹理。下面是这个着色器的结果。</p>
<p><img src="/2023/05/23/uni-shader4/2.png" alt></p>
<p>上面提供的讲解都很简单，以后我们可能会进一步使用它们。</p>
<h1 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h1><p>纹理基础结束后，我们进入透明效果的学习，之前的学习中我们只使用了颜色通道的RGB值，Alpha并没有使用，他就是表示透明度的，当这个值为1，像素完全显示；这个值为0，像素不会显示。</p>
<p>我们将学习两种实现透明的方式，透明度测试（无法实现真正的半透明）和透明度混合。</p>
<h2 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h2><p>只要一个片元的透明度不满足条件，那么将直接舍弃这个片元，它不会对颜色缓冲有任何影响。在Unity Shader中我们可以使用clip函数完成这个测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line">// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Learn/Alpha Test&quot;</span><br><span class="line">&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color(&quot;Main Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_MainTex(&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Cutoff(&quot;Alpha Cutoff&quot;, Range(0,1)) = 0.5</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Tags&#123;&quot;Queue&quot; = &quot;AlphaTest&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;TransparentCutout&quot;&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		#pragma vertex vert</span><br><span class="line">		#pragma fragment frag</span><br><span class="line"></span><br><span class="line">		#include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">		fixed4 _Color;</span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		float4 _MainTex_ST;</span><br><span class="line">		fixed _Cutoff;</span><br><span class="line"></span><br><span class="line">		struct a2v&#123;</span><br><span class="line">			float4 vertex : POSITION;</span><br><span class="line">			float3 normal : NORMAL;</span><br><span class="line">			float4 texcoord : TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		struct v2f&#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			float3 worldNormal : TEXCOORD0;</span><br><span class="line">			float3 worldPos : TEXCOORD1;</span><br><span class="line">			float2 uv : TEXCOORD2;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		v2f vert(a2v v)</span><br><span class="line">		&#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">			o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">			o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">			return o;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">			fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">			fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">			fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">			clip(texColor.a - _Cutoff);</span><br><span class="line"></span><br><span class="line">			fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">			fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">			fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">			return fixed4(ambient + diffuse, 1.0);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在SubShader开头使用了三个标签，第一个表示将该模型的渲染归于AlphaTest渲染队列。在渲染过程中，由于透明物体的存在，我们必须先渲染不透明物体，然后再渲染半透明物体，最终得到正确的渲染效果。不过即使这样做也会有问题，因为不同物体之间可能会有遮挡，这时我们不能直接让两个半透明物体渲染，因为它们的深度关系随着形状而改变，必须进一步分割模型网络才能得到正确结果。</p>
<p>Unity中定义了五个渲染队列，它们的含义如下：</p>
<ul>
<li>Bakcground：在其它队列之前绘制，适合背景上的物体；</li>
<li>Geometry：默认的队列，不透明物体使用该队列；</li>
<li>AlphaTest：使用透明度测试的物体；</li>
<li>Transparent：在Geometry和AlphaTest之后，并且从后往前绘制使用了透明度混合的物体；</li>
<li>Overlay：在最后渲染。</li>
</ul>
<p>所以这里我们使用第一个队列。第二个标签是IgnoreProjector，开启后Shader不会受到投影器干扰；最后一个是RenderType，设置为TransparentCutout表示让Unity将这个Shader归入提前定义的组中，指明这个Shader使用了透明度测试。只需要知道，使用透明度测试的Shader一般都要使用这三个标签。</p>
<p>后面的代码就是之前很熟悉的了，不再讲解。这里注意Clip函数的使用即可。</p>
<p>完成后将这一章对应的纹理贴上去(素材都在<a href="https://github.com/candycat1992/Unity_Shaders_Book">github</a>上)，这张纹理的alpha通道存储了不同的透明度。调整透明度的阈值，看到立方体的某些面消失了。</p>
<p><img src="/2023/05/23/uni-shader4/3.png" alt></p>
<p>这个效果当然不是真正的透明，我们下面来看看透明度混合的做法。</p>
<h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>开启透明度混合后，透明度将作为混合因子来对颜色进行处理。要注意的是，使用透明度混合必须关闭深度写入，但是却需要使用深度测试，这是因为深度写入将直接剔除那些在透明物体之后的点，同时我们又必须通过深度测试判断物体的前后顺序，所以这里深度测试对于我们来说是只读的，它不会影响深度缓存的内容。</p>
<p>使用Unity的混合命令就可以开启混合，它指定了混合时使用的混合函数。</p>
<p><img src="/2023/05/23/uni-shader4/4.png" alt></p>
<p>这里我们使用第二种函数，它处理RGBA的每一个通道，数学公式如下：</p>
<script type="math/tex; mode=display">DstColor_{new}=SrcFactor*SrcColor+DstFctor*DstColor_{old}</script><p>除了相乘后加法以外，我们还可以使用其它不同的公式，使用BlendOp BlendOperation命令可以指定混合公式：</p>
<p><img src="/2023/05/23/uni-shader4/8.png" alt></p>
<p><img src="/2023/05/23/uni-shader4/9.png" alt></p>
<p>其中还可以进一步设置SrcFactor为源的Alpha值，DstFactor为1减去源的Alpha值。源指的是当前处理的颜色，也就是没有写入颜色缓存的值；目标指的是已经存在颜色缓存中的值，混合就是将当前处理的颜色和存在颜色缓冲的颜色进行混合，得到的新颜色再次覆盖原来颜色缓存中的值。将它转化成数学公式：</p>
<script type="math/tex; mode=display">DstColor_{new}=SrcAlpha*SrcColor+(1-SrcAlpha)*DstColor_{old}</script><p>当然也有其它的指定方式，语法为[Blend SrcFactor DstFactor, SrcFactorA DstFactorA]。其中Factor可以替换为以下的值：</p>
<p><img src="/2023/05/23/uni-shader4/10.png" alt></p>
<p>下面我们来实现这个Shader，使用和上面一样的Shader，然后修改几个地方。</p>
<p>首先将Properties修改如下，记得一并修改Pass中声明的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">		_Color(&quot;Main Tint&quot;, Color) = (1,1,1,1)</span><br><span class="line">		_MainTex(&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_AlphaScale(&quot;Alpha Scale&quot;, Range(0,1)) = 1</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		fixed4 _Color;</span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		float4 _MainTex_ST;</span><br><span class="line">		fixed _AlphaScale;</span><br></pre></td></tr></table></figure>
<p>新增的变量AlphaScale用于控制整体的透明度。然后修改标签如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tags&#123;&quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;Transparent&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>RenderType指明了Shader是一个透明度混合的Shader。我们还需要在Pass中关闭深度写入，设置混合因子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">			Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		ZWrite Off</span><br><span class="line">		Blend SrcAlpha OneMinusSrcAlpha</span><br></pre></td></tr></table></figure>
<p>接下来修改片元着色器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">			fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">			fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">			fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">			fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">			fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">			fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">			return fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>其实仅修改了返回值的Alpha，就得到下面的效果了：</p>
<p><img src="/2023/05/23/uni-shader4/5.png" alt></p>
<p>到这里我们不得不面对前面提到的一个问题：模型本身具有复杂遮挡关系时，如何保证每个部分的排序正确？由于我们关闭了深度写入，所以无法对模型进行像素级别的深度排序，不可避免地会出现一些排序错误的情况。这里我们可以使用开启深度写入的半透明效果解决这个问题。</p>
<h2 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h2><p>我们使用两个Pass来渲染一个模型，第一个Pass开启深度写入但是不写入颜色，这时我们的深度缓冲中已经存在了正确的深度信息；第二个Pass进行正常的透明混合，此时就可以使用和前面相同的操作了。只不过这种方法增加了性能开销。</p>
<p>我们只需要在前一个小节的Shader中加入以下的Pass：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">			ZWrite On</span><br><span class="line">			ColorMask 0</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>这个Pass开启了深度写入，然后使用ColorMask语义设置颜色通道的写掩码，可以是RGB/A/0/RGBA的任意组合，0表示Pass不写入任何颜色通道，不会修改颜色缓冲。</p>
<p>我们得到了这样的效果：</p>
<p><img src="/2023/05/23/uni-shader4/6.png" alt></p>
<p>如果使用前一节的Shader，得到的就是错误的渲染：</p>
<p><img src="/2023/05/23/uni-shader4/7.png" alt></p>
<h2 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h2><p>之前的渲染中，我们没有开启双面渲染，这导致半透明物体的内部结构完全是看不到的，看起来就像只有半个一样。因此我们可以使用Cull指令来控制需要剔除哪个面，它的语法是：</p>
<p>Cull Back | Front | Off</p>
<p>设置为Back时背对摄像机的图元不会被渲染，也是默认情况；Front时朝向摄像机的图元不会被渲染；Off时关闭剔除功能。</p>
<h3 id="透明度测试的双面渲染效果"><a href="#透明度测试的双面渲染效果" class="headerlink" title="透明度测试的双面渲染效果"></a>透明度测试的双面渲染效果</h3><p>只需要在前面透明度测试的代码中添加下面的Cull命令就能看到效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">	Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">Cull Off</span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/23/uni-shader4/11.png" alt></p>
<h3 id="透明度混合的双面渲染效果"><a href="#透明度混合的双面渲染效果" class="headerlink" title="透明度混合的双面渲染效果"></a>透明度混合的双面渲染效果</h3><p>我们使用两个Pass，第一个Pass负责渲染背面，第二个Pass负责渲染正面，Unity将按顺序执行Pass，所以背面将先被渲染，这保证了渲染顺序的正确。所以将之前Shader中的Pass复制一份，第一个Pass开启剔除正面，第二个Pass开启剔除背面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">			Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		Cull Front</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pass&#123;</span><br><span class="line">			Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		Cull Back</span><br></pre></td></tr></table></figure>
<p>得到下面的结果：</p>
<p><img src="/2023/05/23/uni-shader4/12.png" alt></p>
<h2 id="透明总结"><a href="#透明总结" class="headerlink" title="透明总结"></a>透明总结</h2><p>到这里入门系列就结束了，透明部分主要是使用了各项ShaderLab的设置，没有太多的代码，重点是实现透明效果的两种方法，以及混合的原理，通过开启面的剔除可以得到双面渲染的结果。这里还尝试了使用多个Pass处理问题，是比较消耗性能的做法。</p>
<p>后面部分是中级篇，讲了进阶光照，高级纹理和动态Shder的实现。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity和Shader进阶（五）</title>
    <url>/2023/06/03/uni-shader5/</url>
    <content><![CDATA[<p>这里我们进一步学习入门精要的高级纹理，之所以跳过高级光照是因为该部分说明的内容不会影响我们直接学习高级纹理，由于学习了PBR，不如直接将立方体贴图讲清楚，之后再慢慢研究光照。除此外，高级纹理还包括渲染纹理和程序纹理。</p>
<span id="more"></span>
<h1 id="立方体纹理"><a href="#立方体纹理" class="headerlink" title="立方体纹理"></a>立方体纹理</h1><p>我们之前已经接触过立方体贴图了，它包含六张图像，分别对应正方体的六个面。而读取立方体纹理需要的是三维矢量，不再是uv了，这个三维矢量从正方体的中心作为原点出发，然后按照矢量方向和立方体相交，该点得到的信息就是采样的颜色了。</p>
<p>立方体贴图是环境映射的一种实现方式，之前PBR的博客里有提到，PBR的全流程中光照只是基础部分，真正要实现PBR的光照需要配合各种贴图完成，尤其是用环境贴图达成近似的全局光照GI，这才是PBR的核心。PBR使用的环境贴图Ambient Occlusion，就是一张立方体贴图；我们Unity中的天空盒使用的也是立方体贴图。</p>
<p>使用立方体纹理的好处是简单易用，但是不灵活，因为它不是实时的，每当环境光照发生改变，都要重新对立方体纹理进行渲染，并且本身也不是完全的全局光照，本质上仅仅对周围环境进行了一次采样，还是属于局部光照的范畴。</p>
<h2 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h2><p>Unity中提供了一个用于解析立方体天空和的Shader，位于Skybox/6 Sided，新建纹理并应用该着色器后，会看到材质面板中出现六个纹理位置，我们可以将需要的纹理放置到对应的位置。</p>
<p><img src="/2023/06/03/uni-shader5/1.png" alt></p>
<p>其中使用的纹理位于入门精要提供的github地址，图片名称标记了该图片对应的位置。之后我们打开Window/Rendering/Lighting，选择天空盒为这个新的材质。</p>
<p><img src="/2023/06/03/uni-shader5/2.png" alt></p>
<p>这样我们得到下面的效果：</p>
<p><img src="/2023/06/03/uni-shader5/3.png" alt></p>
<h2 id="创建环境映射的立方体纹理"><a href="#创建环境映射的立方体纹理" class="headerlink" title="创建环境映射的立方体纹理"></a>创建环境映射的立方体纹理</h2><p>Unity中，如果已经有了立方体纹理，那么我们将它的Texture Type设置为Cubemap即可。但是很多时候我们都是自己搭建的场景，我们希望场景中的物体都有自己的环境立方体纹理，这样手动创建就会很麻烦，所以我们可以通过脚本创建，使用Unity提供的Camera.RenderToCubemap函数可以完成这个任务。</p>
<p><img src="/2023/06/03/uni-shader5/4.png" alt></p>
<p>接下来我们要稍微接触一点Unity Editor的内容，unity editor是一个通用的编辑器，提供了unity内部对象的创建，预览，编辑的功能及可视化界面。通过使用unity提供的编辑函数，我们可以修改或者添加界面内容，定制编辑器。用于修改编辑器的脚本文件应存放在Editor文件夹中。在这里我们为了创建环境映射，需要编写一个脚本，它的功能是渲染指定位置的立方体纹理，并存储到指定的Cubemap中。</p>
<p>首先，我们来编写这样一个脚本，入门精要提供了代码，使用了Editor将脚本直接添加到菜单中(毕竟不太可能对每个物体都手动添加一遍这个脚本组件，然后开始一次游戏，再删除脚本组件)，这样我们右键需要的物体，就能实现这个功能了。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承ScriptableWizard以创建编辑器向导</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RenderCubemapWizard</span> : <span class="title">ScriptableWizard</span> &#123;</span><br><span class="line">	<span class="comment">//待指定的物体位置</span></span><br><span class="line">	<span class="keyword">public</span> Transform renderFromPosition;</span><br><span class="line">    <span class="comment">//待指定的立方体纹理</span></span><br><span class="line">	<span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在向导打开或者用户在向导中更改内容时，将调用此函数。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span> ()</span> &#123;</span><br><span class="line">		helpString = <span class="string">&quot;Select transform to render from and cubemap to render into&quot;</span>;</span><br><span class="line">		isValid = (renderFromPosition != <span class="literal">null</span>) &amp;&amp; (cubemap != <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用RenderToCubemap以生成立方体纹理</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span> ()</span> &#123;</span><br><span class="line">		<span class="comment">// create temporary camera for rendering</span></span><br><span class="line">		GameObject go = <span class="keyword">new</span> GameObject( <span class="string">&quot;CubemapCamera&quot;</span>);</span><br><span class="line">		go.AddComponent&lt;Camera&gt;();</span><br><span class="line">		<span class="comment">// place it on the object</span></span><br><span class="line">		go.transform.position = renderFromPosition.position;</span><br><span class="line">		<span class="comment">// render into cubemap		</span></span><br><span class="line">		go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// destroy temporary camera</span></span><br><span class="line">		DestroyImmediate( go );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//序列化设置</span></span><br><span class="line">	[<span class="meta">MenuItem(<span class="string">&quot;GameObject/Render into Cubemap&quot;</span>)</span>]</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCubemap</span> ()</span> &#123;</span><br><span class="line">		ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(</span><br><span class="line">			<span class="string">&quot;Render cubemap&quot;</span>, <span class="string">&quot;Render!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存该脚本后，场景中创建一个Empty GameObject，然后使用Create/Legacy/Cubemap创建一个立方体纹理，注意要将创建的Cubemap的Readable选项勾选，因为我们马上要修改这个文件。Cubemap的face size控制着Cubemap的大小和精度，size越大渲染的分辨率越大。</p>
<p>然后右键Game Object，选择Render into Cubemap，打开编辑器向导：</p>
<p><img src="/2023/06/03/uni-shader5/5.png" alt></p>
<p>其中我们可以指定待渲染的位置和待修改的立方体贴图，将之前创建的两个对象拖进去，点击Render即可得到渲染好的Cubemap。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射和折射是最常见的环境映射，我们先看看反射的效果，它能制作一个类似金属的反射效果。仍然使用之前创建的天空盒，新建Shader和默认材质，向场景中添加一个Teapot模型，在入门精要的Github上可以找到。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Learn/Reflection&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_ReflectColor (<span class="string">&quot;Reflection Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_ReflectAmount (<span class="string">&quot;Reflect Amount&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">		_Cubemap (<span class="string">&quot;Reflection Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">			Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			fixed4 _ReflectColor;</span><br><span class="line">			<span class="keyword">fixed</span> _ReflectAmount;</span><br><span class="line">			samplerCUBE _Cubemap;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">struct</span> a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">struct</span> v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldPos : TEXCOORD0;</span><br><span class="line">				fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">				fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">				fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">				SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				</span><br><span class="line">				o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">				</span><br><span class="line">				o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);</span><br><span class="line"></span><br><span class="line">				TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span>&#123;</span><br><span class="line">				fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">				fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line"></span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">				fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;</span><br><span class="line"></span><br><span class="line">				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">				fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Reflective/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，使用Cube类型的属性Cubemap存储立方体纹理，然后在Pass中用samplerCUBE映射到实际值。UNITY_LIGHT_ATTENUATION是计算光照衰减的，我们通过计算世界空间下观察方向和法线方向，根据光路可逆原则，要找到光线经过反射后达到摄像机的颜色，可以通过计算观察方向到物体的反射方向得到，因此调用内置函数得到光线的入射方向，然后用这个方向对之前渲染的立方体贴图进行采样，得到该点立方体贴图的值，最后再根据ReflectAmount对漫反射颜色和采样得到的反射颜色插值。</p>
<p>当反射比例为1时，我们得到下面的效果：</p>
<p><img src="/2023/06/03/uni-shader5/6.png" alt></p>
<p>Teapot完全反射了场景的颜色，或者说是天空盒的颜色。这里我们是在顶点着色器中计算的反射方向，如果要精细可以在片元着色器中计算，会得到更好的结果。</p>
<h2 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h2><p>折射是另一种环境映射的方法，光线照射到物体表面以后，一部分发生折射进入物体，经过物体内部反射又射出物体，因此最少用两次反射可以物理意义上地模拟折射。不过我们这里使用一次即可，因为它看起来也不那么差。</p>
<p>方法和前面一致，不同的是我们使用refraction内置函数计算折射的方向，它接受三个参数，第一个是光线入射方向，第二个是法线方向，最后还有一个参数是入射光线所在介质和折射光线所在介质的比值，和高中物理的计算一样，它返回折射方向，模等于入射光线，它不关心强度。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader <span class="string">&quot;Learn/Refraction&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_RefractColor (<span class="string">&quot;Refraction Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_RefractAmount (<span class="string">&quot;Refraction Amount&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">		_RefractRatio (<span class="string">&quot;Refraction Ratio&quot;</span>, Range(<span class="number">0.1</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">		_Cubemap (<span class="string">&quot;Refraction Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase	</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			fixed4 _RefractColor;</span><br><span class="line">			<span class="built_in">float</span> _RefractAmount;</span><br><span class="line">			<span class="keyword">fixed</span> _RefractRatio;</span><br><span class="line">			samplerCUBE _Cubemap;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">struct</span> a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">struct</span> v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldPos : TEXCOORD0;</span><br><span class="line">				fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">				fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">				fixed3 worldRefr : TEXCOORD3;</span><br><span class="line">				SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			<span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span> &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				</span><br><span class="line">				o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Compute the refract dir in world space</span></span><br><span class="line">				o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);</span><br><span class="line">				</span><br><span class="line">				TRANSFER_SHADOW(o);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span> &#123;</span><br><span class="line">				fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">				fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line">								</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">				</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Use the refract dir in world space to access the cubemap</span></span><br><span class="line">				fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line">				</span><br><span class="line">				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Mix the diffuse color with the refract color</span></span><br><span class="line">				fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack <span class="string">&quot;Reflective/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时使用的第一个参数是观察方向的反方向，如果将折射率拉到1，那么这样的结果应该会导致我们计算的折射光采样的就是观察方向指向的天空盒子，但是毕竟我们本来也仅仅做了一次折射，都是不符合物理规律的。</p>
<p><img src="/2023/06/03/uni-shader5/7.png" alt></p>
<p>调整折射率为1后得到一个半透明的Teapot：</p>
<p><img src="/2023/06/03/uni-shader5/8.png" alt></p>
<p>这样的表现验证了我们的想法，书中这里没有详细说明，只介绍了内置折射函数的使用。</p>
<h2 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h2><p>前面我们PBR的博客中粗略说过菲涅尔反射，这里我们仍然采用相同的近似公式进行计算：</p>
<p><img src="/2023/06/03/uni-shader5/6.png" alt></p>
<p>然后重新新建材质和Shader，修改代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Shader <span class="string">&quot;Learn/Fresnel&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_FresnelScale(<span class="string">&quot;Fresnel Scale&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">		_Cubemap (<span class="string">&quot;Reflection Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">			Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="keyword">fixed</span> _FresnelScale;</span><br><span class="line">			samplerCUBE _Cubemap;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">struct</span> a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">struct</span> v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldPos : TEXCOORD0;</span><br><span class="line">				fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">				fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">				fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">				SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">				o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);</span><br><span class="line">				TRANSFER_SHADOW(o);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span>&#123;</span><br><span class="line">				fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">				fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line"></span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">fixed</span> fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * pow(<span class="number">1</span> - dot(worldViewDir, worldNormal), <span class="number">5</span>);</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line">				</span><br><span class="line">				fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Reflective/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算菲涅尔项以后，我们将它作为插值因子来计算漫反射和反射之间的比例，当调整FresnelScale为0时，我们可以重新观察茶壶边缘，此时它的边缘会反射光线，而正面几乎不会反射光线。</p>
<p><img src="/2023/06/03/uni-shader5/9.png" alt></p>
<p>后面会使用菲涅尔反射来简单模拟一个水面的效果。</p>
<h1 id="渲染纹理"><a href="#渲染纹理" class="headerlink" title="渲染纹理"></a>渲染纹理</h1><p>下面我们学习渲染纹理，在渲染过程中，我们把渲染的结果输出到颜色缓冲，再显示到屏幕上，不过现在我们可以把渲染结果存储到一个纹理中，这被称为RTT(Render Target Texture)技术。这种专门的纹理类型就是渲染纹理，在Unity中我们可以直接创建一个渲染纹理，并设置摄像机的渲染目标为该纹理；也可以利用屏幕后处理的命令来获取屏幕图像，将它放到和屏幕分辨率相同的渲染纹理中。</p>
<p>下面我们分别学习这两种方式。</p>
<h2 id="镜子效果"><a href="#镜子效果" class="headerlink" title="镜子效果"></a>镜子效果</h2><p>我们可以用渲染纹理实现一个很简陋的镜子效果，但是它非常简单。之前我们知道可以让摄像机将画面存到渲染纹理中，那么我们搭建场景如下，然后创建一个摄像机，将它的Target Texture设置为新建的Render Texture，设置渲染纹理的属性为Readable，这样该摄像机看到的画面就会被填充进这个纹理了。我们可以通过调整纹理的分辨率来控制镜子画面的清晰度。</p>
<p><img src="/2023/06/03/uni-shader5/10.png" alt></p>
<p>利用这个特点，我们从观察视角的反方向观察物体，模拟从镜子中观察的效果，上面是观察视角的图片，反过来观察我们得到一个这样的渲染纹理：</p>
<p><img src="/2023/06/03/uni-shader5/11.png" alt></p>
<p>这个图片作为镜子只差最后一步了，将它的横轴x反转！那我们当然能使用Shader来对该纹理进行采样，反转它uv坐标中的x，那么左右就颠倒了，实现了镜子一样的效果，代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Learn/Mirror&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">			</span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">struct</span> a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">struct</span> v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			<span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span> &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.uv = v.texcoord;</span><br><span class="line">				o.uv.x = <span class="number">1</span> - o.uv.x;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line"> 	FallBack Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2023/06/03/uni-shader5/12.png" alt></p>
<p>仔细看还是很容易露馅的，毕竟它只是一张图片。我们这里采用了一个四边形Quad作为镜子，它仅有一个面是可见的，因此在上面的场景里镜子背后还有我们之前创建的摄像机，用于填充渲染纹理，它并不能看到镜子。而在我们的观察视角下，镜子采样渲染纹理并反转，实现了这样一个效果，此时是能看到四边形的。</p>
<h2 id="玻璃效果"><a href="#玻璃效果" class="headerlink" title="玻璃效果"></a>玻璃效果</h2><p>前面我们使用过透明的相关设置，它主要是通过渲染队列的优先级和混合完成的。现在为了模拟玻璃的效果，我们不能再使用那样简单的方法了，使用GrabPass后，Unity会把屏幕的图像绘制在一张纹理中，供后续的Pass访问。我们可以使用它来进行更复杂的处理，使用法线模拟折射的效果。同时也要注意设置GrabPass的渲染队列，渲染透明物体仍然要使用Transparent，才能保证不透明物体率先被绘制上去。</p>
<p>首先声明属性和设置标签，创建着色器要使用的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">        _Distortion (&quot;Distortion&quot;, Range(0,1000)) = 10</span><br><span class="line">        _RefractAmount(&quot;Refract Amount&quot;, Range(0.0,1.0)) = 1.0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot; = &quot;Transparent&quot; &quot;RenderType&quot; = &quot;Opaque&quot;&#125;</span><br><span class="line"></span><br><span class="line">        GrabPass &#123;&quot;_RefractionTex&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma multi_compile_fwdbase	</span><br><span class="line">			</span><br><span class="line">			#pragma vertex vert</span><br><span class="line">			#pragma fragment frag</span><br><span class="line">			</span><br><span class="line">			#include &quot;UnityCG.cginc&quot;</span><br><span class="line">			#include &quot;Lighting.cginc&quot;</span><br><span class="line">			#include &quot;AutoLight.cginc&quot;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            float _Distortion;</span><br><span class="line">            fixed _RefractAmount;</span><br><span class="line">            sampler2D _RefractionTex;</span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;</span><br><span class="line">                float4 TtoW1 : TEXCOORD3;</span><br><span class="line">                float4 TtoW2 : TEXCOORD4;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们使用了颜色纹理、法线纹理、用来环境映射的立方体贴图，Distortion控制折射的扭曲程度，没有实际意义，RefractAmount控制反射和折射的比例。然后我们设置标签，使用Transparent作为渲染的队列，但是后面又设置RenderType为Opaque，表示不透明，这个不太好理解，主要是为了在使用着色器替换的时候能正确渲染这个物体，以后再说。</p>
<p>GrabPass {“_RefractionTex”}是我们定义的特殊Pass，这个Pass会抓取屏幕图像并存储到其中字符串定义的纹理中，它并不会被创建到我们的Project中，而是用于后续的Pass访问。在后面其它声明的时候还要额外声明这个纹理的sampler，用RefractionTex_TexelSize可以存储纹理的纹素大小，例如一个256*512的纹理的纹素大小是(1/256,1/512)，我们需要用它计算渲染纹理采样的偏移。</p>
<p>此外，为了使用法线计算折射效果，我们还要将切线空间的法线转换到世界空间中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos);</span><br><span class="line"></span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line"></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>顶点着色器中，ComputeGrabScreenPos内置函数计算了顶点在被抓取的屏幕上(渲染纹理)的采样坐标，并存储到v2f中；然后TRANSFORM_TEX计算纹理坐标的Tiling和Offset，两个纹理分别存储到xy和zw中。然后是变换矩阵的计算，后面方便对Cubemap采样，要得到从切线空间到世界空间的变换矩阵，就用切线、副切线和法线在世界空间下的矢量表示按照列排列，最后用一列存储顶点在世界空间的坐标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line"></span><br><span class="line">                float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">				i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;</span><br><span class="line"></span><br><span class="line">                fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line"></span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                fixed3 reflDir = reflect(-worldViewDir, bump);</span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 finalColor = reflCol * (1 - _RefractAmount) + refrCol * _RefractAmount;</span><br><span class="line"></span><br><span class="line">                return fixed4(finalColor, 1);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>片元着色器中，获得世界坐标系下顶点位置和观察方向，接着用UnpackNormal内置函数对采样得到的法线值进行转换，得到切线空间的法线矢量，对矢量的xy值(代表切线和副切线方向的值)乘以Distortion和RefractionTex_TexelSize.xy以计算偏移，给顶点在被抓取的屏幕采样的坐标加上这个偏移，此时这个offset反映了法线的扰动情况。</p>
<p>然后计算折射的颜色，对被抓取屏幕的采样坐标除以w分量以得到真正的屏幕坐标，然后对这个渲染纹理采样，得到折射颜色。</p>
<blockquote>
<p>虽然叫它屏幕坐标，但是它实际上没有除以w分量，意味着此时w分量不为1，原因是之前顶点要插值得到片元，ComputeGrabScreenPos函数计算后保留了齐次除法，以得到更精确的插值结果。裁剪空间[-1,1]到视口空间[0,1]的变换是先进行齐次除法完成投影，然后将xy分量除以2加上0.5。</p>
</blockquote>
<p>之后将切线空间的法线转换到世界空间，计算反射颜色，内置函数得到光线的入射方向，对颜色纹理采样得到漫反射颜色，对立方体贴图使用入射方向采样得到入射光线的颜色，乘以漫反射颜色得到最终的反射颜色，之后根据RefractAmount作为混合因子，计算实际颜色并返回，这样就完成了。</p>
<p>然后我们来创建场景，使用书中对应github给出的墙壁纹理，制作一个封闭的房间，然后在房间中心添加一个点光源，此时我们利用点光源的位置来渲染立方贴图，使用上面提到的脚本即可。这个新的立方体纹理将用于着色器的环境映射。</p>
<p>然后创建一个球体，用更大的正方体包裹住球体，对正方体应用上面着色器的材质和书中提供的纹理，得到这样的效果。</p>
<p><img src="/2023/06/03/uni-shader5/13.png" alt></p>
<p>前面我们使用GrabPass {“_RefractionTex”}获得渲染纹理，实际上也可以不指定引号包裹的名称，区别在于使用名称后Unity在每一帧中只会对第一个使用了这个名称的物体执行一次屏幕抓取，后续所有使用该名称的物体都不会得到更新后的图片，而是采样同一个渲染纹理；不指定名称时，后面的Pass使用GrabTexture访问渲染纹理，Unity将会逐一给他们进行一次抓取。</p>
<h1 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h1><p>使用程序可以设计多样的纹理元素，用各种参数控制它们的外观，获得丰富的视觉体验。Unity中为这类纹理方法提供了一个专门的材质，称为程序材质。下面我们来学习如何实现这个纹理。</p>
<p>新建材质和脚本，注意这里我们不再编写Shader了，使用前两篇博客中的单张纹理的着色器即可。纹理也不需要指定，它会通过程序生成并指定。下面我们开始编写这个脚本。</p>
<p>首先我们声明脚本能够在编辑器模式下运行，在类名之前添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ExecuteInEditMode]</span><br></pre></td></tr></table></figure>
<p>然后编写程序纹理的类，声明以下变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ProceduralTextureGeneration : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">	//材质</span><br><span class="line">	public Material material = null;</span><br><span class="line"></span><br><span class="line">	#region Material properties</span><br><span class="line">	[SerializeField, SetProperty(&quot;textureWidth&quot;)]</span><br><span class="line">	private int m_textureWidth = 512;</span><br><span class="line">	public int textureWidth</span><br><span class="line">	&#123;</span><br><span class="line">		get</span><br><span class="line">		&#123;</span><br><span class="line">			return m_textureWidth;</span><br><span class="line">		&#125;</span><br><span class="line">		set</span><br><span class="line">		&#123;</span><br><span class="line">			m_textureWidth = value;</span><br><span class="line">			_UpdateMaterial();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[SerializeField, SetProperty(&quot;backGroundColor&quot;)]</span><br><span class="line">	private Color m_backgroundColor = Color.white;</span><br><span class="line">	public Color backgroundColor</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">			return m_backgroundColor;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">			m_backgroundColor = value;</span><br><span class="line">			_UpdateMaterial();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	[SerializeField, SetProperty(&quot;circleColor&quot;)]</span><br><span class="line">	private Color m_circleColor = Color.yellow;</span><br><span class="line">	public Color circleColor</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return m_circleColor;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">			m_circleColor = value;</span><br><span class="line">			_UpdateMaterial();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	[SerializeField, SetProperty(&quot;blurFactor&quot;)]</span><br><span class="line">	private float m_blurFactor = 2.0f;</span><br><span class="line">	public float blurFactor</span><br><span class="line">	&#123;</span><br><span class="line">		get</span><br><span class="line">		&#123;</span><br><span class="line">			return m_blurFactor;</span><br><span class="line">		&#125;</span><br><span class="line">		set</span><br><span class="line">		&#123;</span><br><span class="line">			m_blurFactor = value;</span><br><span class="line">			_UpdateMaterial();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	#endregion</span><br><span class="line">	</span><br><span class="line">	private Texture2D m_generatedTeture = null;</span><br></pre></td></tr></table></figure>
<p>这里我们使用了一个非常有用的插件<a href="https://github.com/LMNRY/SetProperty">SetProperty</a>，能让我们通过简单的语法SetProperty(“”)将私有变量进行序列化。上面我们声明了一些列的纹理属性，其中material是模型的材质，通过getcomponent获取；textureWidth是纹理的尺寸，backgroundColor是纹理的背景颜色，circleColor是即将绘制的圆圈的颜色，blurFactor是控制圆圈边界模糊的因子。</p>
<p>此外，这里还是用了一个自定义的方法_UpdateMaterial()用于在修改材质属性后更新材质。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        if(material == null)</span><br><span class="line">        &#123;</span><br><span class="line">			Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">			if(renderer == null)</span><br><span class="line">            &#123;</span><br><span class="line">				Debug.LogWarning(&quot;Cannot find a renderer.&quot;);</span><br><span class="line">				return;</span><br><span class="line">            &#125;</span><br><span class="line">			material = renderer.sharedMaterial;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		_UpdateMaterial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	private void _UpdateMaterial()</span><br><span class="line">    &#123;</span><br><span class="line">		if(material != null)</span><br><span class="line">        &#123;</span><br><span class="line">			m_generatedTeture = _GenerateProceduralTexture();</span><br><span class="line">			material.SetTexture(&quot;_MainTex&quot;, m_generatedTeture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Start方法中我们获取material即可。_UpdateMaterial中，我们调用另一个自定义的程序纹理生成函数，它返回一个纹理图片，然后我们设置材质的纹理为这个图片，就完成了纹理的赋值过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Color _MixColor(Color color0, Color color1, float mixFactor)</span><br><span class="line">	&#123;</span><br><span class="line">		Color mixColor = Color.white;</span><br><span class="line">		mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);</span><br><span class="line">		mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);</span><br><span class="line">		mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);</span><br><span class="line">		mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);</span><br><span class="line">		return mixColor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Texture2D _GenerateProceduralTexture()</span><br><span class="line">    &#123;</span><br><span class="line">		Texture2D proceduralTexture = new Texture2D(textureWidth, textureWidth);</span><br><span class="line"></span><br><span class="line">		float circleInterval = textureWidth / 4.0f;</span><br><span class="line"></span><br><span class="line">		float radius = textureWidth / 10.0f;</span><br><span class="line"></span><br><span class="line">		float edgeBlur = 1.0f / blurFactor;</span><br><span class="line"></span><br><span class="line">		//pixels</span><br><span class="line">		for(int w = 0; w &lt; textureWidth; w++)</span><br><span class="line">        &#123;</span><br><span class="line">			for(int h = 0; h &lt; textureWidth; h++)</span><br><span class="line">            &#123;</span><br><span class="line">				Color pixel = backgroundColor;</span><br><span class="line">				//9 circles</span><br><span class="line">				for(int i = 0; i &lt; 3; i++)</span><br><span class="line">                &#123;</span><br><span class="line">					for(int j = 0; j &lt; 3; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">						Vector2 circleCenter = new Vector2(circleInterval * (i + 1), circleInterval * (j + 1));</span><br><span class="line"></span><br><span class="line">						float dist = Vector2.Distance(new Vector2(w, h), circleCenter) - radius;</span><br><span class="line"></span><br><span class="line">						Color color = _MixColor(circleColor, new Color(pixel.r, pixel.g, pixel.b, 0.0f),</span><br><span class="line">							Mathf.SmoothStep(0f, 1.0f, dist * edgeBlur));</span><br><span class="line"></span><br><span class="line">						pixel = _MixColor(pixel, color, color.a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				proceduralTexture.SetPixel(w, h, pixel);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">        &#125;</span><br><span class="line">		proceduralTexture.Apply();</span><br><span class="line">		return proceduralTexture;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>最后两个方法稍显复杂，第一个方法是简单的颜色插值，调用unity的lerp函数根据混合因子对两个颜色进行插值，当因子为0返回第一个颜色，因子为1返回第二个颜色。</p>
<p>第二个方法就是我们主要编写的程序纹理方法了，它创建了一个2D的纹理，然后声明圆之间的间距，半径，模糊系数，遍历所有的像素点，根据像素点和圆心的位置远近，并乘以模糊系数来在背景颜色和圆圈颜色之间进行插值，这样一来靠近圆心的像素点颜色会更靠近圆圈的颜色，这就是基本的思路。</p>
<p><img src="/2023/06/03/uni-shader5/14.png" alt></p>
<p>Unity提供一类专门使用程序纹理的材质，叫做程序材质，它们和普通材质基本相同，但是使用的纹理是程序纹理。一般我们使用Substance Designed软件在Unity外部生成程序纹理和程序材质。</p>
<p>它是一个很好用的纹理生成工具，这里篇幅原因不展开说了，有需要的可以学习该软件并应用到自己的游戏项目中。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity初识(一)-布局和使用</title>
    <url>/2023/03/01/unity/</url>
    <content><![CDATA[<p>这是unity引擎学习的博客，首先会更新学习笔记，Unity学习的内容如下图，不过学习笔记将以项目为主，最后可能会汇总并按照大纲更新一遍教程。这篇博客将帮助你学会如何适用unity，包括物理、动画、渲染，最终你可以完成一个2D/3D游戏的制作，并且在后期可以进一步学习unity的高级渲染。</p>
<p>本次博客介绍下Unity界面，更多内容请查看后续更新。</p>
<span id="more"></span>
<p><img src="/2023/03/01/unity/1.png" alt> </p>
<p>上图展示了学习Unity的大致内容，如果你已经有了面向对象的编程基础，那么C#将变得十分容易，这里不做介绍。现在，我们从Unity的界面说起。</p>
<h1 id="界面和布局"><a href="#界面和布局" class="headerlink" title="界面和布局"></a>界面和布局</h1><p><img src="/2023/03/01/unity/3.png" alt></p>
<ul>
<li>标题栏：标题栏显示当前项目信息，标题组成是当前项目-项目组件-运行环境-Unity版本-图形API；</li>
<li>菜单栏：Unity编辑器的各种选项卡；</li>
<li>工具栏：操作视图场景和编辑器布局的工具选项；</li>
<li>状态栏：显示程序警告、错误信息；</li>
<li>Scene视图：编辑场景的地方，所有元素的设置都在Scene中修改；</li>
<li>Game视图：最终游戏展示的场景，可以运行；</li>
<li>Project窗口：资源库，管理资源；</li>
<li>Hierarchy窗口：层级窗口，游戏中的对象、元素按照层级顺序排列，可以快速确定、选中对象；</li>
<li>Inspector窗口：检查窗口，可以显示，调整选中对象的属性。</li>
</ul>
<h2 id="1-Scene-View的使用"><a href="#1-Scene-View的使用" class="headerlink" title="1 Scene View的使用"></a>1 Scene View的使用</h2><p><img src="/2023/03/01/unity/4.png" alt></p>
<p>在Scene View中，可以对所有游戏对象进行互动，选中，定位，从而方便我们布置游戏场景。</p>
<h2 id="1-1-操作视角的移动"><a href="#1-1-操作视角的移动" class="headerlink" title="1.1 操作视角的移动"></a>1.1 操作视角的移动</h2><h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>2D和3D坐标轴的切换通过工具栏的按钮完成，按钮显示当前状态，点击后改变当前的维度；在Unity中，使用的三位坐标系是左手坐标系，X轴代表水平方向，Y轴代表竖直方向，Z轴代表深度。</p>
<p>Unity的坐标系分类于图形API中介绍的概念类似，分别是：</p>
<ul>
<li>世界坐标系：整个场景中描述物体位置的坐标系；</li>
<li>局部坐标系：描述单个物体的坐标系；</li>
<li>屏幕坐标系：图形经过选然后显示成屏幕像素的坐标系；</li>
<li>视口坐标系：图形经过渲染后，坐标压缩在[0,1]之间的坐标系；</li>
<li>GUI坐标系：最后呈现的可视化图形界面中，物体的坐标系。</li>
</ul>
<p>在点击按钮，转换为3D坐标系后，窗口右上角会提供一个工具：</p>
<p><img src="/2023/03/01/unity/5.png" alt></p>
<p>利用这个工具可以快速调整视角，单机锥形可以将当前操作视角和该锥形代表的轴对齐，锥形底座代表屏幕，尖端代表方向；右键正方体可以激活菜单，菜单中free选项代表默认视角。</p>
<h3 id="导航工具"><a href="#导航工具" class="headerlink" title="导航工具"></a>导航工具</h3><p>除了调整操作视角的朝向，移动位置也是有必要的，如同OpenGL中glLookat函数的原理。为了查看整个场景安排，缩放也是需要掌握的操作。</p>
<p>移动方式：</p>
<ul>
<li>按住右键后，通过WASD前后左右移动，QE上下移动，按下shift键可以加速移动；</li>
<li>左侧工具栏切换到手型按钮（快捷键Q），即可左键拖动屏幕，此时不能选中；</li>
<li>按住alt键，此时按住鼠标中键也可以进行移动；</li>
</ul>
<p>缩放方式：</p>
<ul>
<li>按下alt键，此时左键可以移动视角，右键可以对场景进行缩放；要注意这里左键的移动视角和之前不同了，这里的移动视角指的是，以场景坐标原点为中心，环绕操作视角，而上面提到的则是直接移动视角，和我们平时3D游戏中完全相同（即场景漫游）。因此，场景漫游起始也可以实现场景缩放的效果。</li>
</ul>
<p>如果不小心将视角调整到不能判断的地方，可以双击层级窗口中的对象，或者选中后按下F键，就能快速定位到这个物体，然后重新调整。</p>
<p>总结起来说，按下鼠标右键进入”漫游模式“，可以任意移动操作视角；按下alt键后进入”旋转模式“，此时以坐标原点为中心进行操作。</p>
<h2 id="1-2-选中对象"><a href="#1-2-选中对象" class="headerlink" title="1.2 选中对象"></a>1.2 选中对象</h2><p>（Hierarchy）层级栏中，展示了所有存在的对象，那么从场景视图中，可以更直观和清晰地选择想要修改的对象。</p>
<h3 id="选中方式"><a href="#选中方式" class="headerlink" title="选中方式"></a>选中方式</h3><ul>
<li>单机场景中的某个对象，选中后对象的信息会显示在检查栏（Inspector）中；</li>
<li>如果对象存在重叠，那么重复单机，选中对象会在这些重叠对象中循环；</li>
<li>在视图右上角的搜索框中搜索对象；</li>
<li>拖拽鼠标左键，选中框内所有对象；但是注意此时的工具状态要为矩形工具（Rect Tool）；</li>
<li>按住shift后点击左键，同样是矩形工具；</li>
<li>选中后，还可以按住Ctrl键，进一步添加、减少选中的对象；</li>
</ul>
<h3 id="设置选中许可"><a href="#设置选中许可" class="headerlink" title="设置选中许可"></a>设置选中许可</h3><p>在层级栏中，为了让一些没必要修改、移动的对象保持状态，可以设置其选中属性，方法是单机对象在层级栏中，名字左侧的手型按钮。</p>
<ul>
<li>点击手型按钮，更改对象和对象全部的子对象的选中属性；</li>
<li>按住shift键再点击，仅更改对象，不更改子对象的选中属性；</li>
</ul>
<h2 id="1-3-对象的移动"><a href="#1-3-对象的移动" class="headerlink" title="1.3 对象的移动"></a>1.3 对象的移动</h2><p>场景视图提供了方便的操作，来对所有对象进行调整，从而方便安排场景。移动方式主要是工具栏中的五个按钮：</p>
<p><img src="/2023/03/01/unity/6.png" alt></p>
<ul>
<li>移动：使用移动工具（图1）的情况下（快捷键W），物体选中后会有相应的坐标轴显示出来，鼠标移动到坐标轴上并且进行拖动，即可更改物体的位置；拖动两个坐标轴构成的小平面，可以让物体在这个平面上进行移动；按住shift键，可以让物体在垂直于当前操作摄像机视角的平面上进行移动；</li>
<li>旋转：使用旋转工具（图2）的情况下（快捷键E），有三根线分别代表三个坐标轴，拖动细线能够让物体垂直于相应的坐标轴进行旋转；最外层的白色细线则是对应当前的操作摄像机视角，让物体垂直于当前视角旋转；</li>
<li>缩放：使用缩放工具（图3）的情况下（快捷键R），拖动三个坐标轴，让物体沿着对应的轴进行缩放，拖动中间的正方体，让物体等比例缩放；</li>
<li>2D变换：使用矩形工具（图4）的情况下（快捷键T），一般用来对2D物体进行修改，拖动四个矩形顶点即可；</li>
<li>3D变换：使用变换工具（图5）的情况下（快捷键Y），综合了移动、旋转、缩放功能，操作和上面介绍的方式完全相同；</li>
</ul>
<p>对象的移动修改了对象的位置，位置作为属性，在检查栏中的Transform选项卡可以查看、修改。</p>
<p>另外，在移动的时候，某些对象可能含有子对象，如果希望在修改的同时不影响子对象，要确保切换到Pivot模式；如果要修改对象及其子对象形成的外接盒，那么就切换到Center模式。</p>
<p>同理，在旋转的时候，希望对象以父对象为中心，那么就切换到Local模式；否则就切换到Global模式。这两个按钮都在视图工具栏中，作为选项卡存在。</p>
<h2 id="1-4-视图工具栏"><a href="#1-4-视图工具栏" class="headerlink" title="1.4 视图工具栏"></a>1.4 视图工具栏</h2><ul>
<li>Draw Mode：切换不同的绘制模式，不同选项含义基本如下：</li>
</ul>
<p><img src="/2023/03/01/unity/7.png" alt></p>
<ul>
<li>2D：切换2D和3D模式；</li>
<li>Lighting：开启/关闭光照；</li>
<li>Audio：开启/关闭声音；</li>
<li>Effects：管理特效，选型卡含义基本如下：</li>
</ul>
<p><img src="/2023/03/01/unity/unity\8.png" alt></p>
<ul>
<li>Visibility：开启/关闭场景的可见性，方法和对象拾取的设置相同；</li>
<li>Grid：设置系统网格；</li>
<li>Camera：设置场景摄像机的各项属性：</li>
</ul>
<p><img src="/2023/03/01/unity/9.png" alt></p>
<ul>
<li>Gizmo：在场景和游戏视图中都可以使用，用来标记不可见的游戏对象。</li>
</ul>
<h2 id="2-Game-View的使用"><a href="#2-Game-View的使用" class="headerlink" title="2 Game View的使用"></a>2 Game View的使用</h2><p>Game视图中，有三个按钮控制游戏演示，播放(Ctrl+P)、暂停(Ctrl+Shift+P)、按帧播放(Ctrl+Alt+P)，在播放状态下，可以进行游戏演示的试玩，但是试玩过程中进行的所有操作都是暂存的，结束播放以后将重置状态。</p>
<p>除此外，视图中还有一个工具栏，功能如下：</p>
<p><img src="/2023/03/01/unity/10.png" alt></p>
<ul>
<li>Game：切换Game运行的平台，点击选项卡Stimulator后，可以切换到模拟器视图，用模拟器查看不同设备上游戏运行的情况；</li>
<li>Display：切换到不同场景摄像机视角；</li>
<li>Free Aspect：调整设备尺寸，分辨率等，可以自行添加自定义尺寸；</li>
<li>Scale：缩放；</li>
<li>Play Focused：设置演示时是否最大化；</li>
<li>Mute Audio：声音；</li>
<li>Stats：性能统计；</li>
<li>Gizmos：和Scene视图中的Gizmos相似；</li>
</ul>
<h2 id="3-Hierarchy窗口的使用"><a href="#3-Hierarchy窗口的使用" class="headerlink" title="3 Hierarchy窗口的使用"></a>3 Hierarchy窗口的使用</h2><p>场景中游戏对象的管理器，包括模型、摄像机、预制件等，和Scene中的物体一一对应。</p>
<p>窗口功能有：</p>
<ul>
<li>对象父子关系的设置；</li>
<li>游戏对象的管理，复制、粘贴、删除、更改嵌套关系，排序等；</li>
<li>多场景编辑；</li>
</ul>
<h2 id="4-Project窗口的使用"><a href="#4-Project窗口的使用" class="headerlink" title="4 Project窗口的使用"></a>4 Project窗口的使用</h2><p>Project窗口管理所有的项目资源，用于查找文件和资源导航；功能和资源管理器类似，能直接进行创建、删除等文件操作。</p>
<h3 id="4-1-工具栏"><a href="#4-1-工具栏" class="headerlink" title="4.1 工具栏"></a>4.1 工具栏</h3><p><img src="/2023/03/01/unity/11.png" alt></p>
<ul>
<li>加号：创建文件，给出多种文件类型，或者添加资源；</li>
<li>搜索框：按照文件命搜索；</li>
<li>打开搜索框：用于以单独窗口进行搜索；</li>
<li>按类型搜索，如网格、预制件；</li>
<li>按标签搜索；</li>
<li>收藏文件，将按照当前的搜索设置生成一个过滤器，添加到Favorites中；</li>
<li>更改隐藏文件可见性；</li>
</ul>
<h3 id="4-2-基本目录说明"><a href="#4-2-基本目录说明" class="headerlink" title="4.2 基本目录说明"></a>4.2 基本目录说明</h3><p>通常项目会将所有文件分别放在两个根目录中，一个是Assets，一个是Packages，前者是游戏的资源文件，包括动画、纹理等内容，后者则是游戏运行需要的库文件，一般不需要手动进行链接等操作了。</p>
<h2 id="5-Inspector窗口"><a href="#5-Inspector窗口" class="headerlink" title="5 Inspector窗口"></a>5 Inspector窗口</h2><p>显示游戏对象的所有属性，包括渲染设置、碰撞设置、移动变换设置等。</p>
<ul>
<li>如果选中了相同类型的多个资源，窗口将显示他们共有的属性；如果是多个不同类型的资源，窗口会给出各种类型资源的数量，单机该列表以后可以看到该类型的所有资源。</li>
<li>一个游戏对象通常关联许多其他的资源，在该窗口中使用Ping选项卡可以快速定位到这些有关联的物体，称为查找“源”。</li>
</ul>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(十)-动画系统(一)</title>
    <url>/2023/04/25/unity10/</url>
    <content><![CDATA[<p>有了场景，我们想让角色动起来，制作一个移动系统，使用IK动画来进行优化，然后配合第三人称摄像机，就可以在自己制作的场景中漫游了。其中动画系统的使用是重点，无论是角色在各种地形上动画的矫正，还是移动时动画的播放，都需要我们完全掌握动画系统的使用，这篇博客就详细说明动画系统各个部分的使用，主要是前面没有提到过的内容。</p>
<span id="more"></span>
<p>经过前面的学习我们知道，2D动画中有三个重要概念：</p>
<ul>
<li>Animation Clip：制作动画的基本素材，包含动画的关键帧</li>
<li>Animator Controller：动画状态机，控制动画如何播放</li>
<li>Animator Component：动画组件，实现脚本和Controller的交互，以及绑定骨骼等动画管理</li>
</ul>
<p>这里就不重复说明了，不过当涉及人形动画的时候，还有一个重要的概念：Avatar，也就是我们在前面博客中绑定的骨骼。</p>
<p>现在我们深入认识这些概念的用法。</p>
<h1 id="Animation-Clip"><a href="#Animation-Clip" class="headerlink" title="Animation Clip"></a>Animation Clip</h1><p>我们现在直接用unity制作一个开关门的动画，新建一个Cube并拉伸到门的尺寸，然后创建一个空游戏对象pivot在门的侧边上，接着将door设置为pivot的子对象，然后试着旋转Y轴，你就会发现现在门的旋转轴已经变成在它边框上的pivot了。</p>
<p><img src="/2023/04/25/unity10/1.png" alt></p>
<p>然后我们选中pivot，打开Animation窗口，点击Create创建一个Animation Clip，命名为doorOpen，和之前一样，Unity给pivot自动添加了Animator组件、设置了Animation Controller，并有了第一个Clip。</p>
<p>此时打开存放动画的文件夹，用文本编辑器打卡Clip对应的文件，可以看到Clip实际上是用YAML语言制作的，Unity中大多数资源文件都是用这个语言编写的，可以看到此时文本中具有很多属性，内容为空，并且是以Curves进行命名，这个我们稍后再说。</p>
<p>下面我们选中pivot并回到Animation窗口，点击Add Property，就是添加属性内容，这里可以选择如何让游戏对象变化，使得Clip记录不为空，就能让动画生效了。</p>
<p>因此我们选择加入Transform-Rotation属性并添加，选择一分钟刻度对应的地方，可以看到白色提示线，并且此时Animation窗口中的Preview窗口右上角显示为60，表示我们在处理第60帧，也就是我们的动画默认60帧/S。</p>
<p><img src="/2023/04/25/unity10/2.png" alt></p>
<p>接着我们将左边Rotation.y修改为120，拖动时间轴，发现Unity使用插值算法修补了我们中间没有设置的帧的旋转值。然后点击下面的Curves按钮，转到曲线界面，这就是实际保存在文本中的内容了，可以通过曲线查看和修改当前动画，这就是为什么使用Curves来保存。</p>
<h2 id="动画复用"><a href="#动画复用" class="headerlink" title="动画复用"></a>动画复用</h2><p>了解了为什么要使用Curves和文本的方式来保存动画，就可以进一步学习动画复用了。我们选中刚才制作的Clip文件，然后新建一个3D对象拖到其Inspector窗口下面的预览中：</p>
<p><img src="/2023/04/25/unity10/4.png" alt></p>
<p>此时发现方块也在旋转，说明这个动画可以用到它上面，甚至是我们的人形模型：</p>
<p><img src="/2023/04/25/unity10/3.png" alt></p>
<p>当一个游戏对象包含多个子对象的时候，Property选项也会给出对应子对象的动画选项，这里我们创建一个双开门，删除创建的动画和动画组件，将刚才的门复制一个，然后新建一个空游戏对象作为它们的父对象，接着重新添加动画Clip，点击Add Property：</p>
<p><img src="/2023/04/25/unity10/5.png" alt></p>
<p>这时分别添加两个子对象的旋转属性，然后设置到合适位置，得到双开门的动画。重新打开Clip文本文件，此时看到其中用我们的命名给这两个子对象设置了旋转曲线，也就是说，Unity会根据子对象的命名来寻找这个对象，并让这个对象发生对应的旋转，如果我们修改了子对象的名称，那么Unity找不到对应的物体，就不能正常播放了。</p>
<p><img src="/2023/04/25/unity10/6.png" alt></p>
<p>那么现在我们清楚了，当动画文件中指定子对象名称一致的时候，动画就可以实现相同的效果，也就是动画复用；如果没有，那么动画不起作用。而父对象的命名则没有要求，因为动画文件搜索的就是发生变化的子对象。因此，对于人形动画，我们将所有关节作成一个pivot，Clip描述这些关节的运动，就得到了人物的动画。</p>
<p>那么问题来了，如果确保人体关节的命名一致？美术人员制作的动画很可能命名不同，甚至骨骼结构也不同，这时就需要使用替身系统了。</p>
<p>前面我们说Avatar就是骨骼实际上并不准确，Avatar是替身的意思，在Unity中想要复用一个动画到另一个骨骼不同的角色上，需要我们进行以下步骤：</p>
<ul>
<li>选中模型，使用Unity的Rig/Animation Type/Humanoid设置导出该角色骨骼和Unity标准骨骼对应的信息，也就是模型展开后的蓝绿色的小人；Animation Type的其他设置为Legacy旧版动画，Generic通用动画，None无动画；</li>
<li>Unity将原来的动画文件对原骨骼的描述转化为对标准骨骼的描述；</li>
<li>通过标准骨骼作为中介，将动画复用到新角色上面。</li>
</ul>
<p><img src="/2023/04/25/unity10/7.png" alt></p>
<p>Animation Define两个选项：</p>
<ul>
<li>Create From This Model：根据该模型建立Avatar；</li>
<li>Copy From Another Model：拷贝另一个已经配置好的Avatar；</li>
</ul>
<p>Skin Weights：</p>
<ul>
<li>蒙皮能够被几个骨骼的运动影响，默认是4根；</li>
</ul>
<p>Optimize Game Objects：</p>
<ul>
<li>选中后将删除原来无用的模型骨骼从而节省空间；</li>
</ul>
<p>现在点击Apply确认，看到Inspector窗口中本来灰色的Configure按钮可以使用了，点击后进入Avatar设置界面，它包含一个Mapping映射设置和Muscles &amp; Settings设置，我们先看前者。</p>
<h3 id="Mapping设置"><a href="#Mapping设置" class="headerlink" title="Mapping设置"></a>Mapping设置</h3><p><img src="/2023/04/25/unity10/8.png" alt></p>
<p>这些是骨骼映射信息，进入的时候Unity已经自动绑定了。</p>
<p>下拉界面，点击左下角的Mapping：</p>
<ul>
<li>Clear：清空映射；</li>
<li>Auto Map：自动映射；</li>
<li>Load：加载映射；</li>
<li>Save：将当前映射保存为模板Template；</li>
</ul>
<p>点击Pose：</p>
<ul>
<li>Reset：重置角色动作，如果FBX文件包含动画则会显示动画动作；</li>
<li>Sample Bind-Pose：改成绑定骨骼时的造型；</li>
<li>enforce T-Pose：强制模型为T-pose；</li>
</ul>
<p>如果骨骼不正确，需要在这里重新手动绑定以下。</p>
<h3 id="Muscles-amp-Settings"><a href="#Muscles-amp-Settings" class="headerlink" title="Muscles &amp; Settings"></a>Muscles &amp; Settings</h3><p>这是用来调整角色动作的设置，可以拖动滑动条来查看角色的肌肉能被拉伸到什么程度，或者作出限制。</p>
<p><img src="/2023/04/25/unity10/9.png" alt></p>
<p>设置完成后点击Done退出Configure。现在我们了解整个原理了，不过有一个操作我们没有做过，当出现无法适配的动画时，可以点开FBX动画的Inspector窗口，将动画的Rig设置为Copy From Other Avatar，并选择需要适配的模型作为Copy对象即可。也可使用动画自己创建的Avatar进行调整，最终达到满意的效果。</p>
<h1 id="Animator组件"><a href="#Animator组件" class="headerlink" title="Animator组件"></a>Animator组件</h1><p>前面接触很熟悉了，要再说明的就是Avatar，如果没有绑定骨骼，那么会按照模型原本的骨骼去严格匹配动画。使用Avatar的话不仅能在子对象中寻找，就算是在很多层下面也能成功映射。下面说一说前面没使用的属性：</p>
<p><img src="/2023/04/25/unity10/10.png" alt></p>
<ul>
<li>Apply Root Motion：应用动画本身的移动；</li>
<li>Update Mode：更新计算骨骼节点位移的方式，Normal表示和帧率同步，Animate Physics表示和物理系统同步，用到物理组件的时候就会刷新，unscaled time表示忽略时间标尺。</li>
<li>Culling Mode：剔除不可见动画的方式，Always Animate表示不剔除，Cull Update Transforms会停止IK动画(后面介绍)之类的操作，Cull Completely表示不可见时完全停止动画。</li>
</ul>
<h1 id="Animator-Controller"><a href="#Animator-Controller" class="headerlink" title="Animator Controller"></a>Animator Controller</h1><p>现在我们开始介绍最重要的状态机，与前面介绍的2D相比，3D部分新增加用到的就是Layers了，它可以让角色的不同部分播放不同的动画，这样在我们有两个动画Clip的时候，让角色的一部分播放第一个动画，另一部分播放第二个动画，可以实现其他的动画效果。</p>
<p>另外界面右上角有一个Auto Live Link，开启后可以在运行时跟踪当前播放的状态。</p>
<h2 id="动画状态的属性"><a href="#动画状态的属性" class="headerlink" title="动画状态的属性"></a>动画状态的属性</h2><p>选中一个状态，查看Inspector窗口：</p>
<p><img src="/2023/04/25/unity10/11.png" alt></p>
<ul>
<li>Speed：播放速度，如果要在脚本中使用这个属性，需要勾选下面的Multiplier并添加对应的Float变量作为中间变量，动画实际播放速度是Speed和这个变量的乘积；</li>
<li><p>Motion Time：仅播放动画的特定帧，要关联一个Float变量，0表示开始时，1表示结束时；</p>
</li>
<li><p>Mirror：镜像动画，仅对人形动画有作用，要关联一个Bool变量；</p>
</li>
<li>Cycle Offset：开始播放时动画的偏移，表示从哪一帧开始播放，同样0表示开始，1表示结束，关联一个Float变量；而且后续循环播放动画的时候不会有影响；</li>
</ul>
<h3 id="Foot-IK和IK"><a href="#Foot-IK和IK" class="headerlink" title="Foot IK和IK"></a>Foot IK和IK</h3><p>Inverse Kinematics，反向动力学，一般来收我们计算角色动画是从根节点到末端骨骼的，这种称为正向动力学，Forward Kinematics，但是有时候我们希望角色的末端骨骼放到特定的地方，因而先确定末端骨骼的位置，再反向计算根节点。</p>
<p>Unity中可以在运行中选中角色，然后勾选Gizmos中的Animator，可以看到出现了一些小红球，这些红球称为IK Goal，是Unity提供的关于骨骼位置的标记，表示当前角色的某个骨骼应该靠近哪个地方，因此利用IK Goal可以查看确认角色动画是否完美匹配了。</p>
<p><img src="/2023/04/25/unity10/12.png" alt></p>
<p>可以看到这里模型匹配地还是不错的，而我们动画状态的Foot IK属性勾选后，就会稍微纠正脚步的动作，让脚往对应的两个红球上靠近，从而调整动画，我这里由于匹配很好，所以勾选后没有变化。</p>
<p>而且，修改IK Gola也不会改变Foot IK的位置，因为Foot IK参照的是原本的IK Goal，即使我们在代码中修改了IK Goal，Foot IK还是会按照运行之前的位置调整。因此，要让角色真正实现指挥身体这个操作，还是要靠我们实际改动IK Goal并在脚本中告诉角色怎么去运动，而不是勾选Foot IK。</p>
<p>现在我们尝试调整IK Goal，在Animator/Layers窗口中点击Base Layer的设置，勾选IK Pass，就可以调用IK的API了。给角色添加一个脚本，然后增加以下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    Animator animator;</span><br><span class="line">    [<span class="meta">Range(0, 1)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> weight = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorIK</span>(<span class="params"><span class="built_in">int</span> layerIndex</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetIKPosition(AvatarIKGoal.RightFoot, <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到如下结果，当我们不调整这个weight时，角色不会靠近我们设置的IK Goal，调整weight后角色将右脚放在这个点上。</p>
<p><img src="/2023/04/25/unity10/13.png" alt></p>
<p>配合射线检测地形，就可以制作好的适应地形的效果，我们后面再说IK怎么做。当然，如果模型某一部分和动画不匹配，也可以直接设置weight为1，绑定到对应的IK Goal上。</p>
<h3 id="Write-Default"><a href="#Write-Default" class="headerlink" title="Write Default"></a>Write Default</h3><p>这个选项默认开启，我们先介绍一个方法OnEnable，和Awake方法有点类似，这个方法会在对象被启用的时候调用，对象实例化的时候就也会调用这个方法。因此，Animator挂接到对象以后，开始游戏，对象被实例化的时候Animator被启用，它的OnEable方法就会记录当前状态机里的Clip修改了哪些属性，作为默认值。</p>
<p>那么在一些情况下，一个动画Clip中只包含对某些对象的属性更改，另一些对象的属性更改并不存在，例如电梯开门动画和电梯的上下行动画，前者只控制门的位移，后者控制电梯(包括电梯门，门是它的子对象)的位移，此时由于Animator记录了开始的那一帧中，这些对象的位置，也就是默认值，会自动填充给当前状态对应的动画Clip中没有修改的对象，例如电梯开门动画中没有对电梯这个对象的修改，这导致本来不想修改这个电梯对象时反而让电梯读取默认值发生了动画。</p>
<p>因此，如果开始的时候电梯在下层，那么我们先让电梯转移到上层，然后开门，开门动画没找到电梯对象的变换，所以填充默认值，导致电梯总是转移到下层再开门。如果状态中存在改变这个对象的属性，那么就交给这个值处理，所以不会发生问题，也就是开门动画。</p>
<p>更多技术讲解可以异步这篇<a href="https://blog.csdn.net/rickshaozhiheng/article/details/77838379">博客</a>。</p>
<h2 id="动画转换的属性"><a href="#动画转换的属性" class="headerlink" title="动画转换的属性"></a>动画转换的属性</h2><p>之前我们用到不少状态机中动画转换的属性了，这里仅介绍没有使用的：</p>
<p><img src="/2023/04/25/unity10/14.png" alt></p>
<ul>
<li>solo/Mute：当有多个同方向的转换时，勾选solo表示仅执行这些选中的转换，哪个条件满足就执行哪个；如果同时满足，执行排在上面的转换，在动画状态中可以调整顺序，但在转换属性中不可以调整。Mute表示转换永不执行；</li>
<li>白色曲线：表示Root Motion，动画自带的位移；</li>
<li>Fixed Duration：下一项转换时间计算按秒还是按百分比；</li>
<li>Transition Offset：进入下一个动画的偏移量；</li>
<li>Interruption Source：可以打断当前转换的Transition；</li>
<li><p>Ordered Interruption：和上面的有关，下次再说；</p>
</li>
<li><p>Conditions：可以添加多个转换条件，它们之间的关系是逻辑与；如果希望转移之间存在逻辑或的条件，可以通过设置多个同方向转换实现；</p>
</li>
</ul>
<h3 id="Transition-Interruptions"><a href="#Transition-Interruptions" class="headerlink" title="Transition Interruptions"></a>Transition Interruptions</h3><p>我们详细说明一下前面略过的Interruption Source和Ordered Interruption两个属性，一般动画的转移都是不可打断的，但是有些时候我们希望动画和玩家的交互是及时的，当玩家发出命令以后不管角色此时处于什么动画，或者处于什么动画之间的转换，都要将这个动画/转移打断，然后向新的转移变换。</p>
<p>那么这里又涉及状态转换的优先级了，前面我们说状态转换之间存在优先级，当勾选了多个solo的转移时，如果同时条件满足，将执行排在状态的Inspector/Transitions上面的转换，也就是从上往下转移的优先级降低。这其实就是Ordered Interruption选项的作用，这个选项默认被勾选，表示按照状态转换的优先级来执行状态之间的打断。</p>
<p>例如下面这个Run状态的属性中有两个转移，分别转移到Idle和Jump状态，此时转移到Idle的状态转移就具有更高的优先级。此时能Run-&gt;Idle能打断Run-&gt;Jump的转换，而后者却不能打断前者的转换。</p>
<p><img src="/2023/04/25/unity10/15.png" alt></p>
<p>如果取消了Ordered Interruption，那么优先级关系不会被应用，状态转换之间可以任意打断。</p>
<p>然后再看Interruption Source的选项，代表能够打断当前转换的状态转换的源：</p>
<ul>
<li>Current State：从当前转移的当前状态出发的所有转移；</li>
<li>Next State：从当前转移的下一个状态出发的所有转移；</li>
<li>Current State Then Next State：两个状态出发的转移都可以打断，但是当前状态出发的优先级更高；</li>
<li>Next State Then Current State：两个状态出发的转移都可以打断，但是下一个状态出发的优先级更高；</li>
</ul>
<p>解释一下后两个，我们知道同时激活多个状态转换的时候状态机根据优先级判断哪个转换被执行，那么状态之间的打断也是类似的，一个状态在执行的时候，同时有两个可以打断它的动画出现了，那么状态机就会根据上面的选项来判断，选择Current State Then Next State时就会执行从当前状态出发的，另外一个从下一状态出发的但是同时被激活的状态转移不会被执行。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(十一)-动画系统(二)</title>
    <url>/2023/04/26/unity11/</url>
    <content><![CDATA[<p>除了上次介绍的内容外，这篇博客中我们还会进一步使用New Input System和Root Motion，后者是很常见的动画概念，动画是可以包含角色移动控制的，这里会着重讲解。</p>
<span id="more"></span>
<h1 id="New-Input-System"><a href="#New-Input-System" class="headerlink" title="New Input System"></a>New Input System</h1><p>与我们一直使用的输入系统相比，新输入系统有更好的性能，还提供更好的扩展性，所以我们有必要学习。要使用它，需要我们在Package Manager/Registry中搜索input system并安装，完成后会提示需要重启。</p>
<p><img src="/2023/04/26/unity11/1.png" alt></p>
<p>然后选中角色，添加Player Input组件，这就是new input system提供的，它需要一个配置文件来定义玩家的输入，点击Create创建，我们使用默认配置，保存会会打开这个配置的编辑窗口，我们先放在一边；然后修改Behavior属性为Invoke Unity Events，表示检测到输入时执行Unity的事件方法，从而调用我们编写的脚本函数。</p>
<p><img src="/2023/04/26/unity11/8.png" alt></p>
<p>接着展开下面的Events，可以看到列出了很多空表，它们对应左侧配置窗口中的信息，表示此时执行Callback回调，这里用法其实就是我们将写好的方法添加到右侧的List中注册，那么当右侧被回调的时候就会连带执行我们注册的方法了，例如Move中WASD表示按下WASD移动角色，并且此时系统检测到玩家处于Move状态，那么就执行Move的回调函数，将我们播放动画的方法添加进去，那么角色移动的同时就会播放动画了。</p>
<p>上面图中选中了Move，看到右边的Action Type为Value，Control Type为Vector2，即决定角色动作触发的形式是采用值判断，控制方式为使用二维向量，其中x值表示AD的按键，y值表示WS的按键，而且如果同时按下W和D，这个二维向量不会是(1,1)，因为Unity会自动归一化长度超过1的向量。</p>
<p>下面我们开始编写等待调用的方法，新建一个脚本，添加以下内容：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Animator animator;</span><br><span class="line">    <span class="built_in">float</span> threshold = <span class="number">0.1f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> forwardSpeed = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> backwardSpeed = <span class="number">-1.5f</span>;</span><br><span class="line">    <span class="built_in">float</span> currentSpeed;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        moveCharacter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveCharacter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 movement;</span><br><span class="line">        movement = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, currentSpeed * Time.deltaTime);</span><br><span class="line">        transform.position += movement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params">InputAction.CallbackContext callbackContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录玩家输入</span></span><br><span class="line">        Vector2 movement = callbackContext.ReadValue&lt;Vector2&gt;();</span><br><span class="line">        currentSpeed = <span class="number">0f</span>;</span><br><span class="line">        <span class="keyword">if</span>(movement.y &gt; threshold)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;Forward&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            currentSpeed = forwardSpeed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (movement.y &lt;= threshold)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;Forward&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (movement.y &lt; -threshold)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;Backward&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            currentSpeed = backwardSpeed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (movement.y &gt;= -threshold)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;Backward&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>保存后运行游戏，我们的人物现在可以通过WS控制前进和后退，使用摇杆的玩家也可以通过我们设定的阈值来进行输入，而且动画可能并不匹配人物移动的速度，这可以通过调整动画或者移动的速度来控制，我们后面会用Root Motion来彻底解决问题。</p>
<p>除此外，这里我们一按下按键角色就开始进行移动了，而且对使用手柄或者手机摇杆的玩家很不友好，通常希望移动遥感的程度与角色移动的速度同步，并且在从静止切换走路的时候速度是逐渐加快的，到因此我们修改一下，将上面的currentSpeed重命名为targetSpeed，然后调用线性插值方法来使我们的currentSpeed从零逐渐提高到targetSpeed，因为moveCharacter方法每帧都会调用一次，意味着currentSpeed总是在向TargetSpeed靠近而不是直接等于；然后对于移动的targetSpeed也乘上玩家输入的控制值movement.y。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意不要设置currentSpeed初始化为0，Lerp方法的第三个参数t表示插值返回的值有多靠近第一个参数，例如这里0.9就是取			//(targetSpeed-currentSpeed)*0.9+currentSpeed</span></span><br><span class="line">   currentSpeed = Mathf.Lerp(targetSpeed, currentSpeed, <span class="number">0.9f</span>);</span><br><span class="line"></span><br><span class="line">targetSpeed = forwardSpeed * movement.y;</span><br><span class="line">targetSpeed = backwardSpeed * movement.y;</span><br></pre></td></tr></table></figure>
<p>这样就改进了没有过渡速度的问题，而且手柄玩家也可也正常使用这个移动系统了。但是还有一个问题没解决，我们的移动速度在变化，但是动画的播放速度并不会同步，这就要使用我们之前熟悉过的Blend Tree了。所以我们通过将速度传递给Blend Tree之后，混合树会根据currentSpeed帮我们计算当前动画的状态。</p>
<p>最终我们的代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Animator animator;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> forwardSpeed = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> backwardSpeed = <span class="number">1.5f</span>;</span><br><span class="line">    <span class="built_in">float</span> targetSpeed;</span><br><span class="line">    <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    Vector3 movevalue;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        moveCharacter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveCharacter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentSpeed = Mathf.Lerp(targetSpeed, currentSpeed, <span class="number">0.9f</span>);</span><br><span class="line">        movevalue = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, currentSpeed * Time.deltaTime);</span><br><span class="line">        transform.position += movevalue;</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;Speed&quot;</span>, currentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params">InputAction.CallbackContext callbackContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录玩家输入</span></span><br><span class="line">        Vector2 movement = callbackContext.ReadValue&lt;Vector2&gt;();</span><br><span class="line">        targetSpeed = movement.y &gt; <span class="number">0</span> ? forwardSpeed * movement.y : backwardSpeed * movement.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只不过我们由于删除了阈值，所以如果玩家的摇杆有漂移、损坏的情况就会很难受，他们的输入始终无法达到最值1，所以我们速度的最大值也无法达到，因此我们重新打开new input system的配置文件，添加一个叫Stick DeadZone的processor：</p>
<p><img src="/2023/04/26/unity11/4.png" alt></p>
<p>这个processor会对输入的数据进行处理，最小值意味着[-0.125,0.125]之间的输入会被视为0，防止误触；小于-0.925的会被视为-0，大于0.925的会被视为1。</p>
<h1 id="Root-Motion"><a href="#Root-Motion" class="headerlink" title="Root Motion"></a>Root Motion</h1><p>我们先尝试简单使用Root Motion功能，首先在Maximo上找到包含Root Motion的动画，你可以使用这个<a href="https://www.mixamo.com/#/?page=1&amp;query=locomation+pack">移动包</a>，下载之后我们复制一个角色出来，然后重新更改状态机，使用Pack中提供的Walking，Running，Idle三个动画，你可以在预览窗口中查看是否正确，确保将他们都设置为人形动画。</p>
<p>如果你角色的Animator窗口中勾选了Apply Root Motion属性，那么此时播放Walking或者Running时预览窗口中的角色就会有自主的位移了。然后添加一个只设置状态机变量而完全不处理输入的脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerRootmotion</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    Animator animator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerMove</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 movement = context.ReadValue&lt;Vector2&gt;();</span><br><span class="line">        <span class="keyword">if</span> (movement.y &gt; <span class="number">0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;Forward&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;Forward&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (movement.y &lt; <span class="number">0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;Backward&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;Backward&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>保存并运行游戏，发现角色确实会自己移动，但是角色的移动并不正确，不是直线移动，而且还会发生高度的变化。因此我们有必要理解Root Motion的核心机制，当启动Root Motion后，我们计算动画中Transform的方式改变了，之前我们介绍动画的时候说，动画实际上就是对象及其子对象的一系列变换，动画的关键帧记录了对象的变换值，播放到这一帧的时候就会将对象的变换设置为记录的值，从而完成动画。</p>
<p>但是启用Root Motion后，动画之间将不再强制赋值，而是计算相对变换，用图形学中旋转、缩放、位移矩阵来解释，就是每次计算帧和帧之间的移动不再通过给这些矩阵赋值的方式，而是给物体的这些矩阵不断乘以一个相对位移矩阵，这个相对位移矩阵就是当前对象变换的情况，就像惯性一样。所以，勾选Root Motion后对象的变换就不会被重置，如果一个动画的开头记录了对象的初始位置，结尾记录了最后的位置，那么在这个动画播放一次之后不会将物体重置到开头的位置，而是乘以让对象不断移动的相对变换矩阵，因此对象将继续沿着动画指定的方向移动。</p>
<h2 id="Generic中的Root-Motion"><a href="#Generic中的Root-Motion" class="headerlink" title="Generic中的Root Motion"></a>Generic中的Root Motion</h2><p>在Generic的动画中，不像Hunmanoid那样有人形骨骼，如果我们打开一个Generic的动画，会发现它的Clip中没有对游戏对象的移动，那应该怎么让动画对游戏对象的移动生效呢？方法就是指定一个骨骼，将这个骨骼的所有变换应用到整个游戏对象上，因此同样需要指定Generic的Avatar，不过Generic的Avatart仅有一根骨骼，也只会进行一次绑定。</p>
<p>那么总结一下，Generic中的Root Motion就是将根骨骼的运动应用到整个游戏对象上。而在模型制作中，骨骼一般不使用模型上面的某一个骨骼，而是会单独制作一个骨骼来记录变换，应该把这个骨骼设置为Root Node。</p>
<p>有需要可以下载这个<a href="https://assetstore.unity.com/packages/3d/characters/animals/toon-fox-183005">狐狸资源</a>查看，它的Root Node就设置在模型的中间了。</p>
<p><img src="/2023/04/26/unity11/5.png" alt></p>
<h2 id="Hunmanoid中的Root-Motion"><a href="#Hunmanoid中的Root-Motion" class="headerlink" title="Hunmanoid中的Root Motion"></a>Hunmanoid中的Root Motion</h2><h3 id="动画的Root-Motion基础设置"><a href="#动画的Root-Motion基础设置" class="headerlink" title="动画的Root Motion基础设置"></a>动画的Root Motion基础设置</h3><p>下面我们才能真正理解动画中Root Motion选项的作用，点开一个动画的Inspector窗口，查看下面这些属性：</p>
<p><img src="/2023/04/26/unity11/6.png" alt></p>
<p>要说明的是，在Generic动画中这些root motion相关的设置中，Based Upon一项会有一个Root Node Oreintation，不同于Hunmanoid中的Body Oreintation，这里我们先当成一样的，马上我们会解释它们的差别。</p>
<h4 id="Root-Transform-Rotation"><a href="#Root-Transform-Rotation" class="headerlink" title="Root Transform Rotation"></a>Root Transform Rotation</h4><p>表示旋转的Root Motion设置，我们依次介绍。</p>
<ul>
<li>Bake Into Pose：将根骨骼节点的旋转当作普通动画处理，而不是Root Motion的一部分；如果我们不想让动画的根骨骼带动对象，就可以勾选，例如英雄联盟中角色跳舞的时候游戏对象停在原地；所以像前进、待机、后退这种动画我们希望自己能控制移动，就可以勾选，避免莫名其妙的旋转。后面的loop match表示动画在角度上的吻合度，如果动画带动的旋转很大，这个标记会是红色的，代表效果比较显著；绿色则是代表没有什么影响。</li>
<li>Based Upon：对象在动画开始时对准的方向，Body Orientation表示根骨骼的方向，但这个方向是Unity根据整个动画算出来的平均方向，所以不准确，我们可以使用下面的offset来矫正这个方向；Original则表示原本的朝向，也就是美术规定的方向，一般可以信任。</li>
</ul>
<h4 id="Root-Transform-Position-Y"><a href="#Root-Transform-Position-Y" class="headerlink" title="Root Transform Position(Y)"></a>Root Transform Position(Y)</h4><p>表示垂直方向上的设置：</p>
<ul>
<li>Bake Into Pose：和上面类似，勾选表示不要将根骨骼Y方向上的位移带动游戏对象；</li>
<li>Based Upon：将垂直方向上的哪个位置对齐到游戏对象的原点，选择Original表示美术选择的部分，通常也就是脚；选择Feet也是差不多；最后Center of Mass就是将质心放到原点；下面的Offset同样调整便宜；</li>
</ul>
<h4 id="Root-Transform-Position-XZ"><a href="#Root-Transform-Position-XZ" class="headerlink" title="Root Transform Position(XZ)"></a>Root Transform Position(XZ)</h4><p>表示水平方向上的设置：</p>
<ul>
<li>Bake Into Pose：和上面类似，勾选表示不要将根骨骼水平方向上的位移带动游戏对象；</li>
<li>Based Upon：将水平方向上的哪个位置对齐到游戏对象的原点，和Y方向上的完全一致，只不过是水平面上的。</li>
</ul>
<h2 id="机制和配置"><a href="#机制和配置" class="headerlink" title="机制和配置"></a>机制和配置</h2><p>不像Generic模型那样，Hunmanoid动画通常没有根骨骼，Unity会通过分析模型计算重心Center of Mass，也就是预览窗口中开启右上角坐标系图标的时候会显示的蓝色箭头：</p>
<p><img src="/2023/04/26/unity11/7.png" alt></p>
<p>这个Mass Center在脚本中通过animator.bodyPosition和animator.bodyRotation来访问坐标和方向，可以用OndrawGizmos方法在场景中画出来。然后Unity将这个重心在水平面上的投影作为根骨骼来对待，被称为Root Transform，通过animator.rootPosition和animator.rootRotation访问坐标和方向。</p>
<p>因此，如果角色的动画此时是歪斜的，root Transform也会跟着有变化，Unity会把root Transform的位移应用到游戏对象上，简单来说，可以将root Transform作为root motion的根骨骼。</p>
<p>那么通过这种方式，Unity将人形模型中可能不同的根节点转化为root Transform，能帮助在不同的骨骼结构上复用一个Root Motion动画。</p>
<p>最后关于Root Node Oreintation和Body Oreintation，其实前者就是根骨骼，后者因为没有根骨骼，所以就是root transform。</p>
<p>现在你明白我们之前动画的问题如何解决了，就是设置Root Motion选项，将水平移动的Root Motion动画的Y方向和Rotation勾选Bake Into Pose，调整Rotation的Based Upon为Original，这样角色就不会走歪路，或者走到地面中了。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(十二)-Root Motion和Character Controller</title>
    <url>/2023/04/27/unity12/</url>
    <content><![CDATA[<p>上期主要说了New Input System和Root Motion核心机制，这次我们将在Blend Tree中使用Root Motion，配合Character Controller组件和Cinemachine，可以制作一个角色的移动系统了。注意，这里并没有详细讲解如何制作，只包括这三个组件的介绍。可能后面会有专门的博客提供解决方案。</p>
<span id="more"></span>
<h1 id="Blend-Tree中使用Root-Motion"><a href="#Blend-Tree中使用Root-Motion" class="headerlink" title="Blend Tree中使用Root Motion"></a>Blend Tree中使用Root Motion</h1><p>现在我们重新给角色建立一个Blend Tree，然后还是添加三个动画：Idle，Walking，BackwardWalking。确保它们都正确建立了Avatar，并且都具有Root Motion，而且基础设置完成。然后我们使用下面的代码，其实就是将前面的代码简化了，移动交给root motion来完成，我们只负责状态机中Speed变量的赋值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Locomotion</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Animator animator;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> forwardSpeed = <span class="number">1.6f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> backwardSpeed = <span class="number">1.2f</span>;</span><br><span class="line">    <span class="built_in">float</span> targetSpeed;</span><br><span class="line">    <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    Vector3 movevalue;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentSpeed = Mathf.Lerp(targetSpeed, currentSpeed, <span class="number">0.9f</span>);</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;Speed&quot;</span>, currentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerMove</span>(<span class="params">InputAction.CallbackContext callbackContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录玩家输入</span></span><br><span class="line">        Vector2 movement = callbackContext.ReadValue&lt;Vector2&gt;();</span><br><span class="line">        targetSpeed = movement.y &gt; <span class="number">0</span> ? forwardSpeed * movement.y : backwardSpeed * movement.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个地方值得说明，在我们使用root motion的时候，移动的阈值不是我们确定的，因此需要使用Blend Tree中的阈值计算功能，它会根据动画来计算一个合适的阈值以供参考，下面我们打开Blend Tree的Inspector窗口：</p>
<p><img src="/2023/04/27/unity12/1.png" alt></p>
<p>阈值默认勾选Automate Thresholds，Unity会在最大值和最小值之间平均分布阈值；勾选以后，才能使用下面的选项。</p>
<p>点开Compute Thresholds，选项代表根据动画的变化来计算阈值，含义如下：</p>
<ul>
<li>Speed：下面三个变量组成的三维向量长度；</li>
<li>Velocity X：根据X轴上的速度(左右移动)；</li>
<li>Velocity Y：根据Y轴上的速度(垂直移动)；</li>
<li>Velocity Z：根据Z轴上的速度(前后移动)；</li>
<li>Angular Speed(Rad)：弧度制的角速度；</li>
<li>Angular Speed(Deg)：角度制的角速度；</li>
</ul>
<p>所以，我们这里选择的是Velocity Z，用动画前后移动的速度来计算阈值，就得到了上面的结果。此时运行游戏可以发现前进和后退的速度是不一致的，如果想要它们一致，我们只能调整某个动画的播放速度，因此Unity下面还提供了Adjust Time Scale选项，他有两个选项：</p>
<ul>
<li>Homogeneous Speed：计算出让所有列表中动画root motion速度一致时的播放速度。</li>
<li>Reset Time Scale：重置动画播放速度。</li>
</ul>
<p>注意，计算播放速度时会让待机动画的播放速度改变，因为待机动画没有位移，使得计算出来的速度非常大，我们把它的播放速度设置为1即可。如果你的动画没有root motion，那么也不必使用这个选项。</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>现在又回到前面的问题，如果动画播放速度为1，被关联的阈值就代表了角色播放这个动画时的移动速度。角色前进的速度是受限于阈值的，即使我们代码中的速度大于root motion的阈值，Unity也会将超过阈值的值限制。另外，就算我们代码中设置的速度即使是小于阈值的，也没有办法保证角色的移动速度就是这个值，因为混合树根据阈值进行混合的时候有可能会做非线性插值，所以导致代码中的这个速度完全无法控制实际的角色移动。</p>
<p>更重要的是，直接修改阈值可能会导致角色脚滑的情况，因为动画播放速度和实际移动速度不匹配。</p>
<p>那么解决方案就只有一个了，改变动画的播放速度，因为设置动画的播放速度不会受到阈值上限的影响，也能让角色快速移动的时候播放匹配速度的动画：</p>
<ul>
<li>Unity计算动画阈值；</li>
<li>播放速度=希望的速度阈值/计算阈值；</li>
<li>阈值=希望的速度阈值；</li>
</ul>
<p>这样以后原本动画的计算阈值是1.5，而我们希望的速度阈值是1，但是播放速度是1/1.5，所以在我们希望速度阈值下角色确实只有1的速度，而且动画播放速度也是小于1的；如果速度阈值达到了计算阈值1.5，那么播放速度就会变为1。因此这个方法可以做到移动速度和动画播放速度的同步，我们后面都可以这样进行阈值的设置。</p>
<p>当然，这个思路照样有bug，非线性插值会导致代码中速度和关联阈值不一致，所以当代码让关联阈值处于阈值最大值和最小值之间的时候，速度仍然是不可控的，不过这种不精确也是可以接受的。</p>
<p>此外，这个方法还是不通用，因为动画复用在不同的模型上，导致Unity计算出来的阈值也不同，高的角色就走得快，矮的角色就走得慢，使用同样的状态机和动画，明日香就比可莉走得快很多，所以原本root motion设定的速度就不再合适了。</p>
<p>所以综上所述，要让不同的人物使用root motion，最好为每个角色制作自己的状态机，单独设置速度。下面我们解决这两个问题。</p>
<h3 id="不同角色使用root-motion"><a href="#不同角色使用root-motion" class="headerlink" title="不同角色使用root motion"></a>不同角色使用root motion</h3><p>前面我们说过，root motion会计算物体的缩放值，一个物体越小，那么物体其他变换的程度也越小。但是从Transform组件上看，两个人物模型的缩放值都是1，其实在制作Avatar时，unity已经对模型进行了缩放映射，小的模型对标准的Avatar来说要放大，或者让Avatar变小，大的模型反之。这种差异就导致了root motion不同，小模型上的root motion随着Avatar的缩小也缩小了。</p>
<p>解决方法还是调整播放速度，将动画播放速度除以缩放值即可：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">animator.speed = animator.humanScale;</span><br></pre></td></tr></table></figure>
<p>此时腿短的角色就会跑得更快，最后两个角色移动速度就是一致的。如果我们又不想改变整个Animator中动画的播放速度，只改变当前混合树中的动画，此时就要用到Animation State的Multiplier属性了，把上面这个值传递给它就好了。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">animator.SetFloat(<span class="string">&quot;ScaleFactor&quot;</span>, <span class="number">1</span> / animator.humanScale)；</span><br></pre></td></tr></table></figure>
<p>注意，如果一个模型大小在导入Unity的时候不符合要求，应该在该模型的配置中解决，而不是使用Transform组件中的Scale属性来完成，这会导致不必要的计算。</p>
<p><img src="/2023/04/27/unity12/13.png" alt></p>
<h3 id="自主控制移动速度"><a href="#自主控制移动速度" class="headerlink" title="自主控制移动速度"></a>自主控制移动速度</h3><p>即使我们正确修改了播放速度来一定程度上修正移动速度，最后角色还是不会按照设想移动，因为角色的root motion不是匀速的！我们设置的阈值其实是root motion移动的平均值，在Clip的Inspector窗口可以看到Average Velocity，就是Unity计算的阈值。如果打开Clip中的Root属性，选择Curves查看，你会看到真正的的root motion：</p>
<p><img src="/2023/04/27/unity12/2.png" alt></p>
<p>你肯定已经觉得很不妙了，阈值也不是线性的，root motion本身也不是线性的，这意味着角色移动速度完全就是不可控的，即使玩家看不出来，但当我们必须使用其他游戏组件控制对象位移时也不能让root motion完全接管移动了，所以这么复杂而且不精确的东西还有必要使用？</p>
<p>是的，它确实没有必要使用了，对一般的移动来说使用root motion的确解决了脚底打滑的问题，但我们有更好的方案，root motion也并不是一无是处。</p>
<p>这里介绍的方法就是通过刚体配合动画，回想为什么会发生脚底打滑，动画上来说是播放速度和移动速度不匹配，物理上来说是因为没有摩擦力！所以我们得让物理引擎参与进来，给角色添加刚体，碰撞体，冻结刚体在X轴和Y轴上的旋转防止角色倒地，修改脚本代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Locomotion</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Animator animator;</span><br><span class="line">    Rigidbody rigidbody;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> forwardSpeed = <span class="number">1.6f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> backwardSpeed = <span class="number">1.2f</span>;</span><br><span class="line">    <span class="built_in">float</span> targetSpeed;</span><br><span class="line">    <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    Vector3 movevalue;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;ScaleFactor&quot;</span>, <span class="number">1</span> / animator.humanScale);</span><br><span class="line">        rigidbody = GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentSpeed = Mathf.Lerp(targetSpeed, currentSpeed, <span class="number">0.9f</span>);</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;Speed&quot;</span>, currentSpeed);</span><br><span class="line">        rigidbody.velocity = animator.velocity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerMove</span>(<span class="params">InputAction.CallbackContext callbackContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录玩家输入</span></span><br><span class="line">        Vector2 movement = callbackContext.ReadValue&lt;Vector2&gt;();</span><br><span class="line">        targetSpeed = movement.y &gt; <span class="number">0</span> ? forwardSpeed * movement.y : backwardSpeed * movement.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，现在我们让Move方法的调用放到OnAnimatorMove中而不是Update，并且接管了角色的移动，如果你回去查看Animator的Apply Root Motion选项，会发现此时它后面变成不可选的描述语句，显示Handled by Script。角色移动的方式就是使用刚体的速度属性，这里还是root motion的速度，但是添加了更多的物理模拟如摩擦力，当然还是不精确的速度，如果你希望的话可以直接将currentSpeed赋值给它，只不过可能会有一点点动画上的不同步。</p>
<p>然后将Animator组件的Update Mode修改为<strong>Animate Physics</strong>，这会让OnAnimatorMove方法中计算角色骨骼位移的Move方法和Fixed Update同步，而且其中动画的计算处于动画系统和Fixed Update计算之后，物理系统计算之前，具体可以看<a href="https://docs.unity3d.com/cn/2021.3/Manual/ExecutionOrder.html">这里</a>：</p>
<p><img src="/2023/04/27/unity12/3.png" alt></p>
<p>这样我们的动画就比较不错了，简单有效，因为物理模拟而更加真实。不过我们Rigidbody中的重力却出问题了，角色受到的重力加速度很小，这其实还是root motion的冲突，因为具有root motion的动画需要勾选Bake Into Pose，否则Y方向上的移动动画会和重力冲突，所以勾选即可。</p>
<h3 id="重力失效"><a href="#重力失效" class="headerlink" title="重力失效"></a>重力失效</h3><p>重新运行，你发现角色虽然下降了，但是怎么是匀速下降呢？重看上面的OhelnAnimatorMove方法，我们强调它在物理系统之前调用，也就是说，每次物理系统计算出一个合理的速度后，被我们的OnAnimatorMove中的Move方法重置了！</p>
<p>所以我们赋值速度的时候仅改变水平方向速度即可，Y方向的速度设置为rigidbody.y，这样重力的问题就解决啦。</p>
<p>这又导致另一个问题，如果角色水平方向受力了，这个问题不是又发生了吗？如果我想用root motion影响角色Y方向的运动该怎么办？因此，这样的移动方式也不是万能的，具体情况需要你自己权衡。到这里root motion就暂时结束了，下面我们才能正式开始制作移动系统，你也理解了为什么我们要花这么多偏度理解root motion，它是动画和移动的核心。</p>
<h1 id="移动控制器"><a href="#移动控制器" class="headerlink" title="移动控制器"></a>移动控制器</h1><p>前面我们一直在使用root motion来进行角色移动的控制，但是主要还是学习动画系统。为了方便后面开发，我们如果不需要对角色进行物理模拟(也就是不使用RigidBody组件)，可以直接使用Unity的Character Controller来处理简单的移动和碰撞。</p>
<p>确保角色身上没有碰撞体和刚体组件，添加Character Controller组件，各项属性含义如下：</p>
<p><img src="/2023/04/27/unity12/4.png" alt></p>
<ul>
<li>Slope Limit：角色能越过的斜坡角度；</li>
<li>Step Offset：角色能过跨越的台阶高度；</li>
<li>Skin Width：角色发生碰撞时碰撞方向上的最小间隔距离，设置为Radius的十分之一可以防止卡死；</li>
<li>Min Move Distance：最小移动距离，小于该距离的移动会被忽略；</li>
<li>Center：碰撞体中心；</li>
<li>Radius：碰撞体半径；</li>
<li>Height：碰撞体高度；</li>
</ul>
<p>可以看到这个控制器其实也能负责碰撞体的简单工作，接下来打开脚本，在OnAnimatorMove方法中启用移动方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CharacterController = GetComponent&lt;CharacterController&gt;();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//CharacterController.Move(animator.deltaPosition);</span></span><br><span class="line">       CharacterController.SimpleMove(animator.velocity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Move方法不具有重力，SimpleMove方法默认启用重力，传入对应参数就配置好控制器了。一般来说，如果使用这个控制器组件，重力需要自己手写。</p>
<h1 id="Cinemachine"><a href="#Cinemachine" class="headerlink" title="Cinemachine"></a>Cinemachine</h1><p>我们仍然使用前面提到的cinemachine制作摄像机。安装cinemachine包后，打开顶部菜单栏新建一个Virtual Camera，添加后可以发现，此时我们场景中的Main Camera多出一个禁用的红色图标，并且自动添加了Cinemachine Brain组件，这个组件和我们新建的虚拟相机一同管理摄像机运行。</p>
<p>绑定之后，Main Camera的某些属性已经无法修改了，而是要通过读取某个虚拟摄像机的数属性来更改。我们可以定义任意数量的虚拟摄像机，并且在它们之间切换。</p>
<h2 id="Cinemachine-Brain"><a href="#Cinemachine-Brain" class="headerlink" title="Cinemachine Brain"></a>Cinemachine Brain</h2><p><img src="/2023/04/27/unity12/5.png" alt></p>
<ul>
<li>Live Camera：读取哪一个虚拟摄像机；</li>
<li>Live Blend：转换到哪一个摄像机，当一个摄像机被禁用，这里会转到下一个启用的摄像机；</li>
<li>Show Debug Text：游戏窗口中显示Live Camera和Live Blend；</li>
<li>Show Camera Frustum：显示摄像机的视锥体；</li>
<li>Ignore Time Scale：相机行为是否受到时间缩放值影响；</li>
<li>World Up Override：当相机Y轴和世界坐标系Y轴夹角大于90°，相机重设方向使得该夹角小于90°；如果给这里添加了对象，那么Up方向就会采用这个物体的Y轴方向。</li>
<li>Update Method：指出相机同步的方法，Fixed Update表示同步物理引擎，Late Update表示同步画面绘制，Smart Upadte表示自动选择，Manual Update表示脚本控制；</li>
<li>Blend Update Method：指明两个虚拟相机之间的切换行为同步的方法，只能选Fixed Update和Late Update。</li>
<li>Default Blend：默认的相机切换模式。</li>
<li>Custom Blends：自定义不同相机的切换模式，点击Create Asset可以创建并添加切换模式；</li>
<li>Events：相机触发的事件；</li>
</ul>
<h2 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a>Virtual Machine</h2><p>在实际开发中，我们通常只修改Cinemachine Brain的配置，读取不同的Virtual Machine配置来实现相机的行为，因此原则上相机有几种行为就是用几个Virtual Machine。</p>
<p><img src="/2023/04/27/unity12/6.png" alt></p>
<ul>
<li>Status：状态，Live表示启用，Standby表示待机且运行，Disabled表示被禁用，点击后面的solo可以让相机立即启用；</li>
<li>Game Window Guides：游戏窗口中显示提示信息；</li>
<li>Save During Play：在Play状态下的修改会被保存；</li>
<li>Priority：优先级较高的摄像机会被启用；</li>
<li>Follow：跟随游戏对象；具体在Body中设置；</li>
<li>Look At：看向游戏对象；具体在Aim中设置；</li>
<li>Standy Update：待机时以什么频率执行刷新；Never表示不计算，Always表示和激活的相机一致；Round Robin表示轮盘赌计算不同的虚拟摄像机；</li>
<li>Lens：镜头设置，FOV，Near Clip和Far Clip都和图形学中一致。Dutch表示斜角镜头的角度。</li>
<li>Transition：相机切换的设置，Blend Hint表示相机切换的行为的物理特征，None表示线性切换，Spherical Position表示球面切换，Cylindrical Postion表示圆柱切换，Screen Space Aim When Target Differ表示当look at的对象不同时在屏幕空间之间切换；Inherit Position表示让虚拟相机移动到相机的位置；</li>
<li>Noise：添加晃动效果；</li>
<li>Extension：额外功能；</li>
</ul>
<p>下面我们进一步介绍Body和Aim两个属性的配置。</p>
<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p><img src="/2023/04/27/unity12/7.png" alt></p>
<p>Body控制摄像机的Position。当Body为Transposer时，表示摄像机会在固定的偏移上跟随游戏对象。偏移通过Follow Offset调整，XYZ的Damping是相机移动的阻尼系数。</p>
<p>而Binding Mode则是摄像机跟随使用的坐标系，有以下选项：</p>
<p><img src="/2023/04/27/unity12/8.png" alt></p>
<ul>
<li>Lock To Target On Assign：当目标被分配给Fllow，或者虚拟摄像机被激活的时候，根据Offset在对象本地坐标系下锁定相对位置，跟随对象；如果对象发生旋转、移动，再次触发Assign，相机位置就会重新根据Offset锁定。也就是世界坐标系改变，但是本地坐标系不变；</li>
</ul>
<p><img src="/2023/04/27/unity12/9.png" alt></p>
<ul>
<li>Lock To Target With World Up：这个比较复杂，飞机飞行有三个旋转轴，分别是偏航Yaw，俯仰Pitch，横滚Roll，可以看这篇<a href="https://blog.csdn.net/qq_38800089/article/details/108768388">博客</a>，该模式下摄像机坐标随对象的偏航Yaw轴旋转，而虚拟相机本身自然是不旋转的。该模式下使用Yaw Dampling可以调整旋转的阻尼；</li>
<li>Lock To Target No Roll：相机绕偏航Yaw和俯仰Pitch轴旋转，但不能绕横滚Roll旋转；同样使用Damping设置阻尼；</li>
<li>Lock To Target：此时绕三个轴都可以旋转，还可以选择使用四元数或欧拉角调整阻尼；</li>
<li>World Space：和Lock To Target On Assign类似，只不过在世界坐标系下进行，因此与世界坐标系的相对位置不变；</li>
<li>Simple Follow With World Up：相机不会绕任何一个轴旋转，并且在横向尽量不移动；</li>
</ul>
<p>暂时我们就介绍Transposer一个选项。</p>
<h3 id="Aim"><a href="#Aim" class="headerlink" title="Aim"></a>Aim</h3><p>Aim中调整摄像机的Rotation。</p>
<p>Aim有以下模式：</p>
<p><img src="/2023/04/27/unity12/11.png" alt></p>
<ul>
<li>Do nothing：不旋转；</li>
<li>Composer：标准的Aim模式，让相机看向Look At对象，而且该模式的各项属性和之前我们介绍的Game Window Guides有关。</li>
</ul>
<p><img src="/2023/04/27/unity12/12.png" alt></p>
<p><img src="/2023/04/27/unity12/10.png" alt></p>
<p>提示界面中，黄点代表要对准的目标。Tracked Object Offset是偏移量，调整它可以让相机追踪的对象发生偏移。Lookahead Time表示根据对象的移动速度推算一个偏移量，并施加在摄像机上。Lookahead Smoothing是平滑的速度预测偏移量，可以用来消除镜头抖动。Lookahead Ignore Y会忽略预测垂直方向上的移动。Damping还是阻尼。Screen X和Screen Y则是后面Dead Zone的中心位置。Dead Zone Width和Dead Zone Height则是宽高。Dead Zone是屏幕中的一块矩形，只要Target还在这个区域中，相机就不会发生转动，它在游戏视图中表现为一块透明区域。</p>
<p>而蓝色区域则是Soft Zone，Target落在这里面的时候相机会发生转动，让Target回到Dead Zone，宽高也就不解释了。Bias X和Bias Y则是Soft Zone距离中心的的偏移量。最外层的红色区域是黄点绝不会落入的区域。Center On Active表示相机被启用的时候会把对象放到正中央，不勾选则会放在最近的Dead Zone的边缘。</p>
<p>其余Aim选项我们依然暂时不做介绍。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(十三)-动画系统(三)</title>
    <url>/2023/04/30/unity13/</url>
    <content><![CDATA[<p>做好了角色控制器以后，是时候进一步填充游戏内容了，我们接下来还是学习动画，Animation Layer可以帮助我们在角色上播放不同的动画，让角色持有武器并移动的动作通过移动和握持两个动画来实现；更进一步的IK则会帮助角色适应不同地形。除了前面实现角色基本移动功能的状态机，root motion等，这两个功能都很有必要学习。</p>
<span id="more"></span>
<h1 id="Animation-Layer"><a href="#Animation-Layer" class="headerlink" title="Animation Layer"></a>Animation Layer</h1><p>使用Animation Layer可以管理不同身体部分的复杂状态机，骨骼蒙版就是来控制使用哪些骨骼的：</p>
<p><img src="/2023/04/30/unity13/1.png" alt></p>
<p>创建完成后我们选择手臂及其IK Goal，代表选择的是手臂、手掌和两个IK：</p>
<p><img src="/2023/04/30/unity13/2.png" alt></p>
<p>接着回到状态机中，将我们创建的这个Avatar Mask赋值给新建的Arms Layer：</p>
<p><img src="/2023/04/30/unity13/3.png" alt></p>
<p>可以看到出现了M字样作为标记，表示这个Layer使用了Avatar Mask。在Layer的设置中，还有以下几项：</p>
<ul>
<li>Weight：当前Layer影响动画的权重；</li>
<li>Mask：使用的Avatar Mask；</li>
<li>Blending：和上层动画的混合方式，Override为取代，Additive为正常混合；</li>
<li>Sync：选择是否和其他层级同步；</li>
<li>IK Pass：是否使用IK；</li>
</ul>
<p>然后我们找到一个持枪动画，按照之前讲解的方法修改必要的地方，添加进状态机中的Arms层，用一个bool变量来控制当前是否持枪，得到效果就是角色在bool变量为真时双手抬起，并且可以行走，不会影响手部的动作。</p>
<p><img src="/2023/04/30/unity13/4.png" alt></p>
<h2 id="Additive模式的使用"><a href="#Additive模式的使用" class="headerlink" title="Additive模式的使用"></a>Additive模式的使用</h2><p>上面我们用override覆盖了原本的手臂动画，现在我们使用Additive模式为角色添加疲劳感。找到一个喘气的动画，添加到新建的状态机层中即可。接着打开Layer的设置，创建一个只影响头部和驱赶的Avatar Mask给这个层：</p>
<p><img src="/2023/04/30/unity13/5.png" alt></p>
<p>这样一来，层中只有一个状态，也就是说只要Weight变大，那么这个层的状态就会附加到原本的状态上做一个混合，达到角色喘气、疲劳的感觉。</p>
<p><img src="/2023/04/30/unity13/6.png" alt></p>
<p>我们下面修改脚本，用脚本来控制角色的疲劳值，将代码修改成下面这样：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QinController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> RotateSpeed = <span class="number">1000f</span>;</span><br><span class="line"></span><br><span class="line">    Transform Playertransform;</span><br><span class="line">    Animator animator;</span><br><span class="line">    Vector2 playerInput;</span><br><span class="line">    <span class="built_in">bool</span> isRunning;</span><br><span class="line">    Vector3 playermovement;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> currentSpeed;</span><br><span class="line">    <span class="built_in">float</span> targetSpeed;</span><br><span class="line">    <span class="built_in">float</span> WalkingSpeed = <span class="number">1.5f</span>;</span><br><span class="line">    <span class="built_in">float</span> RunSpeed = <span class="number">3.3f</span>;</span><br><span class="line">    <span class="built_in">bool</span> armedRifle = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">float</span> currentFatigue;</span><br><span class="line">    <span class="built_in">float</span> minFatigue = <span class="number">0f</span>;</span><br><span class="line">    <span class="built_in">float</span> maxFatigue = <span class="number">10f</span>;</span><br><span class="line">    <span class="built_in">int</span> FatigueLayerIndex;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        Playertransform = GetComponent&lt;Transform&gt;();</span><br><span class="line">        FatigueLayerIndex = animator.GetLayerIndex(<span class="string">&quot;Fatigue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerRotate();</span><br><span class="line">        PlayerMove();</span><br><span class="line">        CaculateFatigue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPlayerMoveInput</span>(<span class="params">InputAction.CallbackContext callbackContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        playerInput = callbackContext.ReadValue&lt;Vector2&gt;();</span><br><span class="line">        Debug.Log(playerInput);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPlayerRunInput</span>(<span class="params">InputAction.CallbackContext callbackContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        isRunning = callbackContext.ReadValue&lt;<span class="built_in">float</span>&gt;() &gt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        Debug.Log(isRunning);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlayerRotate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (playerInput.Equals(Vector2.zero)) <span class="keyword">return</span>;</span><br><span class="line">        playermovement.x = playerInput.x;</span><br><span class="line">        playermovement.z = playerInput.y;</span><br><span class="line"></span><br><span class="line">        Quaternion targetRotation = Quaternion.LookRotation(playermovement, Vector3.up);</span><br><span class="line">        Playertransform.rotation = Quaternion.RotateTowards(Playertransform.rotation, targetRotation, RotateSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlayerMove</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        targetSpeed = isRunning ? RunSpeed : WalkingSpeed;</span><br><span class="line">        targetSpeed *= playerInput.magnitude;</span><br><span class="line">        currentSpeed = Mathf.Lerp(currentSpeed, targetSpeed, <span class="number">0.5f</span>);</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;VerticalSpeed&quot;</span>, currentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetArmedRifleInput</span>(<span class="params">InputAction.CallbackContext callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(callback.ReadValue&lt;<span class="built_in">float</span>&gt;() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            armedRifle = !armedRifle;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;Rifle&quot;</span>, armedRifle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CaculateFatigue</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentSpeed &lt; <span class="number">1f</span> &amp;&amp; currentFatigue &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentFatigue -= Time.deltaTime;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentSpeed &gt; <span class="number">2f</span> &amp;&amp; currentFatigue &lt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentFatigue += Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        currentFatigue = Mathf.Clamp(currentFatigue, minFatigue, maxFatigue);</span><br><span class="line">        animator.SetLayerWeight(FatigueLayerIndex, currentFatigue / <span class="number">10f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进入游戏，可以看到状态机中Fatigue层的weight随着角色移动而更改，这就是Additive模式的基本用法了。</p>
<p>了解之后我们不妨进一步思考原理，之前说动画其实就是对游戏对象的一系列的变换，那么Additive模式含义就是，让当前层动画的变化施加到游戏对象上，让游戏对象乘以变换矩阵。那么问题来了，如果一个动画并没有包含任何变换，或者说Curves，例如持枪动画中，角色的双手从头到尾是静止的，因此将持枪动画的层级修改为Additive时，角色的动作就不会被这个动画影响，因为乘以的变换矩阵为单位矩阵，我们才只能使用override模式让变换强制执行，一如root motion。</p>
<h2 id="同步的使用"><a href="#同步的使用" class="headerlink" title="同步的使用"></a>同步的使用</h2><p>Sync是Unity提供的同步功能，在开发中有时我们希望能使用角色原来的状态机，但是播放和原来不同的动画，例如角色受伤以后的动画，那么就可以使用Sync进行同步，所谓同步其实仅仅是同步动画状态和状态转换关系，因此对于其中播放什么动画、Blend Tree的内容都不会同步，这样就可以重新添加了。</p>
<p>值得说明的是，如果两个动画状态通过Exit time进行转换，并且这两个动画不一样长，原本的动画可能播放2s后转换，结果现在需要同步的动画只有1s，Unity就会将1s的动画同步缩放到2s，从而保证转换状态不变。</p>
<p><img src="/2023/04/30/unity13/7.png" alt></p>
<p>但是如果希望用1s的动画作为基准，将基准层的2s动画缩放到1s呢？这就是使用Timing选项的作用，注意只有当使用override模式时Timing才是可选的。Timing会根据两个层的权重来对动画时间的缩放进行计算，设置当前层的权重为1，那么自然2s的动画就会被缩小到1s了。</p>
<h2 id="Layer优先级"><a href="#Layer优先级" class="headerlink" title="Layer优先级"></a>Layer优先级</h2><p>你可能发现，在添加了injured层之后角色的Fatigue层和Amrs层就失效了，因为在Unity种位于下面的Layer拥有更高的优先级，因此injured代替了上层的所有动画，为了不妨碍Fatigue生效，我们把injured层拖到这两个层上面即可：</p>
<p><img src="/2023/04/30/unity13/8.png" alt></p>
<p>通过合理使用Layer，可以制作精美的角色动画，包括面部表情，这是一个非常强大的功能。</p>
<h1 id="Inverse-kinematic-Goal"><a href="#Inverse-kinematic-Goal" class="headerlink" title="Inverse kinematic Goal"></a>Inverse kinematic Goal</h1><p>为了让角色持枪的动作更贴合模型，我们可以用IK Goal来实现，前面我们已经使用过了。在勾选Layer中的IK Pass后，代表你开启了IK计算，系统将会每帧回调OnAnimatorIK方法。</p>
<p><img src="/2023/04/30/unity13/9.png" alt></p>
<p>根据反向动力学，Unity会计算将目标骨骼移动到对应位置后角色身体其他部分的变化，因此可以用IK Goal来移动角色四肢，这里持枪姿态就是将角色的双手移动到枪身上面。但是直接在代码中移动IK Goal又看不见，我们很难用调整代码的方式来调整IK Goal位置，因此通常的做法是建立一个空对象代表IK Goal，然后运行后调整这个空对象的位置，就能看到角色四肢的移动效果了。</p>
<p>我们这里可以给角色的左右手分别创建一个枪支的空子对象，然后在代码中让Avatar左右手的位置、朝向都和空对象统一，接着就可以调整空对象的位置，进而调整手的位置了。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorIK</span>(<span class="params"><span class="built_in">int</span> layerIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    animator.SetIKPosition(AvatarIKGoal.RightHand, righthandposition.position);</span><br><span class="line">    animator.SetIKRotation(AvatarIKGoal.RightHand, righthandposition.rotation);</span><br><span class="line"></span><br><span class="line">    animator.SetIKPosition(AvatarIKGoal.LeftHand, lefthandposition.position);</span><br><span class="line">    animator.SetIKRotation(AvatarIKGoal.LeftHand, lefthandposition.rotation);</span><br><span class="line"></span><br><span class="line">    animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, <span class="number">1f</span>);</span><br><span class="line">    animator.SetIKPositionWeight(AvatarIKGoal.RightHand, <span class="number">1f</span>);</span><br><span class="line">    animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, <span class="number">1f</span>);</span><br><span class="line">    animator.SetIKRotationWeight(AvatarIKGoal.RightHand, <span class="number">1f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何在游戏运行的时候保存属性？点击Transform组件右上角的三个点，展开后可以看到Copy Component选项，点击后结束游戏，再打开选择Paste Component Values即可粘贴调整好的值。</p>
<p>另外还有一个重要的地方，由于我们计算IK时对整个骨骼都会有影响，导致设置IK Goal后可能会发现右手位置对了，左手却偏移了，这就是左手的IK Goal受到了右手IK计算的影响。IK效果并不会立即被体现出来，导致一方对另一方绑定位置的影响具有滞后性，导致后绑定的一方绑定位置出错，也就是左手。</p>
<p>因此我们可以创建一个新的Layer，勾选IK Pass用于逻辑运行，并采用形参LayerIndex作为逻辑分支，在不同的层逻辑中进行不同的处理，就可以解决问题了。</p>
<p>我们这里可以直接开启两个层的IK Pass，左右手也不会发生偏移，因为每更新帧中对每个层调用一次OnAnimatorIK和WriteTransform，也就是说给两个层都执行了相同的内容，第一次调用时左手绑定Goal的代码在右手后面，导致绑定出错，第二次调用以后右手绑定位置已经ok了，所以左手重新调整到正确的位置了。</p>
<h1 id="Animation-Rigging"><a href="#Animation-Rigging" class="headerlink" title="Animation Rigging"></a>Animation Rigging</h1><p>Animation Rigging是unity推出的简化动画系统的框架，可以使用一系列的组件将骨骼摆动到正确的位置上。我们这里使用最简单的Two Bone Contrains来进行手部持枪动画的绑定。</p>
<p>首先在Packge Manager中导入Animation Rigging，然后看到顶部菜单栏多出来一个Animation Rigging的选项。然后我们可以先使用Bone Renderer Setup来给角色添加骨骼渲染，之后就可以通过点击场景的方式来选择需要哪个骨骼：</p>
<p><img src="/2023/04/30/unity13/10.png" alt></p>
<p>然后就是rig的使用，rig就相当于一个变换骨骼的操作，一个角色可以拥有多个rig，它们统一被Rig Builder组件管理；每个rig下也可以有多个Constrains，相当于更详细的骨骼变换操作描述，那么我们要使用rig将手部放到合适的位置，就不用像之前那样通过代码慢慢调整。</p>
<p>先给角色添加Rig Builder组件，它自动给角色创建一个名为Rig1的子对象(Rig Builder中也可以点击加号添加新的Rig)，将其重命名为Two Hands Rig，可以看到这个对象已经添加了Rig组件，管理两个手的骨骼变换；再给Rig然后添加两个子对象Right Hand Constrain，Left Hand Constrain，这两个约束详细描述了游戏中角色的手应该如何摆放，就像IK Goal一样，所以我们还是建立空子对象作为Target。</p>
<p>不过这里引入了Animation Rigging，有比较快的方法，原来播放的持枪动画基本OK，所以我们给Chest建立空的子对象作为右手的Target，开始游戏并让角色持枪，然后同时选中此时角色大概正确的手腕骨骼，和我们的target，点击顶部Animation Rigging中的Align Position，就可以让Target的位移同此时手腕相同，方便了我们后面调整。</p>
<p><img src="/2023/04/30/unity13/11.png" alt></p>
<p>接着给两个Constrain添加Two Bone Constrains组件：</p>
<p><img src="/2023/04/30/unity13/12.png" alt></p>
<p>Two Bone Constrains实际上就是通过旋转root、mid两根骨骼，把tip这个骨骼放到target位置上。Maintain Target Offset代表是否保持tip和target之间的位移差。那么手腕Wrist的父节点分别是elbow和arm骨骼，所以就将它们拖进去，下面Target则是刚才对齐的子对象，配置好之后就可以开始游戏了，此时看到右手已经绑定在位置上了。接着你要做的就是调整Target的位置，让右手摆放到合适的位置。</p>
<p>用相同的办法调整左手位置，完成后你应该分别给左右手创建了一个对其的空游戏对象。</p>
<p>接着完成对Aiming Idle动画的调整，完成后一共有四个空游戏对象了。</p>
<p>完成后我们得到了调整后的持枪Idle和瞄准Idle，为了使用这两个动画，我们得让它们切换的同时，Constrains中的Target也一同切换，这当然可以通过代码实现，但是我们有更简单的方法，依然是动画的本质。</p>
<p><img src="/2023/04/30/unity13/13.png" alt></p>
<p>众所周知，动画通过对一层一层游戏子对象的名称来辨别并施加变换，此时我们设置了一个Target子对象作为手移动的对象，那么它自然也可以通过动画访问到，因此我们完全可以添加一个Animation Clip，让这个Clip来对该Target进行变换，从而让这个Target在持枪Idle的时候就保持持枪时Target的值，在瞄准Idle的时候就保持瞄准时Target的值，也就是说左右手各使用一个Target即可，就没必要通过代码进行切换了。</p>
<p>那么打开角色的Animation窗口，新建一个Clip，存入持枪Idle时调整好的左右手Target的Rotation和Position；再新建另一个Clip，这时由于已经有了持枪Idle时Target的位置，所以把瞄准Idle时Target的Transform组件值拷贝到持枪Idle时Target的Transform组件，再次添加持枪Idle时左右手Target的Rotation和Position。</p>
<p><img src="/2023/04/30/unity13/14.png" alt></p>
<p>也就是说，我们两个动画Clip里存的就是对左手Target和右手Target的变换，并且它们具有不同的值，接下来应该如何使用呢？</p>
<p>我们知道，动画Clip会让对应的游戏对象进行变换，这里的变换则是对Target的旋转、位移变换，规定播放该Clip时让Target旋转、移动到固定的位置；又因为我们的Constraints约束了手的位置，所以手就会被带动到Target的位置。我们只需要让状态机中条件发生转换的时候，播放对应动画并override到下层动画上即可。</p>
<p><img src="/2023/04/30/unity13/15.png" alt></p>
<p>所以我们在最下面新建一个Layer层，当isAiming为true的时候播放瞄准Idle的动画Clip，false的时候播放持枪Idle的动画Clip，就实现了Constrains中Target的改变。多余的那个Target就可以删除了。这样我们瞄准动画就修改好了。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(十四)-Animation系统(四)</title>
    <url>/2023/05/04/unity14/</url>
    <content><![CDATA[<p>这次我们来学习动画片段的三个基本操作，分割，事件，修改Curves。虽然我们不是动画师，但是有必要对Unity的动画系统有全面的了解。</p>
<span id="more"></span>
<h1 id="分割片段"><a href="#分割片段" class="headerlink" title="分割片段"></a>分割片段</h1><p>在游戏开发中，一个动画片段可能包含多个逻辑，例如拔枪和收枪动画常常会放在一起，我们实际使用的时候就需要将整个动画分割成两份。</p>
<p><img src="/2023/05/04/unity14/1.png" alt></p>
<p>在动画的FBX文件属性中，Animation下的Clips一栏显示了当前FBX文件中存在的Clips(上面是maximo动画Grab and Put Bakc Rifle分割后的列表)，右侧Start代表该Clip开始的帧数，End代表结束的帧数。点击下面的+号就可以添加Clip。</p>
<p><img src="/2023/05/04/unity14/2.png" alt></p>
<p>再往下就是调整Clip起始帧的地方了，我们之前在这里调整root motion的设置，右边的信号灯起始表示的是从当前Cllip起始帧到结束帧的各种差异，含义和之前介绍的一样。上面Length是Clip持续的时间，30FPS代表每秒三十帧，下面就是时间轴，拖动蓝色箭头就可以修改Clip的长度、位置，而Start和End还是表示起始和结束的帧数。其余设置就不说了，前面root motion的博客介绍过。</p>
<p>那么现在我们要将这个动画分割成拔枪和收枪两部分，于是点击加号添加，调整好时间以后点击下方的Apply，就得到了开始图中的两个Clip片段。</p>
<p>在状态机中测试：</p>
<p><img src="/2023/05/04/unity14/3.png" alt></p>
<p>记得禁用角色的rig约束，可以看到动画已经正确播放了。我们后面再进一步调整动画。</p>
<h1 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h1><p>在Unity中，有时我们需要动画的播放和一些事件关联，如角色播放技能动画时播放音效，攻击动作达到指定位置时触发伤害等，这就是Animation Event的作用。那么这里的例子就是，让角色播放收枪动画到一定程度时，将步枪绑定到角色背后；播放拔枪动画到一定程度时，将步枪绑定到角色手上。</p>
<p>作为例子来说，这里处理方式就采用简单的激活，弄一个枪模型挂在角色背后，当角色伸手拿枪的时候，把背上的枪禁用，然后激活手上的枪；放枪的时候就反过来激活：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PutGrabRifle</span>(<span class="params"><span class="built_in">int</span> isOnBack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isOnBack == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rifleOnBack.SetActive(<span class="literal">true</span>);</span><br><span class="line">        rifleInHand.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isOnBack == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rifleOnBack.SetActive(<span class="literal">false</span>);</span><br><span class="line">        rifleInHand.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们需要使用动画事件来让这个事件函数在播放到一定帧的时候被调用。点开FBX文件下面的Events：</p>
<p><img src="/2023/05/04/unity14/4.png" alt></p>
<p>有加号的按钮就是添加事件函数的按钮，添加以后时间轴上会多出一个白条，表示该处存在事件函数。动画事件的逻辑是，填写Function为事件函数的名称后，当动画播放到该帧，Unity会让Animator组件发出一个Message，然后根据Function名称，调用该游戏对象组件中与Function名称相同的方法，无论有多少个同名方法。</p>
<p>注意，Events中的时间轴不能被拖动，只能被选中，只有在预览窗口中才能拖动时间轴，达到想要的位置。我们这里选择好时间轴，添加方法名称，下面则是传入的参数，只允许传入这四种参数，所以我们传入一个Int值1/0，就完成了这里的事件函数。</p>
<p>然后播放动画，此时收枪拔枪动画已经正常了，只不过位置有些不对。</p>
<h1 id="添加Curve"><a href="#添加Curve" class="headerlink" title="添加Curve"></a>添加Curve</h1><p>在开发中的很多时候，我们需要根据动画播放的进度来调整角色的某些属性，例如滑铲等动画中角色的碰撞体需要修改大小，一种方案是编写脚本来跟踪动画播放进度，不过我们可以直接将修改的属性写入动画文件，也就是Curve，从而方便开发。</p>
<p>刚才添加了收枪拔枪的动画之后，再打开rig，发现角色的IK动画不正常了，因为rig权重是100，导致角色一开始进入拔枪动画时手就被固定在Target上。所以我们需要让角色的rig权重随着动画播放而慢慢变化，需要IK的时候就升高权重，不需要就降低，才能达到平滑的过渡效果。另外，角色的手也应该处于枪把手的位置，这也需要调整。</p>
<p>所以我们要做的事情是：</p>
<ul>
<li>添加一个背上的Target，这个背上Target和背上的枪的相对位置，应该和手上的枪和手上的Target的相对位置一致；</li>
<li>将背上Target的Transform按照前面一篇博客介绍的方法做成一个New Clip，就可以删除这个背上的Target了；</li>
<li>使用Animation的Curve功能调整rig的权重；</li>
<li>修改状态机</li>
</ul>
<p>为了保持相对位置一致，可以把原来的的Target拖动到手上的枪对象下，这样Target就保存了当前相对于父对象枪的相对位置，那么新的Target可以创建到背上的枪对象下面，拷贝这个相对位置即可得到正确的Target位置。</p>
<p>重点说后面如何使用曲线，之前说Curves是动画保存变换的根本形式，我们自然可以通过类似的形式来添加其他变量的Curves，那么这里要修改的就是左右手的Rig权重，我们打开动画文件的Animation栏，找到下面的Curves并点开，点击加号添加一条曲线。</p>
<p><img src="/2023/05/04/unity14/6.png" alt></p>
<p>你可以拖动预览窗口的时间轴选择帧，然后点击菱形按钮添加关键帧并命名，注意这个名字就应该是稍后我们添加在Animator Controller中的Parameter的值，Unity会根据这个名字去匹配Parameter中的变量，然后对变量做对应曲线的修改。</p>
<p>这里我们要修改的是拔枪的动画，为了让角色拔枪的时候动作平滑，那么对于拔枪的右手，就要让它伸到背后枪把手的位置，也就是背上的Target。当动画刚开始播放的时候Weight肯定为0，快要拿到枪的时候让Weight开始上升，角色右手向枪把靠近，拿到枪的时候Weight肯定为1，达到Target；之后让Weight下降，角色要把手拿开，等拔枪到角色身前时，要进入持枪Idle的动画，右手肯定不在背上了，Weight为0。这就是上图中Right Hand Weight三个关键帧的含义。</p>
<p>对于左手，只有在拔出枪后，才会接住枪，这里接住枪的位置和持枪Idle中的约束一致，因此我们直接让左手快要接住枪的时候Weight上升，拿到枪的时候Weight为1，之后保持这个值即可。</p>
<p>现在你大概明白Weight和Target在控制什么了，其实就是角色肢体靠近某个位置的程度，拔枪的时候需要角色将右手放到枪把上，左手等拔出来之后放到枪托上，通过这种方式我们可以控制角色肢体进行精确的抓取操作。</p>
<p>之后我们要做的，就是从Animator中获取这个Curve的值，然后赋值给Constraint的Weight即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TwoBoneIKConstraint rightHandConstraint;</span><br><span class="line"><span class="keyword">public</span> TwoBoneIKConstraint leftHandConstraint;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetTwoHandsWeight</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    rightHandConstraint.weight = animator.GetFloat(<span class="string">&quot;Right Hand Weight&quot;</span>);</span><br><span class="line">    leftHandConstraint.weight = animator.GetFloat(<span class="string">&quot;Left Hand Weight&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，你也许注意到另一个问题，Right Hand Weight后半部分保持Weight为0，通过上面的代码，这意味着即使拔枪动画完成了，角色的右手约束仍然为0，此时Target虽然已经变成我们之前调整的持枪Idle，但是约束并不会被应用。所以我们用了这种方式后，就得为其他需要的Clip一并添加曲线，保持这个Weight的正常。</p>
<p>因此我们找到持枪Idle的动画，添加两条全为1的Curve，名称仍然是和上面图中一致。对于瞄准Idle的动画同样要添加。这样以后我们动作才正式调整完成。</p>
<p>最后我们只需要调整下状态机，那么这部分动画就制作好了。之前我们设置的移动、瞄准等状态机都不需要修改，现在只是要使用我们刚刚制作的新的Target动画Clip来调整手臂的IK，所以我们为了方便管理，我们可以使用同步机制来同步Arms层的转换，将之前控制Target转换的层和Arms同步，并且勾上Timing，保证有Exit Time的动画时间一致。然后将不同状态对应的Target动画放进去，其余都不需要调整。</p>
<p>此时运行游戏，可以看到人物的收枪、拔枪、瞄准都比较精确了。</p>
<h1 id="2D-Blend-Tree原理"><a href="#2D-Blend-Tree原理" class="headerlink" title="2D Blend Tree原理"></a>2D Blend Tree原理</h1><p>之前我们虽然使用了2D混合树，但是并不清楚一些细节和原理。现在我们制作的角色在瞄准的时候虽然能正常移动，但是显然枪口是随着人物移动而移动的，这在射击游戏中显然不对，我们希望的是瞄准时角色的移动不影响瞄准方向，所以需要另外的动画片段才能实现这个移动。</p>
<h2 id="2D-Simple-Directional"><a href="#2D-Simple-Directional" class="headerlink" title="2D Simple Directional"></a>2D Simple Directional</h2><p>我们之前下载的动画包中已经有了八个方向的瞄准移动动画了，使用2DBlend Tree可以让角色动画在它们之间混合，向左后方移动的角色动画枪口仍然是朝正前方的。那么我们修改瞄准移动的Blend Tree为2D Simple Directional，然后依然使用Unity自动计算它们在Blend Tree中的位置：</p>
<p><img src="/2023/05/04/unity14/7.png" alt></p>
<p>点击Compute Positions，Pos X根据X方向的速度计算，Pos Y根据Z方向的速度计算，就得到上面的效果了，可以看到这几个动画片段都被分配到正确位置上。</p>
<p>下面的Adjust Time Scale则是用于调整动画播放速度，只有重置和同步两个选项，前者不用说了，同步则是计算每个动画的平均播放速度(也就是动画文件中的速度)，然后调节播放速度，让动画的平均速度一致。</p>
<p>下面我们重点说明Unity如何给混合树进行混合的，如果坐标原点存在动画，如上图，那么此时Unity会根据红点的位置连线成向量n，然后再连线原点和其他动画，找到顺时针和逆时针距离n夹角最小的两个动画，这样连上原点就有三个点了，它们连成一个三角形，红点作为重心，坐标均已知，因此可以用来计算三个点的权重，作为动画播放的权重。</p>
<p>如果原点不存在动画，做法依然不变，不同的是最后将原点计算的权重平均给其他所有动画，无论其他动画在什么位置。因此，如果原点不存在动画，那么当红点不在重心的时候所有动画都会被分配一定权重，来自原点。</p>
<p>因此，2D Simple Directional模式下动画混合计算比较快速，但是由于采用同原点连线的方式进行计算权重，导致不能让同一个方向上存在两个动画，而原点的某个180度方向内也不允许一个动画都不存在，否则红点在该区域内也不能匹配到三角形。当不需要在一个方向上混合多个动画时，应该首选这个模式。</p>
<h2 id="2D-Freedom-Cartesian"><a href="#2D-Freedom-Cartesian" class="headerlink" title="2D Freedom Cartesian"></a>2D Freedom Cartesian</h2><p>下面我们规范名称，进一步了解这个2D混合树机制。我们把动画称为Example Motion，红点蓝点所在的空间称为Parameter Space，红点则是Sample Point，蓝点是Example Point。</p>
<p>现在我们用$P$表示Sample Point，给定两个Example Point为$P_i, P_j$，定义$i$对$P$的影响力为$h_i(p)=min(1-\frac{\overrightarrow{P_iP} \cdot \overrightarrow{P_iP_j}}{|| \overrightarrow{P_iP_j} ||})$。</p>
<p>其物理意义是，遍历所有存在的$P_j$，向量$\overrightarrow{P_iP}$在向量$\overrightarrow{P_iP_j}$方向上的投影长度和$\overrightarrow{P_iP_j}$长度的比值，取得其中的最小值。这个比值衡量了$P_i$和$P$之间的远近，当比值越大，说明Sample Point距离Example Point越远；比值越小，说明Sample Point距离Example Point越近。将这个比值取反并归一化，就得到我们定义的影响力了。</p>
<p>如果再将这个影响力归一化到所有点上，也就是除以所有点影响力之和，就得到了每个点的权重。</p>
<p>这种混合计算方法就是2D Freedom Cartesian的分配原理，称为Gradient Band Interpolation，是由Unity的开发人员提出的，在笛卡尔坐标系下进行混合计算。<a href="https://www.shadertoy.com/view/XlKXWR">ShaderToy</a>上还有人复现了该算法。</p>
<h2 id="2D-Freedom-Directional"><a href="#2D-Freedom-Directional" class="headerlink" title="2D Freedom Directional"></a>2D Freedom Directional</h2><p>Cartesian使用的算法会导致一个问题，我们开发中有可能一个方向上角色需要播放走和跑的动画，那么当两个方向都需要走和跑的时候，即使我们的Sample Point达到边界，此时因为走路对应的Example Point计算出的影响力参考的是跑步动画的点，那么走路的点的影响力并不为0。我们当然希望这时走路的点权重为0。</p>
<p><img src="/2023/05/04/unity14/8.png" alt></p>
<p>因此，2D Freedom Directional使用了一个加强的Gradient Band Interpolation算法，在极坐标下进行计算。</p>
<p>我们根据论文补充一点数学定义(并不是普遍做法)，在笛卡尔坐标系中，向量被定义为两个点坐标的差，现已知两个点的坐标，极坐标下两个点的向量可以表示为：</p>
<p><img src="/2023/05/04/unity14/9.png" alt></p>
<p>其中$P_i$和$P_j$分别是两个二维坐标。之所以要除以两个坐标的模的平均，是为了保证单位大小不变。α是先验的权重，用来调整极坐标中半径和角度的重要性。</p>
<p>除此外，计算方法完全一致。但是由于在极坐标下进行了计算，最后呈现的效果也是不一样的。该算法的时间复杂度达到了O(n^2)。具体的计算细节我们不再展开。</p>
<p>只需要知道，采用这种方法以后，混合计算就比较精确了。</p>
<p>到这里我们的动画系统就正式介绍完了。由于Animation系统Bug很多，现在很多项目都启用了该系统，不过作为个人来说可以学习使用。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(十五)-使用Cinemachine制作俯视角/第三人称控制器</title>
    <url>/2023/05/07/unity15/</url>
    <content><![CDATA[<p>在前面的博客中我们介绍过一次Cinemachine的基本功能，包括，CinemachineBrain和Virtual的使用，结合动画系统，我们这里练习两种控制方式的制作。俯视角的相机常用在2.5D的游戏中；第三人称相机就不用说了，很主流的视角。注意，我们介绍中的解决方案可能不是十分完美，可以简单了解如何实现相机和动画、移动的统一。</p>
<span id="more"></span>
<h1 id="俯视角射击游戏相机制作"><a href="#俯视角射击游戏相机制作" class="headerlink" title="俯视角射击游戏相机制作"></a>俯视角射击游戏相机制作</h1><p>一般2.5D俯视角的话只需固定相机位置，然后不跟随角色旋转即可，也就是虚拟摄像机中的Aim可以选择Do Nothing，而Body选择Transposer，并设置Binding Mode为Lock To Target On Assign或者World Space，跟随目标移动即可。具体含义可到之前的博客中查找。</p>
<p>我们后面会进一步优化这个简单的摄像机，不过现在我们先关注如何控制角色动画，因为在俯视角射击游戏中，角色除了走动以外，瞄准方向要随鼠标位置移动。因此我们要处理非瞄准模式下的移动和瞄准模式下的移动，它们可以使用混合树完成。</p>
<h2 id="Normal状态下的移动动画"><a href="#Normal状态下的移动动画" class="headerlink" title="Normal状态下的移动动画"></a>Normal状态下的移动动画</h2><p>新建一个Animator Controller，添加两个混合树，一个命名为Aiming，一个命名为Normal，我们先设置Normal的动画。我们使用的素材是Unity之前发布的标准包动作，使用Maximo的其他动画也可以。这个动画包含有行走、转弯、奔跑、待机在内的共15个动画，列表如下：<br><img src="/2023/05/07/unity15/1.png" alt></p>
<p>可以看到这种包含转弯动作的动画一般没有向后走的Clip，也就是说如果角色向后走了，也应该让角色旋转并再向前走，这样显然比较符合实际。那么混合树变量的阈值设置自然也不能像我们之前那样使用x和z方向的位移了，因为角色转弯动画的root motion并没有大幅度的移动，而是旋转比较多。因此如果我们直接使用xz的位移来计算阈值，那么转弯动画的x位移就比较小，会导致很多Clip排布紧密，几乎在一条直线上，导致动画系统混合Clip的时候误差比较大。就算使用了计算量更大的2D Freedom Directional，也是不合适的。</p>
<p><img src="/2023/05/07/unity15/2.png" alt></p>
<p>所以对于这种动画可以用旋转的速度来调整动画的X阈值，也就是角速度。计算角速度可以使用角度和弧度为单位，这里选择弧度Rad比较合适，使用角度当然也没错，但是角度的取值范围远大于纵坐标的z轴速度值，因此又会导致Clip排在一条横线上。而使用了Rad以后计算，发现此时动画的距离就比较合适了，此时虽然有同方向的不同速度，但是也可以使用2D Freedom Cartesian，当然是不精确的，不过我们此时可以忍受这种小幅的偏差，因为只有少数动画在同一方向，换来更低的计算量。</p>
<p>计算完成后，为了让动画播放保持统一，可以将原地、走路、奔跑的动画Clip的纵坐标阈值设置为一样的，这是标准资源包的参考做法。</p>
<p>现在拖动Sample Point，也就是红点，就可以查看移动效果了。确定没有问题后，我们进一步制作瞄准的动画。</p>
<h2 id="Aiming状态下的移动动画"><a href="#Aiming状态下的移动动画" class="headerlink" title="Aiming状态下的移动动画"></a>Aiming状态下的移动动画</h2><p>瞄准状态下的角色动画来自Maximo，包含了角色八个方向上的走路、奔跑动画，注意，这里的动画并非转向，而是角色直接朝某个方向移动的动画，而且角色的朝向不改变，因为角色瞄准的时候应该面朝我们鼠标的方向。由于此时多个同方向上都有不同速度的移动动画，因此必须要使用2D Freedom Directional了，保证动画的计算准确。</p>
<p><img src="/2023/05/07/unity15/3.png" alt></p>
<p>注意，这里动画的播放完全和2D中一致，动画没有角速度，所以采用的是xz速度计算阈值。</p>
<h2 id="参数分析和赋值"><a href="#参数分析和赋值" class="headerlink" title="参数分析和赋值"></a>参数分析和赋值</h2><p>现在我们分析一遍状态机有哪些参数，首先是切换瞄准状态的bool变量，命名为IsAiming；然后是Normal状态的Turn Speed和Vertical Speed，接着Aiming状态还有一个Horizontal Speed，共计四个参数。</p>
<p><img src="/2023/05/07/unity15/4.png" alt></p>
<p>然后确定玩家的输入值，我们这里仍使用New Input System，IsAiming同鼠标右键绑定，作为Button读取；移动使用WASD，作为二维向量读取；此外还需要一个切换奔跑的按键Shift，也做为Button读取。</p>
<p><img src="/2023/05/07/unity15/5.png" alt></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMoveInput</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    moveInput = context.ReadValue&lt;Vector2&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAimPositionInput</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    aimPosition = context.ReadValue&lt;Vector2&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetRunInput</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    isRunning = context.ReadValueAsButton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAimInput</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    isAiming = context.ReadValueAsButton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Normal状态，要传入Turn Speed作为动画混合的X阈值，这个值应当是一个弧度值，代表的是角色当前转向的方向和角色Z轴正方向的夹角的弧度，该弧度为正代表向右转，为负代表向左，那么在俯视角游戏中，镜头不旋转，角色的移动方向完全由WASD决定，但是角色向哪个方向转弯应该和角色当前的朝向有关，所以需要把WASD转化到角色的本地坐标系，角色才知道此时是要朝什么方向移动、转弯。</p>
<p>所以我们得计算角色移动的角速度，输入系统中返回的x值代表角色在世界坐标系下水平移动的方向，y值代表在世界坐标系下垂直移动的方向，那么使用下面的代码计算并设置弧度：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 dir;</span><br><span class="line">dir = <span class="keyword">new</span> Vector3(moveInput.x,<span class="number">0f</span>, moveInput.y);</span><br><span class="line">dir = tr.InverseTransformVector(dir);</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> rad = Mathf.Atan2(dir.x, dir.z);</span><br><span class="line">animator.SetFloat(<span class="string">&quot;Turn Speed&quot;</span>, rad, <span class="number">0.1f</span>, Time.deltaTime);</span><br></pre></td></tr></table></figure>
<p>其中moveInput已经获取了用户输入，我们把它换成三维向量，然后转化到角色的本地坐标系，接着用Mathf.Atan2方法计算反三角函数，就得到了弧度值。由于目前动画自带Root Motion，所以可以不用使用组件移动角色。</p>
<p>对于Aiming状态，需要获取角色前后左右移动的速度，这个我们之前已经使用多此，将用户的输入乘以当前速度即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 dir;</span><br><span class="line">dir = <span class="keyword">new</span> Vector3(moveInput.x, <span class="number">0f</span>, moveInput.y);</span><br><span class="line">dir = tr.InverseTransformVector(dir);</span><br><span class="line">animator.SetFloat(<span class="string">&quot;Horizontal Speed&quot;</span>, dir.x * targetSpeed, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">animator.SetFloat(<span class="string">&quot;Vertical Speed&quot;</span>, dir.z * targetSpeed, <span class="number">0.1f</span>, Time.deltaTime);</span><br></pre></td></tr></table></figure>
<p>注意，我们这里仍然要转化到本地坐标系中，因为角色的朝向是会改变的，我们希望角色在跟随瞄准方向后知道自己是往哪个方向移动。</p>
<h2 id="修改角色瞄准方向"><a href="#修改角色瞄准方向" class="headerlink" title="修改角色瞄准方向"></a>修改角色瞄准方向</h2><p>现在我们处理角色瞄准方向的问题，在New Input System中，Look一项可以选择鼠标的位置来传入一个二维向量aimPosition，该向量以(0,0)作为屏幕左下角，单位是屏幕的分辨率，表示鼠标的位置。因此我们不能直接获取指针在游戏世界坐标系中的位置，需要进行转换。</p>
<p>转换的方法就是使用射线，我们可以设置一个和角色持枪高度一致的平面，然后从相机的位置朝着鼠标位置发出一条射线，Unity提供了API实现这个功能，通过获取射线和平面相交的位置，可以将屏幕上的点转化为世界坐标系中的点。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 playerTargetPosition;</span><br><span class="line">Ray ray = Camera.main.ScreenPointToRay(aimPosition);</span><br><span class="line">Plane hitPlane = <span class="keyword">new</span> Plane(Vector3.up, tr.position);</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> distance;</span><br><span class="line"><span class="keyword">if</span> (hitPlane.Raycast(ray, <span class="keyword">out</span> distance))</span><br><span class="line">&#123;</span><br><span class="line">	playerTargetPosition = ray.GetPoint(distance);</span><br><span class="line">	tr.LookAt(playerTargetPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了当前角色的枪口瞄准的位置playerTargetPosition，使用Transform组件的LookAt方法让角色朝向该位置，其实就是旋转，角色的瞄准就完成了，又因为移动方法使用的是角色本地坐标系，所以我们设置的Animation也能正常作用。</p>
<p>下面是汇总的代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TopDownQinController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform tr;</span><br><span class="line">    Animator animator;</span><br><span class="line">    CharacterController characterController;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> walkSpeed = <span class="number">2f</span>;</span><br><span class="line">    <span class="built_in">float</span> runSpeed = <span class="number">5f</span>;</span><br><span class="line"></span><br><span class="line">    Vector2 moveInput;</span><br><span class="line">    Vector2 aimPosition;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> isRunning;</span><br><span class="line">    <span class="built_in">bool</span> isAiming;</span><br><span class="line">    <span class="built_in">bool</span> currentAimState;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> turnScale = <span class="number">180f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr = GetComponent&lt;Transform&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        characterController = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        changePlayerState();</span><br><span class="line">        PlayerMove();</span><br><span class="line">        PlayerRotate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 玩家输入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMoveInput</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        moveInput = context.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAimPositionInput</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        aimPosition = context.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetRunInput</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        isRunning = context.ReadValueAsButton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAimInput</span>(<span class="params">InputAction.CallbackContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        isAiming = context.ReadValueAsButton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changePlayerState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(currentAimState != isAiming)</span><br><span class="line">        &#123;</span><br><span class="line">            currentAimState = isAiming;</span><br><span class="line">            animator.SetBool(<span class="string">&quot;IsAiming&quot;</span>, isAiming);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlayerMove</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> targetSpeed = isRunning ? runSpeed : walkSpeed;</span><br><span class="line">        <span class="keyword">if</span> (isAiming)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 dir;</span><br><span class="line">            dir = <span class="keyword">new</span> Vector3(moveInput.x, <span class="number">0f</span>, moveInput.y);</span><br><span class="line">            dir = tr.InverseTransformVector(dir);</span><br><span class="line">            animator.SetFloat(<span class="string">&quot;Horizontal Speed&quot;</span>, dir.x * targetSpeed, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">            animator.SetFloat(<span class="string">&quot;Vertical Speed&quot;</span>, dir.z * targetSpeed, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetFloat(<span class="string">&quot;Vertical Speed&quot;</span>, moveInput.magnitude * targetSpeed, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlayerRotate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAiming)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 playerTargetPosition;</span><br><span class="line">            Ray ray = Camera.main.ScreenPointToRay(aimPosition);</span><br><span class="line">            Plane hitPlane = <span class="keyword">new</span> Plane(Vector3.up, tr.position);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> distance;</span><br><span class="line">            <span class="keyword">if</span> (hitPlane.Raycast(ray, <span class="keyword">out</span> distance))</span><br><span class="line">            &#123;</span><br><span class="line">                playerTargetPosition = ray.GetPoint(distance);</span><br><span class="line">                tr.LookAt(playerTargetPosition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 dir;</span><br><span class="line">            dir = <span class="keyword">new</span> Vector3(moveInput.x,<span class="number">0f</span>, moveInput.y);</span><br><span class="line">            dir = tr.InverseTransformVector(dir);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> rad = Mathf.Atan2(dir.x, dir.z);</span><br><span class="line">            animator.SetFloat(<span class="string">&quot;Turn Speed&quot;</span>, rad, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">            tr.Rotate(<span class="number">0</span>, rad * turnScale * Time.deltaTime, <span class="number">0</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        characterController.SimpleMove(animator.velocity);</span><br><span class="line">        tr.Rotate(animator.deltaRotation.eulerAngles);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到俯视视角的摄像机设置其实比较简单，下面我们试着优化摄像机来熟悉和练习Cinemachine的其他功能，最后再快速制作第三人称相机，它们有共通的地方。那么现在我们正式说明当前的需求，策划告诉你他现在要这个摄像机随着Aiming切换，普通状态下镜头的xz方向随着鼠标移动转动，并且角色前进的方向和镜头一致，依然是俯视角；而瞄准状态镜头不转动，角色随鼠标瞄准位置旋转，注意此时仍要求角色移动和镜头方向一致。如何实现？我们使用两种新的Body选项。</p>
<h2 id="Orbital-Transposer"><a href="#Orbital-Transposer" class="headerlink" title="Orbital Transposer"></a>Orbital Transposer</h2><p>使用这种body选项的移动方式，摄像机将在以跟随对象为圆心的圆环轨道上移动，你可以通过一系列的配置规定摄像机在圆环轨道上的位置，或者使用Look At选项配置摄像机的旋转。</p>
<p><img src="/2023/05/07/unity15/7.png" alt></p>
<p>其中多数属性和我们之前介绍的一致，现在主要说明不同的地方：</p>
<ul>
<li>Recenter To Target Heading：勾选Enable后，镜头将在Wait Time后，在Recentering Time内回到Heading中定义的位置。</li>
<li><p>Heading：定义一个镜头的前方方向，Definition中可以选择不同定义，Position Delta代表对象移动的方向，Velocity代表刚体目前的速度(如果没有刚体自动选择第一个)，Target Forward代表对象的前向方向，也就是角色的z轴正方向，World Forward代表使用世界坐标系的z轴正方向。</p>
</li>
<li><p>X Axis：由于在这种移动方式下相机只需要知道横向，也就是x轴如何移动，因此这里提供了设置x轴输入的设置，Value代表当前的值，0就是在Heading的地方，180在Heading对面，Value Range规定移动的范围，勾选Wrap可以让镜头在边界处循环；Speed是移动速度，as Max Speed代表作为最大速度，还可以选择让输入值乘以这个速度；Accel Time表示加速到最大速度用时，Decel Time则是减速用时；Input Axix Name是在新输入系统中定义的输入值名称，后面是具体的Value，勾选Invert以反转输入；</p>
</li>
</ul>
<p>是的，Unity提供了方便的联动，当使用这个Body后，再给摄像机添加一个脚本：</p>
<p><img src="/2023/05/07/unity15/8.png" alt></p>
<p>你就可以方便地使用新输入系统来控制摄像机了，通过该脚本的XY Axis，可以选择我们在输入系统中定义的按键和值传递给镜头，这里选择的方法是Pointer的delta Position，即可移动镜头。不使用新输入系统的情况下，Unity会自动寻找标准输入Input.GetAxis(name)来作为输入。</p>
<p>XY Axis输入二维向量改变相机的x、y轴位置，Z Axis则改变Z轴位置，类比很多第三人称游戏中，鼠标移动就控制了XY，鼠标滚轮则控制了Z。这里我们的相机设置如下：</p>
<p><img src="/2023/05/07/unity15/9.png" alt></p>
<h2 id="Framing-Transposer"><a href="#Framing-Transposer" class="headerlink" title="Framing Transposer"></a>Framing Transposer</h2><p><img src="/2023/05/07/unity15/10.png" alt></p>
<p>Framing Transposer是为2D游戏和正交投影设计的，它始终保持和目标之间的距离，该模式使用了Soft Zone和Dead Zone，可以看到其中很多设定和我们之前介绍Aim中的相同，下面介绍新增加的地方：</p>
<ul>
<li>Target Movement Only：勾选后阻尼将只对相机的位移作用，相机旋转会忽略阻尼；</li>
<li>Camera Distance：相机和目标之间的距离，注意，该模式下不能直接修改Transform的Position，必须通过Tracked Object Offset和Rotation，Camera Distance调整；</li>
<li>Dead Zone Depth：定义了三维上的Dead Zone，当镜头和目标的距离超过该值就调整相机；</li>
<li>Unlimited Soft Zone：让Soft Zone填满整个屏幕；</li>
</ul>
<p>上图就是我们目前的设置，作为瞄准状态下的摄像机。</p>
<h2 id="摄像机随动画状态机之间的转换"><a href="#摄像机随动画状态机之间的转换" class="headerlink" title="摄像机随动画状态机之间的转换"></a>摄像机随动画状态机之间的转换</h2><p>为了方便管理相机，我们可以让它们同动画状态机同步，方式也很简单，Cinemachine提供了State Driven Camera，创建后将前面的两个相机拖成它的子对象：</p>
<p><img src="/2023/05/07/unity15/11.png" alt></p>
<p>可以看到下面的Virtual Camera Children已经有了，该组件中其他属性和Cinemachine Brain的属性类似，我们只需要设置Animated Target即可，它应该是一个具备状态机的游戏对象，也就是我们的角色。添加后State一栏中就可以添加状态了，点击右下角加号，添加后选择对应的状态和相机，就可以实现转换了。在这个组件中可以定制转移模式。</p>
<h2 id="角色随镜头移动"><a href="#角色随镜头移动" class="headerlink" title="角色随镜头移动"></a>角色随镜头移动</h2><p>现在还有最后一个问题，角色不能随镜头方向前进。这个问题也很好解决，我们之前的移动方向是将输入作为世界坐标系中的方向，然后转化到角色的本地坐标系下作为移动方向。所以此时要让角色随着镜头移动，就要将镜头的前方作为角色移动的方向。其实也就是将镜头在xz平面上的投影作为z方向，与之垂直的作为x方向，注意这里的投影方向仍然是在世界坐标系中的位置，因此我们获取了投影方向之后仍然要转换到角色本地坐标系。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalculateInputDirection</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3 camForwardPro = Vector3.ProjectOnPlane(camTransform.forward, Vector3.up).normalized;</span><br><span class="line">    dir = camForwardPro * moveInput.y + camTransform.right * moveInput.x;</span><br><span class="line">    dir = tr.InverseTransformVector(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就得到了dir，我们在Update中运行该函数，每帧更新dir的值。这样角色就可以随镜头指向的前方移动。</p>
<h1 id="第三人称相机设置"><a href="#第三人称相机设置" class="headerlink" title="第三人称相机设置"></a>第三人称相机设置</h1><p>说了这么多以后，制作第三人称就很容易了。我们用到的概念已经都介绍过了，但是使用的虚拟相机是Free Look，这个摄像机实际上是由上中下三个Orbital相机组成的，Top相机，Middle相机，Bottom相机。通过Free Look的属性可以配置这三个相机的高度、轨道半径，由于属性基本我们都介绍过一遍，这里不再赘述。</p>
<p>不同的是，Free Look中读取了鼠标x、y方向的移动，x方向和Orbital一样控制相机在轨道上的移动，这里多了y方向的值用来在上面说的三个相机之间进行线性的切换，这就是Free Look实现第三人称相机的原理。</p>
<p>使用Free Look同样要添加脚本Cinemachine Input Provider并配置，记得修改x、y轴的反转。如果想要在游戏中禁用鼠标显示，可以使用下面的方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Cursor.lockState = CursorLockMode.Locked;</span><br></pre></td></tr></table></figure>
<p>设置完成后采用和上面一样的方法来让角色的移动方向和镜头的投影方向一致，就完成了第三人称相机的制作。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(十六)-布料模拟和输入系统的使用</title>
    <url>/2023/06/25/unity16/</url>
    <content><![CDATA[<p>这次填上前面的坑，之前我们使用Unity-Chan的免费插件spring-bone做布料模拟，比较繁琐，这里也不选择它来介绍了，我们改用他家的Magica Cloth，操作简单方便，效果也好。输入系统Input System跟前面是一个插件，不过前面我们使用的方式最简单，但会带来问题，下面会介绍推荐使用的Asset方法。</p>
<span id="more"></span>
<h1 id="布料-头发模拟"><a href="#布料-头发模拟" class="headerlink" title="布料/头发模拟"></a>布料/头发模拟</h1><h2 id="安装Magica-Cloth插件"><a href="#安装Magica-Cloth插件" class="headerlink" title="安装Magica Cloth插件"></a>安装Magica Cloth插件</h2><p>插件是付费插件，自己捣鼓可以去淘宝或者爱给网下一个，搜索Magica Cloth。不过安装该插件之前还要先安装另外两个依赖插件，一个是Burst，Package Manager中搜索安装即可；另外一个是Jobs，2021中改名为Collections，搜索不到可以用Add Pacakge from git URL，输入地址com.unity.jobs安装即可。</p>
<p>这两个插件安装完成后，再导入Magica Cloth的包，没有报错就是成功了。</p>
<p><img src="/2023/06/25/unity16/1.png" alt></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>我们以下面的模型为例，介绍如何设置人物的头发、衣服效果。图中蓝色骨骼使用Animation Rigging绘制。</p>
<p><img src="/2023/06/25/unity16/2.png" alt></p>
<h3 id="头发"><a href="#头发" class="headerlink" title="头发"></a>头发</h3><p>首先是人物头发，该模型中人物的头发只有左右两个侧发拥有骨骼并需要移动，所以我们对这两个侧发进行设置即可。利用Animation Rigging，点击对应位置的骨骼找到侧发的两个根节点：</p>
<p><img src="/2023/06/25/unity16/3.png" alt></p>
<p>编号7和12的就是要更改的头发节点，下面我们在导入的Magica Cloth/Res/Prefab中找到预制件MagicaPhysicsManager，添加到层级栏中用于管理所有的模拟，然后给人物模型添加子物体：</p>
<p><img src="/2023/06/25/unity16/4.png" alt></p>
<p>其中Magica Bone表示添加用于管理拥有骨骼的布料的模拟器，如果一个布料没有骨骼，使用Mesh也可以。而且这里Cloth不仅可以模拟衣服，头发也是采用这个进行模拟的，我们选择Macica Bone Cloth添加给人物模型。</p>
<p>完成后这里命名为流海，将刚才我们找到的两个节点拖拽给流海的MagicaBoneCloth组件的Root List，然后点击下面的Start Point Selection，会看到此时人物的这两个骨骼被绘制为不同颜色：</p>
<p><img src="/2023/06/25/unity16/5.png" alt></p>
<p>该插件中骨骼有以下类型：</p>
<p>绿色表示这个骨骼节点可以移动，红色节点表示这个骨骼节点不能移动但是可以旋转，也就是根节点，灰色节点表示不会受到插件的影响。所以我们后面要设置的时候，将根节点设置为红色，下面需要移动来模拟的节点设置为绿色即可。可以直接点击Type中的节点颜色来对模型的某个骨骼节点进行修改。</p>
<p>点击End Point Selection完成修改，组件的其他部分不管，直接修改最后的Parameters，插件直接提供了许多预设值供我们使用，所以我们要简单模拟的话也没必要慢慢调整了，对于侧发选择预设的Side Hair就行了：</p>
<p><img src="/2023/06/25/unity16/7.png" alt></p>
<p>之后点击Create，回到组件最上面看到提示信息中有各项参数，就是可以模拟了。点击运行，拖动人物就能看到头发此时有模拟效果。</p>
<p><img src="/2023/06/25/unity16/8.png" alt></p>
<p>注意不同大小、长度的头发都要用不同的参数，所以要多试试，不能用一个模拟器完成所有任务。</p>
<p>然后我们给角色的衣服都像上面这样设置，然后参数预设选择NormalSkirt。</p>
<p>另外，如果衣服默认不是向下的，还可以在参数中添加重力模拟。</p>
<h3 id="碰撞体"><a href="#碰撞体" class="headerlink" title="碰撞体"></a>碰撞体</h3><p>能动了之后还要防止模型穿模，头发很短不用管，但是需要给衣服和身体添加碰撞防止穿模。当然如果头发很长也是要添加碰撞的。</p>
<p>Magica Cloth提供两种方法防止穿模，Surface Peneration和Collider Peneration，第一种适用于衣服和身体有联系的情况，角色移动身体部位时衣服也会动；第二种就是像我们这里，衣服有自己的骨骼，不会和身体发生联动，需要添加碰撞体。</p>
<p>所以这里还是要我们手动给角色的身体部位添加对应大小形状的碰撞体，找到这个部位的根骨骼添加子对象：</p>
<p><img src="/2023/06/25/unity16/9.png" alt></p>
<p>然后调整它们的位置符合身体大小，给所有需要防止穿模的地方都设置一次，接着回到前面不同衣服对应的模拟器上，将可能碰到的部位分别添加给模拟器组件Magica Bone Cloth上的Collider List，这样就可以防止穿模了。</p>
<h1 id="输入系统使用"><a href="#输入系统使用" class="headerlink" title="输入系统使用"></a>输入系统使用</h1><p>旧输入系统中我们直接通过读取输入设备的值进行其它处理，Unity的输入系统用Action这一概念来映射输入设备的输入。新输入系统的工作流可以用下面的图片描述(<a href="https://zhuanlan.zhihu.com/p/106396562">博客地址</a>)：</p>
<p><img src="/2023/06/25/unity16/10.png" alt></p>
<p>我们通过创建Input Action Asset完成Action和输入设备的映射、绑定，每个Action的实现被分为五个Phase如上，其中Started、Performed、Canceled三个阶段将会调用一次Callback。</p>
<p>在文档实例中，给出了四种使用Input System的方式。</p>
<ul>
<li>Using State：读取设备状态值获取输入，和旧的输入系统一致；</li>
<li>Using PlayerInput：使用playerInput组件，设置自定义事件被哪个Callback订阅，也就是我们之前使用的方式；</li>
<li>Using Action Assets：使用Input Action Assets自动生成输入类，需要的时候主动调用方法获取一次输入的值；</li>
<li>Using List：使用自定义的 Input Action 列表，不做介绍。</li>
</ul>
<p>我们要使用的是第三种方式，这种方式不需要在Inspector中做任何配置，也不需要任何组件，使用代码可以完全控制输入，而且能解决乱七八糟的问题。</p>
<p>例如在使用player input组件的时候，容易碰到一种情况是，设置一个Button并绑定，按下对应按键后自定义的回调函数会被调用三次，如上面所说，获取的值在Started和Perfromed两个阶段为true，而最后一个阶段为false，因此在回调函数中打印获取的值，会发现按下一次按键有三次输出。</p>
<p>如果我们有需求是将这个Button做成转换角色状态的输入trigger，例如第一次按下后角色下蹲，再次按下后角色站起来，此时如果用这个输入值作为判断条件，那么会发现判断条件在按下的时候多次判断为true，导致函数被多次调用，因为不管多么短暂，我们的输入总是会保持那么几帧，而且每帧又包含三个阶段的调用，最后这个方法不会和我们实际按下的次数一一对应，而是会相当多次数被调用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按下下蹲键</span></span><br><span class="line">      <span class="keyword">if</span> (inputController.Crouch)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//当前是下蹲状态</span></span><br><span class="line">          <span class="keyword">if</span>(isCrouched)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//头顶没有障碍物</span></span><br><span class="line">              <span class="keyword">if</span>(OverHeadObjDetection() == <span class="literal">false</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">//站立</span></span><br><span class="line">                  isCrouched = <span class="literal">false</span>;</span><br><span class="line">                  animator.SetFloat(crouchID, <span class="number">0f</span>);</span><br><span class="line">                  SetCrouchColliderValue(originHeight, originCenter);</span><br><span class="line">                  cameraController.setLookAtPosition(normalLook);</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//当前不是下蹲状态</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//蹲下</span></span><br><span class="line">              isCrouched = <span class="literal">true</span>;</span><br><span class="line">              animator.SetFloat(crouchID, <span class="number">1f</span>);</span><br><span class="line">              SetCrouchColliderValue(crouchHeight, crouchCenter);</span><br><span class="line">              cameraController.setLookAtPosition(crouchLook);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>回到Action Assets上，我们勾选Generate C# Class可以生成一个类：</p>
<p><img src="/2023/06/25/unity16/11.png" alt></p>
<p>类中提供了一个结构体PlayerActions，将我们设置的Bindings做成了属性，然后提供在这些属性的Started，Performed，Canceled上添加、删除回调的订阅事件的方法。总之，我们要获取输入需要先实例化这个自动生成的类，然后直接获取PlayerActions结构体，使用这些属性的方法主动获取属性的值作为输入即可。</p>
<p>例如，要获取一个Vector2类型的向量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Vector2 Movement &#123; get =&gt; m_InputController.Player.Movement.ReadValue&lt;Vector2&gt;(); &#125;</span><br></pre></td></tr></table></figure>
<p>其中m_InputController是实例化的自动生成的类。如果要获取一个上面例子中Trigger类型的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool Crouch &#123; get =&gt; m_InputController.Player.Crouch.triggered; &#125;</span><br></pre></td></tr></table></figure>
<p>如果有一个普通Button类型的值，即按下为1，松开后为0的按键，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool Run &#123; get =&gt; m_InputController.Player.Run.phase == InputActionPhase.Performed; &#125;</span><br></pre></td></tr></table></figure>
<p>最后这个稍微有些特殊，获取的是Performed阶段的值。</p>
<p>这样使用输入系统就可以解决实际按下按键后出现多次调用的事件了，因为此时我们获取是主动的，使用triggered后仅触发一次。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity初识(二)-界面布局的操作实战</title>
    <url>/2023/03/08/unity2/</url>
    <content><![CDATA[<p>在上次的介绍中，我们对Unity的布局局面有了大致认识，了解了各类工具的使用，所有现在我们直接通过实战进行熟悉，并且不会涉及到代码编写，脚本相关从本系列第三篇博客中记录。</p>
<span id="more"></span>
<p>要通过Unity的基本操作制作简单游戏，方法是使用Unity Playground，其中Unity提供了一系列可以直接使用的组件，预设了开发环境，是官方提供的熟悉基本操作的教程。具体的导入方法在前一节中已经介绍了，直接打开之前用到的项目即可。</p>
<h1 id="制作一个小游戏"><a href="#制作一个小游戏" class="headerlink" title="制作一个小游戏"></a>制作一个小游戏</h1><h2 id="1-新建场景"><a href="#1-新建场景" class="headerlink" title="1 新建场景"></a>1 新建场景</h2><p>在Hierarchy或者Project/Assets/Scene中，都可以进行新场景的创建，一个场景包含很多游戏对象，游戏中可以切换不同的游戏场景，起始就是切换到了另外一个场景。在Hierarchy中右键已有场景，选择Add New Scene；在Project中，直接右键选择Create，然后再选择Scene选项卡。</p>
<p><img src="/2023/03/08/unity2/1.png" alt></p>
<p>创建完成后，可以看到已经包含了一个主摄像机，而且由于创建的是2D项目，因此Scene视图中已经安排好了位置，这一节暂时不用移动摄像机了。</p>
<h2 id="2-创建玩家对象"><a href="#2-创建玩家对象" class="headerlink" title="2 创建玩家对象"></a>2 创建玩家对象</h2><p>我们之前导入了Play Ground，这里用到的所有的资源也都是来自Play Ground。在2D游戏中，角色通常由一系列图片作为资源构成，角色的动作通过播放图片，即关键帧来实现。我们先打开Assets/UnityTechnologies/Playground/Image文件夹，看到有许多分类的图片资源，现在选中太空船(Spaceships)文件夹，任选一个飞船图片作为玩家对象。选中该图片，拖拽到Hierarchy或者Scene中，即可添加对象。</p>
<p><img src="/2023/03/08/unity2/2.png" alt></p>
<p>添加完成后，可以设置下游戏窗口尺寸为Full HD（1980*1080），然后利用缩放工具，将飞船缩放到合适的大小。接着设置属性，按照以下顺序：</p>
<ul>
<li>修改名称（方便自己找即可）；</li>
<li>修改tag为Player；</li>
</ul>
<p>其中，Tag的修改比较重要，Tag作为对象标签，可以将游戏对象分为不同类，方便在编写逻辑脚本的时候让脚本只针对某一类对象生效，从而方便脚本获取对象。标签是自定义的，在项目管理中更改，这里Playground由于是教程，已经导入了标签分类，所以不用我们手动修改了。</p>
<p>接下来为了让飞船能够动起来，就需要用到脚本了。Unity的脚本使用C#语言进行编写，功能就是控制某个游戏对象与玩家、游戏对象和游戏对象之间的交互。同样Unity提供了编写好的脚本，我们直接使用即可，后面的教程中会详细说明脚本如何编写。</p>
<p>脚本可以通过两种方式添加：</p>
<ul>
<li>在Assets中，找到Scripts文件夹（和Image文件夹同级），然后进入Movement文件夹，选中Move文件，拖拽到飞船的Inspector窗口中即可；</li>
<li>点击Inspector窗口中下方的Add Component，然后搜索Move，点击Move with Arrows；</li>
</ul>
<p>添加完成后，看到飞船的属性窗口多了两个选项卡，Rigidbody 2D和刚才添加的脚本，前者是2D下的刚体组件，通过脚本可以进一步赋予飞船重力控制和碰撞检测等效果，将对象和物理引擎挂接，默认情况下如果直接运行，飞船会受到重力往下掉出屏幕。我们进一步调整其中的物理选项：</p>
<ul>
<li>Mass：质量</li>
<li>Friction：表面摩擦力</li>
<li>Angular Friction：旋转摩擦力：</li>
<li>Gravity：重力</li>
</ul>
<p>将重力设置成0，摩擦力设置成5即可。另外，脚本组件中会直接显示脚本的接口，可以方便地进行调整。这里编写好的脚本提供了多种接口，我们调整下飞船的Type of Control、Speed，不好理解的是Orient to Direction，意思是让飞船随着方向键转向，打勾即可。</p>
<p>现在，飞船已经可以通过方向键控制进行移动了。</p>
<h2 id="3-添加碰撞物体"><a href="#3-添加碰撞物体" class="headerlink" title="3 添加碰撞物体"></a>3 添加碰撞物体</h2><p>设置两种物体供游玩：</p>
<ul>
<li>小星星：奖励碰撞；</li>
<li>小行星：惩罚碰撞；</li>
</ul>
<h3 id="3-1-添加小行星"><a href="#3-1-添加小行星" class="headerlink" title="3.1 添加小行星"></a>3.1 添加小行星</h3><p>找到Image下的Asteroids文件夹，选中一个小行星图片，添加到场景中，缩放到合适大小。和前面一样，这里暂时不添加Tag（为什么？），直接添加脚本组件Modify Health，添加后会显示当前脚本与Collider组件关联，并且需要选择碰撞检测的类型，分别是Polygon/Rectangle/Circle，选择第一个（多边形），适合我们这样形状不规则的物体。此时添加了两个组件：脚本组件和Polygon Collider 2D，要将后者选项卡中的Is Trigger取消，意思是是否让该对象仅作为触发器而不具有物理属性，显然这个选项适合检测其他对象是否进入这个区域。而我们要做的小行星就不必了，他应该具有物理属性。另外，飞船同样应该具备碰撞检测，因此也要手动添加Polygon Collider 2D组件。</p>
<p>因此再手动添加Rigidbody 2D组件，然后设置重力为0，旋转阻力为0.5，摩擦力为5，质量为10（可以看看其他数值效果如何）。</p>
<h3 id="3-2-添加小星星"><a href="#3-2-添加小星星" class="headerlink" title="3.2 添加小星星"></a>3.2 添加小星星</h3><p>小星星是奖励玩家的碰撞对象，并且严格来说并不需要具备碰撞检测的能力，而是进行区域的检测，当飞船模型和小星星模型有重叠时，让小星星自动消失，飞船并不会受到撞击，而是分数加一。在Project中找到对应的小星星图片Image/GameElements/Star，拖进Hierarchy中，缩放到合适大小，然后添加组件：</p>
<ul>
<li>Polygon Collider 2D并勾选Is Trigger；</li>
<li>Collectable脚本：已编写好的脚本，当标签为玩家的对象触碰到这个对象时，奖励玩家积分。</li>
</ul>
<h2 id="4-添加UI界面"><a href="#4-添加UI界面" class="headerlink" title="4 添加UI界面"></a>4 添加UI界面</h2><p>用户界面显示了飞船血量、分数，在Unity中，UI是作为预制件存在的，这里也略过制作过程，直接在Project中搜索对应资源UserInterface，将文件类型为预制件（Prefab Asset）的文件拖拽进入Hierarchy中，在Game视图中就会显示UI了，在Scene中并不显示。</p>
<p>为了让UI上的数字和游戏绑定，需要再次借助脚本，刚才我们添加了碰撞检测，但是并没有规定飞船怎么扣血，所以除了给小行星添加扣除血量的脚本外，飞船同样要添加检测和记录生命值的系统Health System。</p>
<p>预制件（Prefabs）：Unity 的预制件系统允许创建、配置和存储游戏对象及其所有组件、属性值和子游戏对象作为可重用资源。预制件资源充当模板，在此模板的基础之上可以在场景中创建新的预制件实例。也就是说，所有东西都可被保存成预制件，作为模板方便反复使用。</p>
<p>现在由于小行星制作完成，后面还需要放置很多个相同的小行星，所以我们直接将Hierarchy中的小行星拖动到Prefabs文件夹中即可保存。为了方便管理，我们在这个文件夹中进一步分类，创建一个新的文件夹，然后再拖进来。拖进来以后，可以发现原来在Hierarchy中小行星左侧空的立方体图标变成蓝色实体了，同时Inspector窗口中也显示了Prefab属性。</p>
<p>小星星同样可以用预制件保存。为了方便管理，可以创建一个空的游戏对象作为相同预制件的父对象，相当于新建了一个文件夹，这样以来可以通过点击空的游戏对象选中所有的相同预制件。不过要注意，当我们将一个对象列为子对象后，这个子对象Inspector窗口中的position属性实际上变成了相对位置，而不再以世界坐标系的原点作为(0,0,0)。</p>
<p>如果想要这些子对象依然使用世界坐标系，那么可以将父对象的坐标移动到(0,0,0)。</p>
<h2 id="5-添加背景"><a href="#5-添加背景" class="headerlink" title="5 添加背景"></a>5 添加背景</h2><p>前面制作了基本玩法，现在添加一个宇宙的背景，找到Image/BackGrounds文件夹，选中BG_Space图片并拖动到Hierarchy中。然后修改Sprite Renderer（精灵渲染器）：</p>
<ul>
<li>Draw Mode改为Tiled；</li>
<li>Sorting Layer改为Background；</li>
<li>缩放到合适大小，遮盖整个背景；</li>
</ul>
<p><img src="/2023/03/08/unity2/3.png" alt></p>
<p>这样以来我们的第一个简单小游戏就制作完成了，其实可以发现，如果熟练使用Unity之后，用这些资源五分钟就能做出来这样一个游戏，可见游戏引擎确实极大地方便了开发。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(三)-制作一个2D游戏</title>
    <url>/2023/03/12/unity3/</url>
    <content><![CDATA[<p>前面的博客中我们熟悉了Unity界面的布局和使用，并没有介绍怎么让Unity和脚本/IDE进行挂接，从现在开始我们进一步学习Unity，仅导入非编程资源构建一个2D的项目，包括代码的调试方法，角色的基本移动脚本，Tilemap如何使用。默认你拥有面向对象基础，方便开展接下来的学习任务。</p>
<span id="more"></span>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>为了方便学习，我们暂时先进行一些准备工作，首先确保我们正确设置了IDE，要了解如何用IDE对Unity的脚本进行开发和调试；然后是Unity序列化的介绍，这个工具能帮助我们在Unity中直接查看并调整脚本对游戏对象的某些设置，对素材导入也有帮助；最后是素材的准备，对个人来说这通常是最头疼的部分。</p>
<h2 id="设置Unity的IDE"><a href="#设置Unity的IDE" class="headerlink" title="设置Unity的IDE"></a>设置Unity的IDE</h2><p>C#开发的话采用vscode和visual studio都可以，不够后者更值得推荐 ，它集成了多种IDE功能，并且基本不用进行多余的设置就可以和Unity挂接成功，包括debug、项目对接、成员查找等，适合初学者使用，因此我这里直接采用后者。</p>
<p>Unity对visual studio支持比较完善，首先要使用vs进行C#开发，需要在vs的安装选项中选择安装桌面开发模块(.NET)，相当于Java必备的虚拟机，让C#程序有一个运行的环境支持，同时也新增了C#语言的识别工具，方便了开发，但这只是一个推荐的可选项；Unity游戏开发模块则是必选的模块，它提供了与Unity挂接的接口和编译器等C#运行环境。</p>
<p><img src="/2023/03/12/unity3/1.png" alt></p>
<p>以vs2019社区版为例，安装可以在新建项目窗口找到，点击后确认安装的模块并安装即可。如果仅使用Unity进行C#的开发，可以不选择.NET，Unity仍然在使用mono作为编译环境，点击“使用Unity的游戏开发”可以发现简介中提到已经包含了C#的编译器。</p>
<p><img src="/2023/03/12/unity3/2.png" alt></p>
<p>下载完成后，打开Unity，找到Edit/Preferences/ExternalTools，点击External Script Editor，选中已经存在的vs即可。</p>
<p><img src="/2023/03/12/unity3/3.png" alt></p>
<p>你可以打开之前的项目或者试着创建脚本，查看是否跳转成功。</p>
<p>接下来我们尝试调试一个脚本，随便创建一个空对象，然后添加新的脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainPlayer</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> myName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> strength;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;我的名字是：&quot;</span> + myName);</span><br><span class="line">        Debug.Log(strength);</span><br><span class="line">        Debug.Log(health);</span><br><span class="line">        Debug.Log(Add(<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y + z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后添加断点，选择附加到Unity</p>
<p><img src="/2023/03/12/unity3/4.png" alt></p>
<p>接着在Game视图中运行场景，经过调用后Unity自动会跳转到vs的调试界面，就可以和正常程序一样查看变量并且调试了。</p>
<h2 id="Unity序列化"><a href="#Unity序列化" class="headerlink" title="Unity序列化"></a>Unity序列化</h2><p>序列化指的是，从程序运行的内存中，将指定对象转换为二进制流（数据），为传输（可能是输出到硬盘文件、或传输给网络上其他电脑）做准备的过程。这点和Unity脚本的序列化不同，后者主要说的就是能不能在Inspector窗口中查看对应脚本给游戏对象设置的属性，类等成员；而Unity也具备文件序列化的功能，方便资源读取等操作，这个我们暂且不说，导入素材的时候也许会用到。</p>
<p>首先对于游戏对象的脚本中，通常会定义一个主类来设置对象的属性、方法等，而属性一般以成员变量的形式呈现，我们知道成员变量需要被访问指定词限制，public的成员变量可以直接被挂接到Unity的Inspector窗口中，而private、protect修饰的成员变量并不被展示。但是有的时候又想让这些变量出现在窗口中方便更改，就可以在其定义前面添加[UnityEngine.SerializeField]，从而序列化一个私有域。</p>
<p>我们在Unity的脚本开发中，除了给游戏对象创建的类外，可能会有一些自定义类存在，方便在游戏对象对应的主类中进行调用。它和我们为游戏对象直接添加的脚本中类的区别是，Unity添加的类继承了一个父类MonoBehavior，这个基类为Unity提供将脚本和对象挂接的接口，也让子类能够被自动序列化，但是自定义类不同，它并没有从这个类派生出去，所以不会被Unity序列化。为了在Inspector窗口中也能对这些类进行修改，就需要在这些类的定义之前加上序列化标签：[System.Serializable]。</p>
<p>关于序列化暂且简单记录到这里，贴一个链接方便深入<a href="https://www.cnblogs.com/zhaoqingqing/p/3995304.html">学习</a>。</p>
<h2 id="素材准备"><a href="#素材准备" class="headerlink" title="素材准备"></a>素材准备</h2><p>新建一个2D模板项目，导入Unity资产：<a href="https://assetstore.unity.com/packages/2d/2d-beginner-tutorial-resources-140167?_ga=2.134705203.331241089.1633678521-522971275.1624332126">RubyAdventure</a>。</p>
<p><img src="/2023/03/12/unity3/5.png" alt></p>
<p>这是一个仅拥有游戏素材的Unity资产，它提供了我们接下来要制作的游戏的所有材料，例如图片、关键帧动画、音效等，而完全没有已经编写的脚本、预制件等内容，因此，所有关于Unity的内容我们都将从零开始。</p>
<p>这个项目包括的内容有：</p>
<ul>
<li>2D素材的导入和使用；</li>
<li>角色控制系统；</li>
<li>TileMap使用；</li>
<li>设置动态Sprite；</li>
<li>入门粒子系统；</li>
</ul>
<h1 id="角色控制"><a href="#角色控制" class="headerlink" title="角色控制"></a>角色控制</h1><p>2D素材我们已经准备好了，具体如何使用这些五花八门的素材，将在使用到某个素材的时候结合操作进行介绍。现在作为脚本的入门，我们先选择一个简单的角色移动控制系统来引入。</p>
<p>2D角色的控制很简单，它通常由两部分构成：移动和动画播放。也就是说，我们创建的角色将在播放动画的同时进行移动，从而完成游戏中移动的效果。现在我们尝试制作角色移动的脚本，将上面这个主角的图片添加到Art/Sprite中，然后再次添加到层级栏中，这样就创建了主角的游戏对象。</p>
<p>然后我们给这个主角对象添加一个新的脚本：RubyController，并将自动创建的脚本拖动到Assets/Scripts文件夹中方便管理。</p>
<p>新建的脚本中给出了一个继承自MonoBehaviour的类RubyController，并且已经创建了两个基本方法：Start和Update。前者在游戏开始前自动调用一次，后者将会在每一帧进行一次调用。</p>
<p>就目前来看，并不需要Start方法，因此可以暂时删除它。为了让角色移动，我们需要调用Unity提供的两个基本类：Input和Transform，前者接受键盘鼠标的输入，后者记录当前游戏对象的位置状态。这样一来我们要做的事情就很明显了，你可能想到，我们使用Input接受键盘按键，再编写一个Move函数，每次接受到信号时，更改Transform即可。Input类还在ProjectSetting中提供了InputManager，将枚举的类型值绑定到自定义按键上，用GetAxis方法接受枚举值；当然你也可以直接用GetKey等一系列方法直接获取按键信息。</p>
<p><img src="/2023/03/12/unity3/6.png" alt></p>
<p>事实上我们也是这样做的，只不过其中有一个问题值得讨论：如何控制游戏帧数和移动速度？</p>
<p>一台高配置的PC可能会具有800帧/秒的性能，如果这个位移量为常量，它将导致极快的移动速度；但是在另一台只有10帧/秒的PC上角色将移动得很慢，并且明显能感受到0.1s的延迟。为了解决这个问题，我们需要根据帧数调整移动量，帧数通过Unity提供的基本类Time中的deltaTime获取，它记录了每帧间隔的时间，为了保持一致的移动速度，我们像下面这样进行编写：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//Input类接受键盘输入，在Unity设置中修改对应按键</span></span><br><span class="line">        <span class="built_in">float</span> horizontal = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="built_in">float</span> vertical = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">    	<span class="comment">//获取当前对象位置</span></span><br><span class="line">        Vector2 position = transform.position;</span><br><span class="line">    	<span class="comment">//根据帧数设置移动速度</span></span><br><span class="line">        position.x = position.x + speed * horizontal * Time.deltaTime;</span><br><span class="line">        position.y = position.y + speed * vertical * Time.deltaTime;</span><br><span class="line">        transform.position = position;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>现在我们设置了以时间为单位的移动速度，它通过deltaTime平衡了不同帧数的影响，800帧时每帧移动量为原本的1/800，10帧时移动原本的1/10，因此每秒移动的距离是相等的。</p>
<p>启用这个脚本以后，我们的角色已经可以移动了，不过由于缺少动画，它显得很奇怪。</p>
<h1 id="TileMap"><a href="#TileMap" class="headerlink" title="TileMap"></a>TileMap</h1><p>除了角色外，另一个重要的内容是场景是如何进行绘制的。显然在我们前面做的飞机小游戏中，背景就是一张图片，我们向其中添加了一些陨石图片并加上各种组件，使得陨石可以进行交互。</p>
<p>而在很多2D游戏中，显然不可能直接用一张图片作为背景就结束场景制作，因为需要设计可交互的场景例如地板、门等东西，尤其是像素游戏中，可以观察到地图并不是一整个图片，而是一格一格的，这其实就是TileMap，利用它可以通过一张美术资源素材图片就设计出大片的地图，下面我们具体看看如何操作。</p>
<h2 id="将美术素材转化为Sprite"><a href="#将美术素材转化为Sprite" class="headerlink" title="将美术素材转化为Sprite"></a>将美术素材转化为Sprite</h2><p>在Unity中，对图片的操作可以使用Sprite完成，这是Unity处理纹理的容器，很像一个有很多方法的实例化对象，可以将任意图片通过Sprite处理。</p>
<p><img src="/2023/03/12/unity3/7.png" alt></p>
<p>这就是我们要用到的素材，直接将图片保存到当前文件夹中自定义的地方即可，可以将其保存到Sprite中。在Unity中选中这个图片，就会发现右边的Inspector窗口中已经显示了Texture Type为Sprite(2D and UI)。</p>
<h2 id="创建TileMap"><a href="#创建TileMap" class="headerlink" title="创建TileMap"></a>创建TileMap</h2><p>有了素材以后，不能直接使用TileMap功能，因为它是作为一个游戏对象存在的，在层级栏中创建TileMap后才能使用它的功能。</p>
<p><img src="/2023/03/12/unity3/8.png" alt></p>
<p>这里创建的是矩形的，这个选项卡中都是说的TileMap形状，学会矩形的就可以了，如果后面需要的话可以自行了解，都差不多。创建以后会发现，TileMap还连带创建了一个父对象Grid，都有各自对应的组件，现在也暂时不需要修改，就是一些所在平面等设置。</p>
<h2 id="使用Sprite-Editor和PPU处理美术素材"><a href="#使用Sprite-Editor和PPU处理美术素材" class="headerlink" title="使用Sprite Editor和PPU处理美术素材"></a>使用Sprite Editor和PPU处理美术素材</h2><p>这时我们可以介绍一下Environment中那些奇怪的图片了，它们看起来毫无关联，并且上面的内容也看不出来，但其实它们是用来制作地图的。具体来说，这些图片是一个九宫格图片，其中每一个都是地图上的一块，例如看起来最明显的那一张：</p>
<p><img src="/2023/03/12/unity3/9.png" alt></p>
<p>分成九宫格以后，我们可以通过后面的方法让左上角的这个格子图片只出现在拐弯的地方，从而不受限与这个图片的大小，而是制作一个足够面积、任意形状的水池：</p>
<p><img src="/2023/03/12/unity3/10.png" alt></p>
<p>这样看就很清楚了，这里美术素材很大程度上节省了画师的时间，同时我们对资源读取的要求也只是那一张图片。选中需要分割的图片，在Inspector窗口中，修改Sprite Mode为Multiple，代表这个素材中含有多个小的素材；将Pixels Per Unit修改为64；打开Sprite Editor，点开Slice选项卡，选择Grid By Cell Count，表示用网格数进行均等划分，这里自然就是3*3，点击slice，点击右上角Apply，然后保存修改。</p>
<p><img src="/2023/03/12/unity3/11.png" alt></p>
<p>这样就划分好一个素材了。而刚才的砖块图片则不需要进行分割，因为它不需要变化，所有地方都一样。</p>
<p>除此之外，还要将这些图片的Sprite属性Pixels Per Unit全部改成64，默认情况下图片读取进来都是100，100*100个像素/单位，接下来我们简称这个值为PPU。</p>
<p>为了解这个值的用法，首先要明白什么是一个单位，在Unity中不论2D还是3D都有摄像机Camera，其中有一个属性是size，解释为摄像机视图的垂直大小，代表摄像机能看到场景的竖直长度为几个单位。这里默认的是5，也就是说摄像机能看到上下各五个网格，总共是十个网格的长度，那么这里一个网格就是一个单位。</p>
<p>既然摄像机上下的尺寸可以通过size确定，那么左右呢？答案是修改size的同时也修改了左右尺寸，因为在Unity中确定了上下尺寸后，根据屏幕横纵比同时也能确定左右尺寸，例如屏幕是9:16的，又知道前面设置size为5，那么左右尺寸就应该是$16/9<em>5</em>2=160/9$个单位。</p>
<p>因此PPU的用处就是用来根据图片本来的尺寸计算一个单位应该给多少像素，原来图片的像素肯定是不改变的，如果一个图片是$192<em>192$的，那么将PPU设置成192后就能将这个图片放到一个格子中；将PPU设置成64就需要9个格子来放这个图片，因为$192=64</em>3$，宽高都需要三个格子，也就是九个格子。</p>
<p>而我们这里之所以划分成九宫格也是这个原因，Brick图片是$64<em>64$的，刚好一个格子；需要分割的图片则是$192</em>192$的，所以划分一下。</p>
<p>最后，某些情况下素材可能需要进一步调整才能符合需要，例如将一个图片调整到刚好覆盖整个摄像机视图，那么就需要根据图片的尺寸来设计size、PPU，从而达到理想的效果。</p>
<h2 id="使用Tile-Palette绘制场景"><a href="#使用Tile-Palette绘制场景" class="headerlink" title="使用Tile Palette绘制场景"></a>使用Tile Palette绘制场景</h2><p>得到切分好的素材后，怎么将它绘制到场景中就是最后的问题了。调色板就是用来做这个的，首先在Scene视图的右上角找到一个紫色的按钮，点击后打开Tile Palette，此时其中是空的，我们需要点击Create New Palette自行创建一个调色板，并将其文件保存在Tiles/Palette中。</p>
<p>接着在Tiles/RuleTiles中创建一个新的RuleTile，选中，修改其中的Default Sprite为刚才处理好的素材，以不需要分割的Brick为例。设置完成后将这个RuleTile拖拽到Palette中，就完成了素材的添加。到这里就可以使用Brush工具选中这个素材，然后在场景中绘制了。</p>
<p>当然这是最简单的情况，我们之前对后面六个图都进行了分割，应该如何使用？答案和之前是一样的，只不过拖进去后可以发现现在可以任意选中其中某一块九宫格进行绘制。</p>
<p>但是显然我们创建的RuleTile还有更好的功能，Unity支持使用编程的方式定义Tile排布方式。这里先不介绍，我们使用另一种简单一些的方式实现自动的排布。</p>
<p>重新创建一个RuleTile，点击+号添加需要进行排布关联数量，并点击select添加图片：<img src="/2023/03/12/unity3/12.png" alt></p>
<p>依次添加之前分割好的图片(自动以编号顺延的方式命名)，在九宫格中确定排布，勾代表这个图片的这个相对位置可以有图片，叉代表不可以，从而完成排布安排。</p>
<p><img src="/2023/03/12/unity3/13.png" alt></p>
<p>其中整个TileMap的Default Sprite可以用任意一个方便分辨的图片，因为最后是以一个格子的形式存放在Palette中的。制作完成后将这个拖动到Palette中，可以发现此时已经会自动变换图边了。</p>
<p>另外还有一个Rule Override Tile，就是类的继承，同样在Tiles选项卡中创建，选中，在Tile属性中设置为要继承的基Tile，然后就会发现只需要添加图片就可以得到和刚才一样的效果了。</p>
<p><img src="/2023/03/12/unity3/14.png" alt></p>
<p>最后，如果要在Palette中调整Tile的位置等操作，注意要选中edit按钮，才能修改当前的Palette，否则不会发生改变。</p>
<h2 id="调整图片排序"><a href="#调整图片排序" class="headerlink" title="调整图片排序"></a>调整图片排序</h2><p>人物不能在背景之后，也就是说背景应该在最下面的图层。这通过修改order in layer实现，在TileMap的Inspector窗口中找到Tilemap Renderer，选择Additional settings中的order in layer，修改为-10，这样即使在同一层，背景的优先级也很小，也就是说这个值越大越会被排在前面。</p>
<p><img src="/2023/03/12/unity3/16.png" alt></p>
<p>而对于一些景物需要存在遮盖关系，这个关系当然会随着人物移动而改变，这可以通过伪透视图实现，在Edit &gt; Project Settings &gt; Graphics &gt; Camera Settings &gt; Transparency Sort Mode = Custom Axis &gt; Transparency Sort Axis x = 0 / y = 1 / z = 0进行设置，表示用y轴的大小作为伪透视的标准，这样一来在我们创建的地图上，走在上面的就会被遮盖，越往下越靠近屏幕，这就是伪透视。</p>
<p>现在我们将素材tree拖进场景中，启动游戏，却发现每次经过树高一半的时候树就被人物遮挡了，我们希望的是人物走到树根的时候再改变遮蔽关系，因此需要再次打开sprite editor，调整pivot为bottom center即可。pivot就是图片的支点，调整以后就可以让人物走到树根再遮挡树了。</p>
<p><img src="/2023/03/12/unity3/15.png" alt></p>
<p>但是如果直接运行游戏会发现并没有得到理想的效果，这是因为我们默认的比较方式是用图片的center位置比较，要pivot生效需要进行两个设置：</p>
<ul>
<li>在Scene视图左上角点击Toggle Handle Position，并选择Pivot；</li>
<li>在游戏对象的Sprite Renderer中将Sprite Sort Point选择为Pivot；</li>
</ul>
<p>默认的都是center选项，这样以后就可以用自己定义的pivot位置实现透视效果了。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity进阶(一)-数据存储和持久化</title>
    <url>/2023/08/21/unity17/</url>
    <content><![CDATA[<p>经过两天研究，是时候总结下unity的数据存储方式了。</p>
<p>之前我们的工程里全部用类或者静态类保存数据，维护起来很不方便，尤其对于策划来说没有直接的工作流，所以我们得提供一个配表解决方案，让策划能够通过修改Excel或者其它文本格式的文件来完成属性的配置。而且有时候需要用网络传输数据文件，我们程序里的数据是不能直接传输的，这就涉及到序列化和反序列化。下面我看看Unity中一般有哪些存储数据的方式。</p>
<span id="more"></span>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><p>之前写代码总是让数据在声明的时候进行初始化，那么这个类每次被实例化的时候就会初始化一次该对象，这样做有两个缺点：第一，如果类是单例还好，可有时需要让这个类作为预制件的脚本挂上去，后续还会实例化这个预制件，那么我们这样会浪费很多空间用来声明这些值，尽管它们有可能是相同的。</p>
<p>第二，每次我们启动游戏，所有的状态都会被重置，因为类在实例化的时候重新声明了数据值，没办法保存上一次打开游戏的数据状态，这就是数据的持久化不能实现。</p>
<p>数据持久化指的是，让数据能够保存在硬盘等外部硬件资源，供后续使用的存储方式。在类的内部进行数据的声明，不能实现数据的持久化。因此我们要以文件作为媒介将数据保存下来。</p>
<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p>了解了持久化，我们再介绍序列化是什么。由于程序运行中某一时刻的状态无法直接保存，我们需要将运行在程序中的数据转化为文件，这样才能用网络通信的接口进行传输或自己保存在本地，这就是序列化。Unity编辑器中提供了Inspector窗口查看程序的值，它的实现就使用了序列化，将运行过程中变量的值序列化为某种格式，然后展示到窗口中。</p>
<p>我们自己实现序列化说白了就是将某个时候的一个或多个变量值存在某种格式的文件中，例如JSON，XML等，这样通信将这些文件传输出去，或者下次打开的时候读取这些文件，就能知道这个时候的状态是什么了。</p>
<p>反序列化就是上面说的读取的这个过程，收到了一个JSON文件，此时对它进行解析，将其中的值重新赋值给我们的变量，就完成了反序列化。通过序列化和反序列化，可以实现网络通信的部分要求和数据持久化。</p>
<h1 id="Scriptable-Object"><a href="#Scriptable-Object" class="headerlink" title="Scriptable Object"></a>Scriptable Object</h1><p>这个神器本身是很好用的，但是由于它只支持编辑器的数据持久化，打包以后就不能了，所以有的教程用这个做背包简直是毫无用处，只能在编辑器里看看效果，真要做背包还是得数据库。但是这个东西优点也很多，比如可以在编辑器里查看、修改，而且资源加载的时候也不用自己再手动反序列化一次，省了一点时间。</p>
<p><a href="https://www.zhihu.com/question/40879788">这位</a>大佬贴了一个用SO做数据存储的解决方案，可以瞻仰一下。</p>
<p>Unity中新建一个类，继承ScriptableObject即可创建一个Scriptable Object类，你可以通过添加序列化关键字的方式来配置它管理的内容，并且支持嵌套，用一个Root类管理其它Scriptable Object，其余完全和类变量的序列化一致。</p>
<p>唯一区别是你不用将它挂载到对象上实例化，而是通过Editor添加一个创建Scriptable Object的选项，在Project中创建该资产，后缀为asset，这样就可以直接使用了，在Inspector中修改序列化的值，然后就能</p>
<h1 id="JSON序列化和反序列化"><a href="#JSON序列化和反序列化" class="headerlink" title="JSON序列化和反序列化"></a>JSON序列化和反序列化</h1><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>当我们的应用接收到一个JSON文件，需要进行解析，对应到我们自己创建的实体类中，其实就是反序列化。首先需要建立对应JSON文件的实体类，推荐一个<a href="https://www.json.cn/json/json2csharp.html">网站</a>可以自动生成JSON文件对应的实体类。当然自己写也可以，只是有可能会出错。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;NAME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vardan&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;HP&quot;</span><span class="punctuation">:</span> <span class="number">100.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ATK&quot;</span><span class="punctuation">:</span> <span class="number">30.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;DEF&quot;</span><span class="punctuation">:</span> <span class="number">20.0</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>通过这两个方法就可以实现序列化和反序列化，但是要注意处理的都是字符串，要解析文件的内容还需要进一步将JSON文件转化为字符串才行。而字符串也因为JSON的格式有不同的限制，这里以二维表格为例，在JSON中一个对象是用{}括起来的，对象可以组成数组，用[]括起来，JSON反序列化的API解析的是单个对象，因此需要注意自己处理的JSON文件的格式是什么，特别是要将数组转化为对象的List，单独对每个对象进行反序列化，不然就会出错。</p>
<p>我这里生成的JSON文件都是默认数组，因此尽管这里文件中只有一个对象，还是用[]括起来了。它生成的数据类是：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AIConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> NAME &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> HP &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> ATK &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> DEF &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Root</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> AIConfig AIConfig &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，后面Root类也可以不要，声明为public以后不使用属性也能够获得类，自动生成的数据类为了方便JSON的嵌套会额外加一个Root，实际上需要的就是匹配的数据类就行了。</p>
<p>使用newtonsoft来解析，Unity自带的方法不足够解析嵌套的JSON文件，所以我们采用这个第三方插件完成，这个是最推荐的，还有另外两个方法：JsonLit和JsonUtility，后者是Unity自带的，一般情况也足够使用。</p>
<ul>
<li>JsonConvert.DeserializeObject(json);将一个json对象的字符串解析成一个类对象</li>
<li>JsonConvert.SerializeObject;将一个类对象转化成一个json字符串对象</li>
</ul>
<p>通过上面的API可以实现序列化和反序列化了，我们先读取json文件：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//json路径</span></span><br><span class="line">      <span class="built_in">string</span> filePath = <span class="string">&quot;Assets/Resources/Data/Config_AI.json&quot;</span>;</span><br><span class="line">      <span class="comment">//如果没找到就返回</span></span><br><span class="line">      <span class="keyword">if</span>(File.Exists(filePath) == <span class="literal">false</span>) </span><br><span class="line">      &#123;</span><br><span class="line">          Debug.Log(<span class="string">&quot;File not Found&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//读取文件为字符串</span></span><br><span class="line">      <span class="built_in">string</span> json = File.ReadAllText(filePath);</span><br></pre></td></tr></table></figure>
<p>读取以后解析，如果是一个{}包括的JSON对象，直接使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AIConfig root = JsonConvert.DeserializeObject&lt;AIConfig&gt;(json);</span><br></pre></td></tr></table></figure>
<p>但是我们这里是JSON数组，因此必须要使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;AIConfig&gt; roots = JsonConvert.DeserializeObject&lt;List&lt;AIConfig&gt;&gt;(json);</span><br></pre></td></tr></table></figure>
<p>这样才能单独处理每个对象，否则会报错。之后json文件的配置信息就已经读取到数据类AIConfig中了，你可以通过拷贝方法来完成赋值或者初始化，这就涉及到深拷贝和浅拷贝的知识了，后面用到再说，现在直接等号赋值就完了。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(五)-制作一个2D游戏</title>
    <url>/2023/04/15/unity5/</url>
    <content><![CDATA[<p>这一节我们继续制作2D游戏，添加飞弹系统及其动画，然后利用Cinemachine组件来便捷地控制摄像机。</p>
<span id="more"></span>
<p>在导入的素材中，主角会发射机械零件以修复机器人，之后机器人就不会对角色造成伤害了。经过前面的学习，你肯定想到我们接下来要做的事情有以下几个：</p>
<ul>
<li>角色发射零件的脚本；</li>
<li>角色发射零件的动画；</li>
<li>机器人和零件的碰撞检测；</li>
<li>机器人击中后被修复的动画；</li>
<li>更改机器人状态。</li>
</ul>
<p>下面我们按这个流程来介绍如何操作。</p>
<h1 id="飞弹预制件及脚本"><a href="#飞弹预制件及脚本" class="headerlink" title="飞弹预制件及脚本"></a>飞弹预制件及脚本</h1><p>首先在Art/Sprites/VFX中找到零件图片CogBullet，修改其PPX属性(前面介绍过)调整到合适的大小，然后将其保存为预制件到Prefabs文件夹下(忘记了？最简单的方法就是添加到Hierarchy中再拖动到Prefabs文件夹，之后删除该游戏对象即可，因为我们接下来所有操作都要在预制件上进行)。</p>
<p>为了进行碰撞检测和实现发射、碰撞的效果，分别要添加Box Collider 2D组件和Rigidbody 2D组件，将Rigidbody 2D中的Gravity scale设置为0。将这个预制件名称修改为Projectile，并添加一个同名脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Rigidbody2D rigidbody;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start is called before the first frame update</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    rigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Launch</span>(<span class="params">Vector2 dir, <span class="built_in">float</span> force</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rigidbody.AddForce(dir * force);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">$&quot;子弹碰撞到了<span class="subst">&#123;collision.gameObject&#125;</span>&quot;</span>);</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你就明白为什么一定要添加刚体组件了，我们发射的方式是调用刚体组件的AddForce方法，这个方法会施加一个瞬间的力让游戏对象进行移动，从而达到发射的效果，这样更符合实际，你要是喜欢用移动的方式来编写也可以，不过不好说会不会产生问题。</p>
<h1 id="角色飞弹系统"><a href="#角色飞弹系统" class="headerlink" title="角色飞弹系统"></a>角色飞弹系统</h1><p>现在有了发射的对象，就可以编写角色发射飞弹的代码了。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//创建游戏对象和发射力度，序列化到Unity</span></span><br><span class="line"><span class="keyword">public</span> GameObject ProjectilePrefab;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> force = <span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<p>序列化以后，脚本组件中会显示当前角色拥有的公开属性，注意到出现了一个需要绑定游戏对象的值ProjectilePrefab，我们把上一步创建的飞弹预制体赋值给他。完成之后在脚本中就可以通过ProjectilePreab访问这个预制体了，而并不在Start中创建，因为这个预制体的实例化是放在发射的脚本中实现的，不可能通过Start创建，所以我们进一步编写一个Launch方法给角色：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Launch</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	GameObject projectileObject = Instantiate(ProjectilePrefab, rigidbody2D.position + Vector2.up * <span class="number">0.5f</span>, 					Quaternion.identity);</span><br><span class="line">    </span><br><span class="line">	Projectile projectile = projectileObject.GetComponent&lt;Projectile&gt;();</span><br><span class="line">	projectile.Launch(lookDirection, force);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到其中出现了新的方法：</p>
<p><img src="/2023/04/15/unity5/16.png" alt></p>
<p>该方法用于实例化，或者说复制游戏对象，API接口如上图，这里我们编写的代码使用第四个接口，此时该实例化对象的父对象就是我们的角色，含义就是将传入的ProjectilePrefab对象进行实例化，生成位置是角色位置上移Vector2.up*0.5f = 0.5个单位的地方(就是半个格子高度)，并且不需要旋转，最后这个参数Quaternion.identity表示旋转量为(0,0,0,1)，分别表示旋转轴的x，y，z值和旋转角的余弦值。</p>
<p>完成后，让角色按下C键的时候发射，所以和移动脚本相似，在Update函数中添加调用这个方法的时机：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Input.GetKeyDown(KeyCode.C))</span><br><span class="line">&#123;</span><br><span class="line">	Launch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存代码并运行，发射飞弹，发现报错了，指出对象Projectile不存在。</p>
<h1 id="调试解决三个Bug"><a href="#调试解决三个Bug" class="headerlink" title="调试解决三个Bug"></a>调试解决三个Bug</h1><h2 id="报错为空"><a href="#报错为空" class="headerlink" title="报错为空"></a>报错为空</h2><p>这是教程给出的错误案例，我们用早前介绍的调试方法，给Instantiate语句加上断点，回到游戏按下C发射飞弹跳转到IDE，查看projectile变量，发现其中的rigidbody组件为空！</p>
<p>回想我们实现飞弹预制件脚本中Launch方法时，确实调用了rigidbody组件，该组件应该在Start方法中被赋值才对，这是因为刚创建该对象的时候不会调用Start方法，而是在下一帧调用，也就是说我们现在实例化了一个飞弹，但并没有立马运行Start方法。解决方法是，使用Awake方法代替Start，该方法会在创建对象后立即运行。</p>
<p>现在重新运行代码，不再报错null，但是发现飞弹刚发射的时候就消失了，因为飞弹创建后就碰到了人物，就被销毁了，如何解决？</p>
<h2 id="取消飞弹和角色的碰撞"><a href="#取消飞弹和角色的碰撞" class="headerlink" title="取消飞弹和角色的碰撞"></a>取消飞弹和角色的碰撞</h2><p>方法是使用Unity的图层功能，我们在整个窗口的右上角找到Layers，选择Edit Layers选项，在添加Character和Projectile图层：</p>
<p><img src="/2023/04/15/unity5/18.png" alt></p>
<p>然后将角色的Layers设置为Character，Projectile的Layers设置为Projectile。这一步就将两个图片放到了不同图层，再打开Edit/Project Settings/Physic2D，拉到最下面打开Layer Collision Matrix，去掉Character和Projectile两个图层之间的碰撞检测：</p>
<p><img src="/2023/04/15/unity5/17.png" alt></p>
<p>这样一来就不会检测这两个图层的物体了，保存后进行游戏，现在飞弹系统已经正常了。下一步我们添加动画。角色的飞弹动画前面已经做好了，所以我们在角色的Launch方法中加上animator即可：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">animator.SetTrigger(<span class="string">&quot;Launch&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>保存后运行游戏，看到动画也正常了。</p>
<h2 id="设置飞弹最大距离"><a href="#设置飞弹最大距离" class="headerlink" title="设置飞弹最大距离"></a>设置飞弹最大距离</h2><p>还有最后一个问题，飞弹如果没有碰到任何游戏对象，将一直存在下去，浪费游戏资源。因此我们现在给飞弹设限，如果飞弹的位置超过了某个值就将飞弹销毁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">	if(transform.position.magnitude &gt; 10.0f)</span><br><span class="line">	&#123;</span><br><span class="line">		Destroy(gameObject);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在飞弹系统才完善。</p>
<h1 id="机器人修复系统"><a href="#机器人修复系统" class="headerlink" title="机器人修复系统"></a>机器人修复系统</h1><p>设置一个bool值供脚本判断现在机器人的状态，如果机器人被零件击中，那么就将这个值修改，让Update和FixedUpdate方法通过这个值判断要不要退出方法。要判断当前碰撞到机器人的游戏对象是什么，还是要到OnCollisionEnter2D方法中实现。前面虽然我们使用了很多次，但是都是一样的模式，现在我们正式理解下这个方法，它需要一个参数collision2D，一个存储碰撞信息的类，其中具有以下对象：</p>
<p><img src="/2023/04/15/unity5/19.png" alt></p>
<p>可以看到它提供了一系列属性，因此我们这里要通过它获取碰撞对象的控制类，也就是RobotController。显然collision并没有这个属性，但是它的很多成员都有，这就是为什么我们有时要访问两次才能找到需要的属性。接下来思路就很清楚了，先对碰撞物体尝试获取RobotController，这个控制脚本组件只有机器人才具备，所以碰撞到其他东西的时候这个对象为空，那么我们不做处理；如果非空，说明就是碰撞到机器人了，此时让机器人执行一个修改自己状态的方法即可：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//机器人执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fix</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    is_fixed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//关闭机器人的刚体组件</span></span><br><span class="line">    rigidbody.simulated = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> Is_Fixed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(Is_Fixed == <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加到Projectile的方法中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RobotController1 robotController = collision.gameObject.GetComponent&lt;RobotController1&gt;();</span><br><span class="line">	<span class="keyword">if</span>(robotController != <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		robotController.Fix();</span><br><span class="line">	&#125;</span><br><span class="line">	Destroy(gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行游戏，发现击中机器人后，机器人停止运动，并且不会进行碰撞检测，不过动画仍然在播放，下面我们添加机器人修复后的动画。</p>
<p>因为机器人修复以后就没有其他状态了，所以这里让机器人从Move混合树中添加一个到修复以后动画的转换即可，在机器人调用了Fix方法的时候同时设置播放修复后动画的Trigger，同时这个转移没有Exit Time，那么机器人被击中后就会一直播放修复动画了。</p>
<h1 id="摄像机移动"><a href="#摄像机移动" class="headerlink" title="摄像机移动"></a>摄像机移动</h1><p>然后就是一个关键地方了，我们摄像机前面一直没有移动过，现在要让它跟随角色移动。你可能想到如何使用脚本控制摄像机移动了，这个很简单，我们这里则是采用一个第三方插件Cinemachine，用于简化跟踪摄像机的操作。</p>
<p>打开Package Manager，选择Unity Registry，安装Cinemachine包。</p>
<p>安装完成后在层级栏中右键，选择并创建Cinemachine/2D Camera，创建后得到一个名为CM vcam1的虚拟摄像机。虚拟摄像机用于添加不同的摄相机参数便于切换，有时需要使用多个摄像机来制作过场动画等内容，创建虚拟摄像机就可以提前设定参数，然后等到需要使用的时候将这个虚拟摄像机绑定到主摄像机上。</p>
<p>虽然我们这里创建的是2D Camera，但是其实也是一个虚拟摄像机，用来限制摄像机的位置和跟随，只需要将跟随对象赋值给创建的摄像机的Follow对象即可。测试一下，摄像机就跟随角色移动了。</p>
<p>然后还要限制摄像机的移动范围，当镜头超过地图边界就不再向外移动。找到Add Extension属性，选择CinemachineConfiner并添加。</p>
<p>再创建一个名为CameraConfiner的空游戏对象，添加碰撞体绑定到整个游戏区域，然后设置为新的图层Layer，在Project Settings/Physics 2D中取消这个Layer和其他任何Layer的碰撞检测，保存，将这个游戏对象赋值给刚才虚拟摄像机的Cinemachine Confiner/Bounding Shape 2D属性上，然后运行游戏，就做好移动功能了。摄像机跟随角色移动，并且不会超过游戏边界。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(四)-制作一个2D游戏</title>
    <url>/2023/04/10/unity4/</url>
    <content><![CDATA[<p>这篇博客我们继续学习2D游戏制作，上一节中学习了怎么调试代码，角色的基本控制等，这一节我们会进一步学习2D的碰撞检测，触发器的使用，2D的Animator。</p>
<span id="more"></span>
<h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><p>前面的学习中我们已经构建了基本的游戏场景，设定了伪透视等视觉效果，现在开始逐步添加场景和角色的交互。</p>
<h2 id="物体碰撞检测的处理"><a href="#物体碰撞检测的处理" class="headerlink" title="物体碰撞检测的处理"></a>物体碰撞检测的处理</h2><p>首先我们以游戏素材中的保险箱为例来说明如何让场景中的某些物体能够阻挡角色。首先不管是什么操作，我们将角色制作成预制件，保存到Prefabs文件夹中，然后选中，添加Rigidbody 2D和Box Collider 2D两个组件，修改刚体组件中的Gravity scale为0防止角色直接下落。</p>
<p>然后进一步修改Box Collider的包围盒，仅让人物的下半身进行碰撞检测，从而满足伪透视的效果：</p>
<p><img src="/2023/04/10/unity4/1.png" alt></p>
<p>同样的，将需要检测碰撞的物体添加Box Collider 2D，设置碰撞区域保证伪透视效果。注意保险箱不需要添加Rigidbody 2D，因为我们不需要让它实现碰撞效果，碰撞后不用改变位置，所以没有必要，只需要作为一个检测碰撞的区域存在，告知人物不能进入即可。</p>
<p>现在添加完成后运行游戏，发现几个问题：</p>
<ul>
<li>人物碰撞后会旋转；</li>
<li>人物碰撞时会抖动；</li>
</ul>
<p>旋转很好解决，在人物的Rigidbody 2D中，找到Constrains选项卡，勾选Freeze Rotation z，表示人物不能以z轴为中心旋转，这样就没问题了。</p>
<p>关键是第二个问题，人物抖动是因为角色移动的脚本逻辑是先移动，然后检测碰撞，退出碰撞区域，所以帧数调高的时候人物就一直重复这个进入-退出的过程，从而看起来是在抖动。本质在于我们之前的脚本使用的是Transformer组件控制移动，要进行两点改动才能让角色碰到碰撞区域时停止：</p>
<ul>
<li>在FixedUpdate方法中进行移动操作，原来的update函数仅获取键盘输入；</li>
<li>不再修改Transformer组件的位置参数进行移动，而是获得并修改rigidbody2D组件的position成员变量；</li>
</ul>
<p>完成后运行程序，发现问题解决了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RubyController</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rigidbody2D;</span><br><span class="line">    <span class="type">float</span> horizontal;</span><br><span class="line">    <span class="type">float</span> vertical;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前游戏对象的组件</span></span><br><span class="line">        rigidbody2D = <span class="built_in">GetComponent</span>&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> speed = <span class="number">0.1f</span>;</span><br><span class="line">    <span class="comment">// 每帧调用一次 Update</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        horizontal = Input.<span class="built_in">GetAxis</span>(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        vertical = Input.<span class="built_in">GetAxis</span>(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">FixedUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Vector2 position = transform.position;</span><br><span class="line">        position.x = position.x + speed * horizontal * Time.deltaTime;</span><br><span class="line">        position.y = position.y + speed * vertical * Time.deltaTime;</span><br><span class="line">        rigidbody2D.position = position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以不在FixedUpdate中直接获取输入信息，是因为这个函数调用的频率较低，默认50次/秒，显然低于我们设定的update，这样比较流畅，除非设备不能达到50帧/秒。</p>
<p>FixedUpdate的默认调用次数可以在项目设置中修改，50次就是间隔0.02s调用一次：</p>
<p><img src="/2023/04/10/unity4/2.png" alt></p>
<h2 id="Tilemap碰撞检测的处理"><a href="#Tilemap碰撞检测的处理" class="headerlink" title="Tilemap碰撞检测的处理"></a>Tilemap碰撞检测的处理</h2><p>Tilemap作为一个游戏对象显然也可以添加组件，但是它并不使用刚才的碰撞组件，而是要添加Tilemap Collider 2D。添加后所有的Grid都自行添加了碰撞检测，检测边界就是网格，当然对一些不想产生碰撞的Tile，可以在它的Inspector窗口中设置Collider Type为None，默认的Sprite就是将图片的四个边当成碰撞区域。</p>
<p><img src="/2023/04/10/unity4/3.png" alt></p>
<p>普通的Tile可以这样设置，我们之前用到的RuleTile也差不多，看起来更直观一点。</p>
<p><img src="/2023/04/10/unity4/4.png" alt></p>
<p>而且override的RuleTile会继承基类的collider，这点要注意。可以使用Advanced override RuleTile</p>
<h2 id="优化碰撞体"><a href="#优化碰撞体" class="headerlink" title="优化碰撞体"></a>优化碰撞体</h2><p>由于我们给很多方格都添加了碰撞体组件，因此产生了庞大的计算量，为了缩小这个计算量我们可以将这些碰撞体通过Composite Collider 2D构建一个整体的碰撞体，这个组件可以获取对象及子对象的所有碰撞体。</p>
<p>同样给Tilemap添加这个组件，发现还自动添加了2D刚体组件，然后在Tilemap Collider 2D组件中勾选Used by Composite，然后设置刚体组件中的Body Type为static，即静止不动。</p>
<p>这样就完成了优化。</p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>游戏中会有很多可交互对象，角色走到这个物品上就表示“吃到”这个物品，从而发生一些效果。这就要用到触发器了，前面我们已经接触过这个概念，它是碰撞体组件中的一个可选项，勾选以后碰撞体将仅检测是否进入区域而不进行碰撞效果的约束。下面我们以血瓶为例创建一个生命系统和可交互的血瓶物品。</p>
<h2 id="生命系统"><a href="#生命系统" class="headerlink" title="生命系统"></a>生命系统</h2><p>在RubyController中添加两个变量分别表示当前生命值和总生命值，添加一个方法接受参数amount并恢复等量生命：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生命值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> max_health = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> cur_health;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_health</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        cur_health = Mathf.Clamp(cur_health + amount, <span class="number">0</span>, max_health);</span><br><span class="line">        Debug.Log(<span class="string">&quot;当前生命值：&quot;</span> + cur_health + <span class="string">&quot;/&quot;</span> + max_health);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加触发器"><a href="#添加触发器" class="headerlink" title="添加触发器"></a>添加触发器</h2><p>现在逻辑就很清除，触碰血瓶的时候触发器生效，调用上面的方法，就实现了恢复效果。而要给血瓶添加的组件就是碰撞器Collider，并勾选Is Trigger。Unity为触发器检测提供的事件方法是OnTriggerEnter2D(Collider2D other)，该方法在每次检测到碰撞的时候被调用，往其中添加我们编写的方法就可以调用了，因此还要添加一个脚本调用这个事件方法。</p>
<p>最后，除法事件以后还要让组件消失，调用父类Object的方法destroy即可，其中参数为gameObject，是当前的游戏对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthCollectible</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> amount = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;发生碰撞的物体是：<span class="subst">&#123;collision&#125;</span>&quot;</span>);</span><br><span class="line">        RubyController r = collision.GetComponent&lt;RubyController&gt;();</span><br><span class="line">        <span class="keyword">if</span>(r != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r.cur_health &gt;= r.max_health) <span class="keyword">return</span>;</span><br><span class="line">            r.change_health(amount);</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后发现已经完成了血瓶系统。代码中还给出了根据组件获取对应游戏对象的方法，利用GetComponent&lt;&gt;泛型，可以返回对象，进而赋值给需要的实例。</p>
<p>除了上面这个触发器事件外，Unity还给出其他与触发器交互的事件方法，上面这个事件是进入触发器范围的时候执行一次，下面我们制作一个尖刺区域来让角色持续扣血，就不能用Enter而是Stay了：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RubyController r = collision.GetComponent&lt;RubyController&gt;();</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        r.change_health(amount);</span><br><span class="line">        Debug.Log(<span class="string">&quot;当前生命值&quot;</span> + r.Cur_health + <span class="string">&quot;/&quot;</span> + r.max_health);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样的话将在每次刷新的时候都进行一次判断，和FixedUpdate一致，因此角色掉血的速度会非常快，为了解决这个问题我们要认识一下RigidBody中的Sleeping Mode选项，三个子项的含义如下：</p>
<ul>
<li>Start Awake：初始时唤醒，也是默认选项；</li>
<li>Start Asleep：初始睡眠，可以碰撞唤醒；</li>
<li>Never Sleep：从不睡眠；</li>
</ul>
<p>这里睡眠的意思就是是否检测刚体碰撞，因为有时某些物体不发生移动，就不会发生碰撞，没必要每帧计算一次，所以就可以先挂起这部分刚体，称为睡眠。默认情况下选项表示该物体是唤醒的，但是一段时间之后就会睡眠，因此如果让我们的角色一直站在这个区域上，一段时间后就会停止刷新消息了。</p>
<p>清除这个问题之后我们再解决人物掉血太快的问题，方法就是让角色受伤后短暂无敌，下面是要修改的脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无敌效果</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> timeInvincible = <span class="number">2.0f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isInvincible;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> invincibleTimer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//其它...</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">this</span>.invincibleTimer = <span class="keyword">this</span>.timeInvincible;</span><br><span class="line">        <span class="keyword">this</span>.isInvincible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//其它...</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(isInvincible == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            invincibleTimer -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(invincibleTimer &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                isInvincible = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change_health</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isInvincible == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                isInvincible = <span class="literal">true</span>;</span><br><span class="line">                invincibleTimer = timeInvincible; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//其它...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路就是用全局变量作为状态依据，每帧计时器减少，当计时器归零的时候就是一次无敌结束，那么让无敌状态的变量重置为false，重置计时器，参与下一轮计时；用无敌状态变量作为依据判断要不要扣血，处于无敌状态直接返回，否则执行后面的操作。</p>
<p>个人感觉这里逻辑处理挺乱的，而且不够简洁，熟悉下脚本使用就行了，不必纠结。</p>
<p>要特别注意下Time.Deltatime这个东西，官方解释为上一帧到这一帧之间的时间间隔，我们又说Update和FixedUpdate调用的时间不一样，但是Time.deltatime会自动适应，也就是说不论什么函数中，这个值保证是两帧之间的时间间隔。</p>
<h1 id="Sprite进阶和动画"><a href="#Sprite进阶和动画" class="headerlink" title="Sprite进阶和动画"></a>Sprite进阶和动画</h1><h2 id="平铺Sprite"><a href="#平铺Sprite" class="headerlink" title="平铺Sprite"></a>平铺Sprite</h2><p>刚才我们用触发器实现了一个伤害区域，角色在区域内会每两秒损失一点生命值，但是如果我们想用多个Sprite伤害区域放到一起，手动操作的话太麻烦了，利用Sprite的平铺功能可以在缩放图像的同时进行区域的平铺，并且整个区域都具备我们刚才实现的逻辑。</p>
<ul>
<li>取消目标对象的缩放值；</li>
<li>Sprite Renderer中的Draw Mode更改为Tiled；</li>
<li>将目标对象使用的素材Sprite中的Sprite Mode/Mesh Type更改为Full Rect并Apply；</li>
</ul>
<p>现在可以使用矩形工具进行平铺了，并且如果觉得对象大小不合适也可以再次缩放。</p>
<p>不过要注意，碰撞检测区域并不会随着我们拖动矩形工具而更改，因此要重新设置。</p>
<h2 id="Sprite动画"><a href="#Sprite动画" class="headerlink" title="Sprite动画"></a>Sprite动画</h2><p>（这部分原本放在简单敌人制作完成后再进入，这里为了排版先说这个）</p>
<p>不管是敌人还是我们的角色，因为没有添加动画所以显得都很怪，现在我们来给他们添加上去。</p>
<p>首先选中敌人Robot，添加Animator组件，可以重新创建一个文件夹Animations，在其中存放动画相关的文件，注意本来也有一个Animations文件夹了，用于存储素材，这里再新建一个方便管理接下来要用的控制器。在该文件夹中创建AnimatorController，命名为Robot，然后在Robot预制件的Inspector窗口中修改Animator组件的Controller为这个Robot。</p>
<p><img src="/2023/04/10/unity4/7.png" alt></p>
<p>控制器创建好了，但是控制的动画还没创建好，可以想到二维的动画就是快速播放很多Sprite，这里提供的素材是每秒播放四张图片，我们先在Window中单机Animation/Animation打开动画窗口，然后选中一下Robot预制件，看到Animation窗口中出现Create字样，点击后看到可以创建anim文件，这就是动画切片，命名为RobotLeft。找到Art/Sprites/Characters/MrClockworkSheet，看到一系列图片，根据命名可知这些图片就是动画素材，称为关键帧，表示在某一帧播放这个图片就会让画面改变。</p>
<p><img src="/2023/04/10/unity4/6.png" alt></p>
<p>然后我们选中其中的WalkSides1到WalkSides4，拖拽进Animation窗口，就给RobotLeft这个动画切片创建好了素材。但是如果直接播放的话，会看到速度非常快，这是因为我们默认的Sample Rate是60，表示每秒采样60次，也就是每1/60s都会播放一个图片，这里我们有4个素材，将它改成4即可。</p>
<p>如果按钮找不到，点击动画窗口右上角的小点，勾选Show Sample Rate。</p>
<p><img src="/2023/04/10/unity4/8.png" alt></p>
<p>播放动画，看到了动画效果。</p>
<p>另外，在窗口中看到我们拖进来的四个图片依次排列在右边了，每个图片上面都有一个小点，这就是关键帧的标记，可以拖动这个标记来改变播放顺序；小点上面的数字表示进行到一秒的什么时候，0:0表示开始，往后都是1/4s，因为我们设置了Sample Rate为4。</p>
<p>我们现在要导入其中的walk素材，你可能会疑惑向右的图片在哪里，这里我们使用Unity的翻转功能，同样使用WalkSides，但是这里还要点击下面的Add Property，然后找到Flip x：</p>
<p><img src="/2023/04/10/unity4/9.png" alt></p>
<p>点击右边加号添加到其中，然后播放看看，就得到了向右走的Clip了。</p>
<h2 id="Animation-Controller"><a href="#Animation-Controller" class="headerlink" title="Animation Controller"></a>Animation Controller</h2><p>现在有了切片，就可以使用我们前面创建的Controller了，找到Robot的Controller，点击open，或者直接在Window中打开Animator窗口：</p>
<p><img src="/2023/04/10/unity4/10.png" alt></p>
<p>左侧是Layers窗口，用于3D管理，将动画用在角色的不同部分；Parameters控制变量，脚本可以用这个提供信息给Controller。</p>
<p>右侧就是动画状态机了，除了我们创建的Clip外还有三个状态：</p>
<ul>
<li>Entry：初始时；</li>
<li>Any State：任何时候；</li>
<li>Exit：退出时；</li>
</ul>
<p>因此Entry指向向左的切片，那么游戏开始就会直接播放向左的动画。</p>
<p>为了让这些动画能相互转换，我们使用混合树进行管理，根据移动方向播放。</p>
<h2 id="混合树"><a href="#混合树" class="headerlink" title="混合树"></a>混合树</h2><p>删除这四个状态，然后右键，Create State/From New Blend Tree，创建后双击Blend Tree进入该层，此时左侧发现Parameter中有一个Blend参数，将它删除后通过右上角的加号创建两个Float变量MoveX和MoveY，然后点击右侧窗口中的Blend Tree，更改Inspector中的Blend Type为2D Simple Directional，然后选择下面两个Parameter分别为刚才创建的两个变量。</p>
<p><img src="/2023/04/10/unity4/11.png" alt></p>
<p>再点击变量下面的加号，Add Motion Field，添加四次，分别选择我们刚才创建的4个Clip，并修改它们的值为图中这样：</p>
<p><img src="/2023/04/10/unity4/12.png" alt></p>
<p>PosX和PosY分别表示此时方向，可以拖动上面的红点，会发现上下左右四个区域对应添加的四个片段，所谓的混合就是完成了动画的过渡，例如移动到右边的时候向右的动画程度更多，那就播放。在一维的时候解释更清除，不过我也先不解释了，动画应该专门的部分。</p>
<h2 id="参数传递给Animator-Controller"><a href="#参数传递给Animator-Controller" class="headerlink" title="参数传递给Animator Controller"></a>参数传递给Animator Controller</h2><p>重新打开Robot的脚本，添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Animator animator;</span><br><span class="line"></span><br><span class="line">//start()</span><br><span class="line">animator = GetComponent&lt;Animator&gt;();</span><br><span class="line"></span><br><span class="line">private void FixedUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 position = transform.position;</span><br><span class="line">        if(vertical == true)</span><br><span class="line">        &#123;</span><br><span class="line">            position.y += Time.deltaTime * speed * direction;</span><br><span class="line">            animator.SetFloat(&quot;MoveX&quot;, 0);</span><br><span class="line">            animator.SetFloat(&quot;MoveY&quot;, direction);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            position.x += Time.deltaTime * speed * direction;</span><br><span class="line">            animator.SetFloat(&quot;MoveX&quot;, direction);</span><br><span class="line">            animator.SetFloat(&quot;MoveY&quot;, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rigidbody.MovePosition(position);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Animator作为Robot的一个组件，管理Robot的动画控制器，因此我们首先要获取这个组件，然后调用方法setFloat来给Controller中Blend Tree管理的变量赋值。运行游戏，发现动画已经正常了。现在我们用已经编辑好的AnimationController Ruby，完成Ruby的Idle，Run，Heat动画的转变。</p>
<p>除了添加移动的动画外，我们还要给角色添加受伤、射击的动画，切片制作就不说了，都是一摸一样的，通过预览调整到合适的效果。制作完成后依然用混合树进行管理，不同的是这次我们要管理的有四个混合树，最后在Animator中实现它们的转变：</p>
<p><img src="/2023/04/10/unity4/13.png" alt></p>
<p>素材中给出了制作好的Animator，可以参考制作。这里值得学习的主要是如何传递消息，前面我们用SetFloat传递浮点数，Animator中的混合树之间可以通过我们添加的参数作为Conditons来判断转变到哪个状态。Trigger是其中比较特殊的一类，Bool值类型的变量在使用SetBool后会保持变量值，除非重新设置；而Trigger则在设置后会重新变回默认值，也就是说使用Trigger作为Conditions的State Transition，仅在Trigger被设置的那一次进行播放，播放完了就不再执行这个状态的动画，退出到其他状态。</p>
<p>所以这里Trigger就很适合作为受击状态Hit的条件，Hit播放一次后无条件退回到Idle。Launch状态也一样。</p>
<p>另外，由于Animator中的参数范围是[-1,1]，所以要对变量最好进行归一化操作，再传递给Animator。</p>
<h2 id="Animator-Transition简介"><a href="#Animator-Transition简介" class="headerlink" title="Animator Transition简介"></a>Animator Transition简介</h2><p>接下来简单介绍一下状态转换的设置：</p>
<p><img src="/2023/04/10/unity4/14.png" alt></p>
<p>其中的功能如下，可以自行查阅Unity文档：</p>
<p><img src="/2023/04/10/unity4/15.png" alt></p>
<p>先了解，3D部分会重点使用这个，连带着会用Blender修改动画。</p>
<h1 id="敌人移动"><a href="#敌人移动" class="headerlink" title="敌人移动"></a>敌人移动</h1><p>有了前面的脚本，可以试着编写一个控制敌人自动移动的逻辑，这里可以自由发挥，我编写的逻辑是敌人上下移动，碰到任何物体都让敌人改变上下移动的方向，从而循环移动。当然也可以控制移动距离等内容，这都很容易，因此就不多说明了</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RobotController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> speed = <span class="number">5</span>;</span><br><span class="line">    Rigidbody2D rigidbody;</span><br><span class="line">    <span class="built_in">float</span> is_up;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rigidbody = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        is_up = <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 position = transform.position;</span><br><span class="line">        position.y += is_up * speed * Time.deltaTime;</span><br><span class="line">        rigidbody.position = position;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter2D</span>(<span class="params">Collision2D collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        is_up = -is_up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里本篇博客结束，我们已经掌握了人物控制和敌人控制的基本做法，它们现在拥有了动画效果，并且具备生命值交互系统，剩余的制作过程请看下一篇系列博客。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(六)-制作一个2D游戏</title>
    <url>/2023/04/17/unity6/</url>
    <content><![CDATA[<p>实际上我们的游戏基本功能都实现了，游戏对象逻辑上的处理已经完成，现在我们来添加两个视觉上的东西，粒子系统和UI。粒子系统说白了就是用来做特效的，例如是烟、雾、水等，这些动画效果如果用Sprite的话效果不好。UI就不用多说了，前面的生命值系统没有血条看起来很奇怪，我们还会连带制作一个对话系统。</p>
<span id="more"></span>
<h1 id="什么是粒子系统？"><a href="#什么是粒子系统？" class="headerlink" title="什么是粒子系统？"></a>什么是粒子系统？</h1><p>在Unity中，粒子系统是一种用于创建各种形态的粒子效果的工具。粒子系统可以用于模拟火、爆炸、烟、水流、火花、落叶、云、雾、雪、尘、流星尾迹等现象，也可以用于创建抽象的视觉效果。粒子系统由粒子发射器、粒子动画器和粒子渲染器三个独立的部分组成。粒子发射器用于控制粒子的发射位置、速度、方向和数量等属性，粒子动画器用于控制粒子的生命周期、大小、颜色、旋转和形状等属性，粒子渲染器用于将粒子渲染到屏幕上。Unity中自带了强大的粒子特效编辑器，可以用于游戏的特效制作。    </p>
<p>Unity还有一个类似的系统叫Visual Effect Graph，用于更大规模的粒子特效，使用可视化编程来完成。我们这里制作的效果比较简单，使用粒子系统就够了。</p>
<p>所谓粒子就是大量的小型图片，具有自己的方向等属性，用来模拟流体实体。我们将使用粒子系统中的内置粒子系统，它可以用脚本实现粒子的控制和交互。</p>
<h2 id="使用粒子系统"><a href="#使用粒子系统" class="headerlink" title="使用粒子系统"></a>使用粒子系统</h2><p>粒子系统一样需要素材才能实现，找到VFX中的ParticleSpritesAtlas，设置为Sprite Mode为Multiple，然后打开Sprite Editor进行分割到4*4的格子中，就得到了6个特效件。</p>
<p><img src="/2023/04/17/unity6/1.png" alt></p>
<h3 id="Texture-Sheet-Animation"><a href="#Texture-Sheet-Animation" class="headerlink" title="Texture Sheet Animation"></a>Texture Sheet Animation</h3><p>在层级栏中右键创建Effect/ParticleSystem并重命名为SmokeEffect，在它的Particle组件中找到Texture Sheet Animation并勾选以启用，调整Mode为Sprites并添加到两个图片，将刚才分割的图片中的两个烟雾赋值进去即可。</p>
<p><img src="/2023/04/17/unity6/2.png" alt></p>
<p>这样设置以后粒子系统不断播放第一个图片，而没有第二个，我们希望随机播放这两个图片以实现烟雾的效果，因此修改Start Frame为Random Between Two Constants，设置第二个参数为2，表示图片索引区间为[0,2)，这是看到烟雾效果会不断变化了，两个图片交替出现，但是发出以后图片也会改变。</p>
<p>为了让图片产生后就不变成另一个图片，现在设置Frame Over Time，此时选项为Curve，表示当前值随着曲线变化，点击线条后底部出现函数图，横轴表示时间，纵轴表示当前值，也就是图像序号，将右边最高点删除，那么Frame不会变化，此时图片产生后就不会更改了。</p>
<h3 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h3><p>Angle改为5，表示圆锥体顶角大小；Radius改为0，表示底部半径大小。</p>
<h3 id="Start-speed"><a href="#Start-speed" class="headerlink" title="Start speed"></a>Start speed</h3><p>选择Random Between Two Constants，上下界设置为0.5和1，表示产生粒子的速度；</p>
<h3 id="Start-Size"><a href="#Start-Size" class="headerlink" title="Start Size"></a>Start Size</h3><p>选择Random Between Two Constants，上下界设置为0.3和0.5，表示粒子的大小。</p>
<h3 id="Start-Lifetime"><a href="#Start-Lifetime" class="headerlink" title="Start Lifetime"></a>Start Lifetime</h3><p>同上，上下界设置为1.5，3，表示粒子的声明周期。</p>
<h3 id="Color-Over-Lifetime"><a href="#Color-Over-Lifetime" class="headerlink" title="Color Over Lifetime"></a>Color Over Lifetime</h3><p>勾选后，点击白条出现Gradient Editor，渐变编辑器，然后看到上下左右四个点，左边表示起点，右边表示结束，上侧两个点表示透明度alpha，将右边的alpha调整为0，就实现图片逐渐透明的效果。下方的两个点则是颜色改变，可以自己探索。</p>
<h3 id="Size-Over-Lifetime"><a href="#Size-Over-Lifetime" class="headerlink" title="Size Over Lifetime"></a>Size Over Lifetime</h3><p>意思和上一个差不多，随时间改变粒子大小，我们选择Size方式为Curves，修改曲线：</p>
<p><img src="/2023/04/17/unity6/3.png" alt></p>
<p>让粒子随着时间变小。</p>
<h3 id="Simulate-Space"><a href="#Simulate-Space" class="headerlink" title="Simulate Space"></a>Simulate Space</h3><p>选择World，表示不以局部坐标模拟物理效果，操作以后烟雾就可以随着机器人的移动而模拟了。</p>
<p>我们基本就使用了这些方法，它们有类似的操作方式，篇幅限制很难全部说明一遍。</p>
<h2 id="脚本控制粒子系统"><a href="#脚本控制粒子系统" class="headerlink" title="脚本控制粒子系统"></a>脚本控制粒子系统</h2><p>我们经过前面的操作后得到了一个特效件，现在拖进Prefabs中做成预制件，然后再添加给Robot的预制件，这样一来机器人移动也会让特效跟着移动，就实现机器人冒烟的特效了。但是机器人被修复以后还是会冒烟，所以我们要用脚本控制特效。</p>
<p>前面我们制作飞弹的时候为了让飞弹不能无限飞行，在一定距离后就用Destroy()方法将其销毁了，这里的粒子特效件作为一个游戏子对象，可以在机器人被修复的时候直接摧毁，因此我们要做的就很简单了，首先获取到这个游戏对象，然后同样在机器人的Fix方法中销毁它即可。</p>
<blockquote>
<p>注意这里指的是层级栏中的特效，而不是预制件，因为我们之前做飞弹的时候使用GameObject类型接受预制件从而直接创建出来，自行销毁，这里是原先存在不用创建，需要用ParticleSystem类型获取以后等待时机摧毁，使用预制件的话本来就不存在这个实例化的游戏对象，就肯定不能摧毁了)</p>
</blockquote>
<p>另一个方法是调用粒子系统的Stop()方法，这样就会使得生命周期没有结束的粒子继续播放，不会像刚才那样直接凭空消失了。</p>
<p>最后我们有时想制作只播放一次的特效，那么需要进行三个操作：</p>
<ul>
<li>取消勾选looping；</li>
<li>Duration设置为希望的播放时间；</li>
<li>Stop Action设置为Destroy；</li>
</ul>
<p>这样以后特效将在播放时间结束后自动销毁，为了让粒子不随着时间而是一次性产生，我们还要进行两个操作：</p>
<ul>
<li>Emission的Rate Over Time设置为0；</li>
<li>使用Emission的Bursts属性，用叫号添加一个Burst，设置爆发的各项属性；</li>
</ul>
<p>此时就可以创建一个只进行一次的特效了。不过问题是这个特效肯定需要某些时候创建，例如吃血瓶的时候，所以不能直接放在层级栏中，我们将他做成预制件，然后在脚本中用公开的序列化ParticleSystem类型来接受，并在调用角色加血方法的时候实例化这个特效。由于特效件设置了会自行销毁，所以不用管理Destroy方法，创建了就相当于播放一次，和动画类似。</p>
<h1 id="什么是UI？"><a href="#什么是UI？" class="headerlink" title="什么是UI？"></a>什么是UI？</h1><p>User Interface，简称UI，是提供给玩家进行游戏交互的面板，在Unity中由于版本原因有多种UI系统：</p>
<ul>
<li>UI Toolkit：一个较新的UI系统，它基于标准的Web技术，旨在优化跨平台的性能，首选；</li>
<li>Unity UI（UGUI）：是较旧的UI系统，仍然可用，但已被视为过时，市面上很多游戏使用这个UI系统；</li>
<li>IMGUI：一种基于函数调用的GUI系统，也称为“Immediate Mode”GUI系统，优点是易于使用和快速，但缺点是不够灵活和可扩展；</li>
</ul>
<p>所以一般来说现在做游戏首先选UI Toolkit，只是可能会缺少功能，实在没办法再使用UGUI。我们这里用UGUI做个了解即可。</p>
<p>学习方面三个都要看，IMGUI因为是纯代码的，自己写界面调试比较方便，然后前两个就看情况使用。</p>
<h2 id="使用UGUI"><a href="#使用UGUI" class="headerlink" title="使用UGUI"></a>使用UGUI</h2><p>层级栏中创建UI/Canvas，看到还自动创建了一个EventSystem对象，用于检测用户事件，这两个都不用调整，我们仅使用最基本的功能。右键创建的画布Canvas，再次添加UI/Image，得到一个子对象，将UI文件夹中的UIHealthFrame图片赋值给Image的Source Image属性，就看到了血条显示，但是血条是变形的，点击Image组件中的Set Native Size来使图片恢复原本的比例。</p>
<p>现在图片又太大了，我们按住shift来等比例缩小图片，并将图片摆放到画布的左上角，可以在Game视图中进行查看当前设置。</p>
<p>现在我们来介绍锚点，在Unity中，锚点是指UI元素相对于其父对象的位置和样式。锚点的取值范围为0（父对象左下角）到1（父对象右上角），锚点是UI元素与父对象之间的桥梁，子对象的位置和大小会随着父对象的变化而变化。锚点中心是四个三角形的中心，如果四个三角形在一起，那么表示画布的子对象会随着锚点中心进行相同的移动，保持距离不变；如果锚点的四个三角形不在一起，它们分别对应矩形的四个顶点，让顶点和自己的距离不变，从而进行拉伸操作。</p>
<p>使用锚点的原因是设备分辨率不同，导致摄像机显示的大小不同，如果固定UI可能会导致错误的显示效果，例如让锚点设置为画布正中心时，左上角的UI元素和锚点保持距离不变，缩放画布会导致UI元素跑到外部。这时让锚点位于画布的左上顶点，就不会错误了。</p>
<p><img src="/2023/04/17/unity6/4.png" alt></p>
<p>解决这个问题后我们再将头像添加到蓝色圆圈上，UI文件夹中找到Portrait，用同样的方法给UIHealthFrame添加子图片对象，设置到合适的位置。</p>
<p>此时尝试缩放UIHealthFrame，发现头像不会跟着缩放，这还是锚点的问题，每一层都有自己的锚点，UIHealthFrame的锚点在他自己的中心，那么头像对应的四个顶点对应到UIHealthFrame的中心后，无论怎么变化都只保证距离不变，所以记住锚点和当前图片的关系，把锚点拖到头像图片的四个点上就好了。</p>
<p><img src="/2023/04/17/unity6/5.png" alt></p>
<h2 id="遮盖生命条"><a href="#遮盖生命条" class="headerlink" title="遮盖生命条"></a>遮盖生命条</h2><p>原理是用另一个图片来遮盖血条，更改遮盖图片的大小来实现血条加减的操作。给UIHealthFrame再添加一个Image，这就是遮盖层，让这个白色的矩形刚好盖住右边空着的血条。</p>
<p>思考一下这里血条减少怎么设置，我们希望的效果是当生命减少时遮盖层右边往左边靠过来，也就是缩放的时候左边不动，右边减少，那么就是说，希望缩放的时候让坐标保持不动，因此可以将Mask的pivot调整到最左边中间。当前pivot在中心，缩放的话会使得图片两边同时向中间缩放，放在最左边就可以让右边往中间靠拢了。</p>
<p><img src="/2023/04/17/unity6/6.png" alt></p>
<p>现在给Mask添加一个图片子对象，用我们的美术素材填充Mask的区域，把UIHealthBar拖进去，如果要让这个子对象填充父对象Mask，并且图片的四个顶点和这个Mask一样的位置就好了，我们再次打开锚点设置Anchor Presets，看到右下角表示将锚点设置到父对象的四个顶点，并且按下alt表示同时设置顶点位置，就实现了填充。</p>
<p>虽然将刚才的锚点设置到Mask的四个顶点后，血条会随着Mask变化，但是由于需要使用遮盖，血条对应的锚点最好设置到左上角，保证Mask缩放的同时血条不会直接缩放(因为直接缩放的话没必要添加遮盖了，这里遮盖是直接让血条消失而不是缩放)因此给Mask添加一个Mask组件，取消Show Mask Graphic，这样一来，我们调整Mask，发现Mask会盖住血条，也就是说Mask会显示目前盖住的部分，没盖住的部分就会消失。</p>
<p><img src="/2023/04/17/unity6/7.png" alt></p>
<h2 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h2><p>下面我们控制Mask缩放。创建脚本UIHealthBar，添加代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIHealthBar</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIHealthBar Instance &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Image mask;</span><br><span class="line">    <span class="built_in">float</span> originalSize;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">        originalSize = mask.rectTransform.rect.width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="built_in">float</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mask.rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, originalSize * <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里采用了单例模式，确保只有一个实例被创建并且可以全局访问来避免多个实例之间的冲突和资源浪费，同时也方便其他类和对象访问和使用。</p>
<p>另外这里要记得添加UnityEngine.UI的命名空间，因为要使用image。</p>
<p>最后使用了新的接口rectTransform.SetSizeWithCurrentAnchors，用来根据锚点改变矩形横纵边长的大小。</p>
<p><img src="/2023/04/17/unity6/8.png" alt></p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(八)-导入人物模型和绑定骨骼动画</title>
    <url>/2023/04/20/unity8/</url>
    <content><![CDATA[<p>到这里我们基本了解unity和一些重要API的使用了，有素材的话可以试着自己制作2D游戏，但是2D游戏不管是逻辑上还是素材上都要比3D游戏简单很多，例如2D游戏的动画仅仅是快速播放图片，而3D游戏中我们则需要对动画进行深入了解，知道一些基本概念。这一篇博客会指导你将任何fbx模型导入到Unity中，并用真正的动画系统让这个模型动起来，然后就能继续制作3D游戏了。</p>
<span id="more"></span>
<h1 id="导入模型"><a href="#导入模型" class="headerlink" title="导入模型"></a>导入模型</h1><h2 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h2><p>3D模型通常是建模师使用3D Max，Blender等建模软件制作的游戏资产，从编程角度来说就是一系列点和面坐标、纹理构成的3D对象，一般有以下格式：</p>
<ul>
<li>fbx是一种比较通用的格式，可以在多个3D软件之间进行导入和导出，支持多种功能，如动画、材质、光照、纹理等。</li>
<li>obj格式是一种比较简单的格式，只包含模型的顶点和面信息，不支持动画和材质等高级功能。</li>
<li>3ds格式是3D Studio Max软件的专用格式，支持多种功能，如动画、材质、光照等。</li>
<li>PMX是一种用于MikuMikuDance（MMD）的模型文件格式，它是MMD中的一种新型模型格式，通常包含模型的顶点、面、纹理、骨骼、材质、动画等信息。</li>
</ul>
<p>Unity支持的模型格式是fbx，因此我们找到的模型必须要转换为fbx格式才能导入到unity中，为此后面我们会介绍一个Blender的插件及其使用方法。</p>
<p>Fbx文件中包含的信息主要包括以下内容：</p>
<ul>
<li><strong>网格 Mesh :</strong> 表示 3D 物体的 形状 ;</li>
<li><strong>材质 Material :</strong> 表示 3D 物体的 表面特性 ;</li>
<li><strong>纹理贴图 Texture :</strong> 定义 3D 物体 表面的 像素颜色 , 一般是一张图片 ;</li>
</ul>
<p>结合我们之前学习图形学的经验可以知道，这里Material定义了物体表面的反射率、颜色、透明度等信息，纹理则是描述物体表面信息的另一个属性，例如贴图等。Unity中的流程是，将纹理应用到材质上，然后材质应用到模型上，最后还可以编写Unity Shader添加更多效果，在另一个系列的博客《Unity和Shader入门》中可以查看这部分内容。</p>
<h2 id="模型素材和动画的获取"><a href="#模型素材和动画的获取" class="headerlink" title="模型素材和动画的获取"></a>模型素材和动画的获取</h2><p>以下网站是我们后面获取素材的主要途径：</p>
<ul>
<li>Adobe旗下的网站<a href="https://www.mixamo.com/#/">Maximo</a>提供了一系列免费的白模(没有提供材质的模型)，但是这个网站最主要的还是提供了大量的动画素材，我们后面的动画都在这个网站上获取；</li>
<li><a href="free3d.com">free3d.com</a>提供了很多带有材质的完整模型；</li>
<li><a href="https://www.aplaybox.com/">模之屋</a>中有很多MMD制作需要的二次元模型，但是都是pmx格式，需要进一步处理。</li>
<li>VRoid Studio是一款免费的3D角色建模软件，可以用于创建自己的3D角色模型，类似捏脸一样可以快速导出；</li>
<li>Adobe Fuse是由Adobe公司开发的3D人物制作工具，可以用于创建自己的3D角色模型，也是捏脸。</li>
</ul>
<p>从上面的网站基本可以满足我们需要了，关于动画我们后续可能还会介绍使用IK进行快速制作。</p>
<h2 id="pmx到fbx格式的预处理"><a href="#pmx到fbx格式的预处理" class="headerlink" title="pmx到fbx格式的预处理"></a>pmx到fbx格式的预处理</h2><p>现在我们在模之屋上找一个角色模型并下载解压，得到文件夹中有一个pmx模型文件，一个Texture纹理文件夹，还可能有其他文件，不过我们不关心，只需要这两个就能使用了。其中pmx文件就是我们的白模，Teture文件夹提供了模型对应的纹理。</p>
<p>现在我们在官网安装好Blender，最好是2.93版本，否则可能不支持插件。</p>
<p><img src="C:/Users/16677/AppData/Roaming/Typora/typora-user-images/image-20230420201308939.png" alt="image-20230420201308939"></p>
<p>安装完成后到<a href="https://github.com/absolute-quantum/cats-blender-plugin">GitHub</a>上点击上图中的蓝色字体下载我们要使用的Cats插件压缩包。Cats插件支持MMD格式的模型导入，可以将MMD格式的模型导入到Blender中进行编辑和优化，然后导出为fbx格式的模型文件，还提供了丰富的工具和功能，如自动绑定骨骼、自动修复模型、自动优化模型等，可以大大提高模型的制作效率和质量。</p>
<p>得到的Zip文件不要解压，在Blender中打开Edit/Preferences/Add-ons，点击右上角的Install，找到刚才下载的压缩包，点击Install Add-on即可安装。</p>
<p><img src="/2023/04/20/unity8/2.png" alt></p>
<p>然后到Blender右侧的侧边栏中找到小箭头(上图红色圆圈中的)并点击打开新的侧边栏，看到如下图所示就是安装成功了。</p>
<p><img src="/2023/04/20/unity8/3.png" alt></p>
<p>接下来我们点击CATS，打开插件界面，点击Import Model，然后找到我们刚才下载的pmx文件，等待导入，成功后角色就在场景中了，但是我们发现模型有些问题，既没有纹理，模型节点也不是按照英文命名。</p>
<p>那么首先我们点击Misc中的Shadeless，使用卡通渲染，发现已经有颜色了。</p>
<p>接着我们点击Fix Model，这个功能主要是由于MMD格式的模型与Blender的模型格式不同，可能会出现一些问题，如骨骼不对齐、材质丢失等。使用Cats插件导入MMD格式的模型后，可以使用Fix Model功能来修复这些问题，以便更好地在Blender中编辑和导出模型。这里使用这个功能可以帮助我们解决命名问题，并且还可以将多余的骨骼删除，将多个节点的Mesh合并到一个名为Body的Mesh等，具体我也不是很清楚，只需要知道Fix Model可以帮助优化模型即可，其实前面的卡通渲染也可以通过这里的Fix Model完成。</p>
<p><img src="/2023/04/20/unity8/4.png" alt></p>
<p>点击后等待运行，发现角色的纹理也被正确识别上去了，现在我们得到了一个包含正确骨骼，材质，纹理信息的模型，点击Export Model，命名，然后点击Export FBX，就得到了FBX模型。</p>
<h2 id="将FBX模型和贴图导入Unity"><a href="#将FBX模型和贴图导入Unity" class="headerlink" title="将FBX模型和贴图导入Unity"></a>将FBX模型和贴图导入Unity</h2><p>将FBX文件和Texture文件拷贝到Unity中(这里我们使用的是3D URP模板，因为后面的Shader会使用URP)，你可以创建一个名为Models的文件夹来存放这些模型文件，如果没有Texture文件夹，那么模型就是白模。</p>
<p>接着选中我们的FBX模型，点击rig属性，修改Animation Type为Humannoid，这意味着我们选择将导入模型的动画类型设置为人形，这可以保证模型的骨骼是人体的五个骨骼部分，你可以点开下图中的最右侧绿色小人，然后选择Configure Avatar来查看，保证骨骼是正确绑定的。</p>
<p><img src="/2023/04/20/unity8/5.png" alt></p>
<p><img src="/2023/04/20/unity8/7.png" alt></p>
<p>拷贝后模型自动识别了贴图，在预览中可以查看。但是渲染方式是不正确的，因为从图形学来说，贴图归贴图，这里不是什么高级的法线贴图，渲染方式还是要看Shader和材质，我们贴图放到Texture中给FBX找，但是材质现在就不一样，它已经在FBX中了，了解Unity Shader的同学应该知道Shader要应用在材质上才能生效。而Unity又不是建模软件，不能对FBX进行修改，也就意味着其中的材质我们也不能修改。</p>
<p>因此我们要把材质导出来，点击模型文件，选择Materials属性，将Loaction设置为Use External Materials(Legacy)并Apply，此时材质会自动放到Materials文件夹中；或者点击Extract Materials，在同级文件夹创建一个Material文件夹，把导出的材质存放到这里。（这里前一种方式可能会出现头发全黑的问题，应该是材质命名的问题，建议使用第二种方式修改）</p>
<p>到这里我们导入模型已经基本完成了，模型，骨骼，纹理，材质都已经导入，将模型创建成游戏对象，下面我们来说一说怎么修改材质才能达到希望的渲染效果。</p>
<h1 id="设置渲染效果"><a href="#设置渲染效果" class="headerlink" title="设置渲染效果"></a>设置渲染效果</h1><p>说到渲染，Unity Shader肯定是不可避免的，不过怎么写一个Shader在本系列中不重要，感兴趣可以看另外一个系列《Unity和Shader入门》。我们这里使用<a href="https://github.com/ColinLeung-NiloCat">ColinLeung</a>大佬编写好的Shader即可，GitHub地址是<a href="https://github.com/ColinLeung-NiloCat/UnityURPToonLitShaderExample，直接下载压缩包并解压，然后在Unity中创建Shader文件夹，把得到的文件全部拖进去。">https://github.com/ColinLeung-NiloCat/UnityURPToonLitShaderExample，直接下载压缩包并解压，然后在Unity中创建Shader文件夹，把得到的文件全部拖进去。</a></p>
<p>然后回到材质，我们进入Material文件夹，全选，将它们的Shader都设置为刚刚导入进来的SimpleURPToonLitExample，保存；然后由于这种渲染需要对面部进行特殊处理(不处理的话面部阴影会被头发遮盖，导致脸黑)，所以找到面部的材质，将右边Is Face勾选，此时看到场景中的人物已经是卡通渲染的了，脸也亮起来了。下面第一张图是没有勾选的，第二张图已经勾选。</p>
<p><img src="/2023/04/20/unity8/8.png" alt></p>
<p><img src="/2023/04/20/unity8/9.png" alt></p>
<p>这样我们就实现了卡通实时关照了，值得一提的是，这个Shader项目也很值得学习，涉及各个方面的内容，之后在另一个系列中也会详细介绍。</p>
<p><img src="/2023/04/20/unity8/10.png" alt></p>
<h1 id="动画系统"><a href="#动画系统" class="headerlink" title="动画系统"></a>动画系统</h1><h2 id="3D动画系统简介"><a href="#3D动画系统简介" class="headerlink" title="3D动画系统简介"></a>3D动画系统简介</h2><p>Unity中的动画以骨骼为核心，骨骼在程序中定义为一个结构体，具有一个矩阵M表示当前骨骼位置，一个字符串表示骨骼名称，还有一个指向父骨骼的指针，这种骨骼定义将模型分为不同的部分，而且骨骼之间能相互带动，通过图形学基础的学习我们知道矩阵M的连乘就可以表示子骨骼的位置变化。</p>
<p>通过骨骼动画，动画师只需要做出动画的关键帧，然后Unity会根据这部分内容进行插值，得到完整的动画效果，大大减小了动画师的工作量，而且由于骨骼之间的联动动画也比较自然。</p>
<p>而模型是由很多三角性面组成的，在有了骨骼之后，就需要进行蒙皮，将模型绑定到骨骼上，绑定好之后组成模型的这些三角型面就可以随着骨骼进行运动了，三角型面的位移也是通过骨骼来获取。</p>
<p>除此外，还有两种程序向动画，FK(Forward Kinematics)和IK(Inverse Kinematics)，即正向运动学和反向运动学，分别表示以父骨骼为首进行的动画和以子骨骼为首进行的动画。这种技术是完成地形和角色动画交互的关键，例如防止角色在斜坡上不会自动纠正动作，或者攀爬中和地形进行交互。</p>
<h2 id="绑定动画骨骼"><a href="#绑定动画骨骼" class="headerlink" title="绑定动画骨骼"></a>绑定动画骨骼</h2><p>3D动画和2D动画的最大区别就是骨骼动画，我们要让模型动起来就要先确定模型的骨骼Avatar。</p>
<p>我们之前使用2D的动画系统制作动画效果，使用Animation Clip作为素材，添加到Blend Tree中管理，然后使用Animator中的Animation Controlller进行播放控制，其实在3D动画中也是类似的，只是我们制作Animation Clip不再使用图片快速播放，而是需要将绑定到骨骼上。</p>
<p>听起来很复杂，但是我们这一部分已经通过CATS插件完成了，角色的骨骼正确绑定到模型上，而将骨骼和动画绑定就只需要将这个骨骼赋值给Animator组件的Avatar属性就完成了，你可能还记得我们当时并未使用这个属性，原因就是2D动画并不需要绑定骨骼。</p>
<p><img src="/2023/04/20/unity8/11.png" alt></p>
<p>可以看到我们创建的模型已经自动添加了Animator组件并绑定了骨骼。</p>
<p>其他操作则完全和2D动画类似，我们依然要设计状态机来判断动画的播放时机，使用Animator的一系列API来进行脚本和动画的同步。</p>
<h2 id="制作3D-Animation-Clip"><a href="#制作3D-Animation-Clip" class="headerlink" title="制作3D Animation Clip"></a>制作3D Animation Clip</h2><p>现在来说一下怎么获取动画素材，在前面介绍的网站Maximo上提供的动画需要配合模型进行导出，也就是说我们就算下载了动画也还是得到fbx文件，只不过fbx文件中包含了动画Clip，那应该怎么提取呢？我们找到想要的动画以后(这里是一个Idle动画)，点击Download，看到以下界面：</p>
<p><img src="/2023/04/20/unity8/12.png" alt></p>
<p>Format表示下载格式，我们当然选择fbx(这里还提供了fbx for unity，不清楚有无差别，暂时没发现问题)；Skin表示是否需要连同角色一起下载，这里就是Without Skin；Frame per Second表示动画的帧率，帧率越高动画越精确，但是Unity会使用插值算法处理动画，所以不用选择太高；最后KeyFrame Reduction表示是否要删除变化幅度太小的动画关键帧，从而节省资源，这里也暂时不用。</p>
<p><img src="/2023/04/20/unity8/13.png" alt></p>
<p>将fbx文件导入Unity后，展开，看到需要的动画已经被识别成切片了，它的图标和我们之前2D学习中看到的一致。接着按照前面相同的操作处理这个fbx，修改为人形并Apply，打开Avatar查看骨骼是否正确。然后就可以使用这个动画了，将切片拖动到游戏对象上，Unity自动创建了一个和游戏对象同名的Animation Controller，并且赋值给Animator组件，还将这个Clip直接添加到Animator的动画状态机界面中了。</p>
<p>此时我们重新选择这个Idle动画，然后点击Edit，下面是一系列属性，勾选Loop Time，就能让这个动画循环播放，然后拉到最下面Apply，运行游戏，此时发现人物已经动起来了。</p>
<p>然后你应该知道怎么做了，使用Animation Controller对他们进行管理。</p>
<p>还要注意的是这里的Animation Clip因为是在fbx文件中的，所以是只读文件，要修改的话需要单独导出来，复制一份即可，此时重新添加给角色，就可以进行修改了。</p>
<p><img src="/2023/04/20/unity8/14.png" alt></p>
<h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p>以上描述也许不会非常相近，你可以查看下面三篇博客学习：</p>
<ul>
<li><p><a href="https://blog.csdn.net/linxinfa/article/details/121370565">【游戏开发实战】下载原神模型，PMX转FBX，导入到Unity中，卡通渲染，绑定人形动画（附Demo工程）</a></p>
</li>
<li><p><a href="https://blog.csdn.net/shulianghan/article/details/127774380">【Unity3D】使用 FBX 格式的外部模型 ② ( FBX 模型与默认 3D 模型的区别 | FBX 模型贴图查找路径 | FBX 模型可设置多个材质 )</a></p>
</li>
<li><a href="https://blog.csdn.net/newchenxf/article/details/123276198">Unity为人物模型 添加动效Animator</a></li>
</ul>
<p>此外，如果你尝试使用了移动动画的话，你会发现角色身上的布料等物品都没有移动过，非常僵硬，这是因为虽然这些地方也绑定了骨骼，但是我们并没有规定它们如何移动，刚才导入的动画也只是控制了角色本身的骨骼。</p>
<p>因此在后面的博客中我们将用一个免费的Unity插件来实现角色的布料模拟，并防止布料在角色身上穿模。你可以通过这个插件来了解如何给Unity编写插件，以及如何对提供的插件进行修改，为自己编写插件积累经验，从而完成某些自动化工作。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(七)-制作一个2D游戏</title>
    <url>/2023/04/18/unity7/</url>
    <content><![CDATA[<p>下面我们制作对话系统和音效。</p>
<span id="more"></span>
<h1 id="对话系统"><a href="#对话系统" class="headerlink" title="对话系统"></a>对话系统</h1><h2 id="对话条件的检测"><a href="#对话条件的检测" class="headerlink" title="对话条件的检测"></a>对话条件的检测</h2><p>角色要和青蛙对话，要求角色面朝青蛙并且距离在一定范围内，因此如果用一个Trigger来检测会不满足第一个条件，我们使用射线投射功能来进行检测，顾名思义，生成一条短直线来检测是否和青蛙碰撞。</p>
<p>在RubyController中的Update方法添加代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(KeyCode.X))</span><br><span class="line">&#123;</span><br><span class="line">    RaycastHit2D hit = Physics2D.Raycast(rigidbody2d.position + Vector2.up * <span class="number">0.2f</span>, lookDirection, <span class="number">1.5f</span>, LayerMask.GetMask(<span class="string">&quot;NPC&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (hit.collider != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Raycast has hit the object &quot;</span> + hit.collider.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用新的API，Physics2D.Raycast：</p>
<p><img src="/2023/04/18/unity7/1.png" alt></p>
<p>从位置origin，朝direction方向发射一个长度为distance的直线，在包含待检测碰撞体的图层layerMask中进行碰撞检测，还可以设置仅检测深度值在(minDepth，maxDepth)之间的对象，2D中深度值指的是Transform.position的Z轴坐标，用来进行图片的排序。</p>
<h2 id="创建对话UI"><a href="#创建对话UI" class="headerlink" title="创建对话UI"></a>创建对话UI</h2><p>和之前一样，我们选择青蛙给他添加一个Canvas子对象，然后将Render Mode设置为World Space，这样可以让UI不再以屏幕为标准，其大小和位置现在以世界坐标作为标准。然后修改Rect Transform中的值让画布调整到合适的大小。</p>
<p>注意，调整大小需要采用缩放的方式，因为UI以像素为单位，如果采用修改width和height的方法来实现，会导致UI仅有几个像素大小，无法显示内容。因此我们采用缩放来进行改变。</p>
<p>调整后为画布添加image子对象，锚点及位置对其四个顶点；将UIDialogueBox赋值给Image，然后再创建子对象UI- Text - TextMeshPro，添加后同样对齐四个点，输入想要显示的文字，就得到了对话框。</p>
<h2 id="控制对话UI"><a href="#控制对话UI" class="headerlink" title="控制对话UI"></a>控制对话UI</h2><p>我们要让对话框在检测到的时候显示，直接调用对话框组件的setActive方法即可，这个实际上就是Inspector窗口最上面的勾选。给NPC创建脚本并添加代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NonPlayerDialog</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> displaytime;</span><br><span class="line">    <span class="keyword">public</span> GameObject dialogbox;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> timerDisplay;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dialogbox != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dialogbox.SetActive(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        timerDisplay = <span class="number">-1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timerDisplay &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timerDisplay -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (timerDisplay &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dialogbox != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dialogbox.SetActive(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayDialog</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        timerDisplay = displaytime;</span><br><span class="line">        dialogbox.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在刚才RubyController那里将输出改为调用这里最后一个方法即可。</p>
<h1 id="音效系统"><a href="#音效系统" class="headerlink" title="音效系统"></a>音效系统</h1><p>Unity中的音频系统具有Audio Listener和Audio Source两种类，前者接受音频，后者发出音频，从而模拟位置音效。其中，Audio Mixer可以混合多种音频，应用效果，执行母带制作；Audio Clip可以制作音频文件添加到Audio Source中。</p>
<h2 id="背景音乐"><a href="#背景音乐" class="headerlink" title="背景音乐"></a>背景音乐</h2><p>我们先用最简单的方式添加背景音乐，在这个素材中所有的Audio Clip都制作好了，所以可以直接使用。那么要播放背景音乐，我们创建一个空的游戏对象，然后添加Audio Listener组件，将素材2D MUSIC LOOP赋值给组件的Audio Clip属性即可，然后勾选loop，设置Spatial Blend为3d。</p>
<h2 id="交互的音效"><a href="#交互的音效" class="headerlink" title="交互的音效"></a>交互的音效</h2><p>某些需要在特定状态下播放的音效就只能通过代码控制了，我们现在用一个Audio Source组件控制播放不同的Audio Clip， 那就在角色对象上添加Audio Source组件，然后Start中获取，接着新声明一个方法接受类型为Audio Clip的参数并调用AudioSource.PlayOneShot方法播放这个Clip。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Playsound</span>(<span class="params">AudioClip audioClip</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    audioSource.PlayOneShot(audioClip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将Clip作为其他游戏对象的属性，每当触发事件的时候就同时调用上面这个方法，即可播放声音。例如血瓶拾取的时候要播放音效，就让血瓶的音效作为血瓶的属性序列化出来，然后当血瓶判断可以加血的时候调用角色控制器来播放这个音频，就实现了播放效果，就和动画一样。</p>
<h2 id="3D的声音"><a href="#3D的声音" class="headerlink" title="3D的声音"></a>3D的声音</h2><p>将Clip的Spatial Blend设置为3D即可，然后在Inspector下方有一个曲线，横轴代表距离，纵轴代表音量，拖动上面的点就可以设置衰减了。但是随意设置可能会导致挂在摄像机上的Listener听不到声音，因为摄像机和2D平面有一段距离，你的设置就可能超过这个距离。</p>
<p>解决方法是，删除主摄像机上的Audio Listener，然后在虚拟摄像机上创建一个子对象，查看虚拟摄像机的位置，观察到它的z轴坐标为-10，而子对象以父对象为原点，因此我们设置其坐标为(0,0,10)，这样一来子对象就是父对象在2D平面上的投影，那么在这个子对象上挂接Audio Listener即可，并且虚拟摄像机会随着角色移动，因此这个接收器就能模拟音效的3D效果了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里我们的2D案例就完成了，教程中并没有全部制作一遍，但是方法都已经使用过了，有时间的话可以进一步自己制作。但是这个项目仍然还是一个很简单的教程项目，缺乏完整的系统，例如菜单，地图，任务，战斗，装备等，都需要进一步学习。不过基本的操作流程我们学会了，基础移动，如何检测攻击，动画系统，音效系统，UI的使用，TileMap，相信在将来的学习中这些会更加熟悉，哪怕是在3D游戏中也是类似的。</p>
<p>因此现在可以体会到游戏制作中的难点了：</p>
<ul>
<li>复杂的逻辑</li>
<li>资源的管理</li>
<li><p>素材的质量</p>
</li>
<li><p>设计的好坏</p>
</li>
</ul>
<p>还有很多要素会影响，对于个人来说要做出好的实例，要尽可能有清晰的设计思路，并且素材是个很大的问题，通常来说3D的话动画资源可以白嫖Adobe<a href="https://www.mixamo.com/#/">旗下的网站</a>，模型可以去模之屋下pmx格式的，不过要用Blender和插件处理pmx，导出Unity能用的格式Fbx。下一篇博客中就会详细说明这些工具的使用。</p>
<p>后面做一个ARPG项目demo，3D即时战斗游戏，Rougelike玩法，重点一是内容丰富，二是风格化美术效果。目前规划内容：</p>
<ul>
<li>角色移动控制：层次状态机规划的移动动画播放，包括闪避动画，障碍物跨越等；</li>
<li>角色攻击系统：层次状态机规划角色的连招系统，技能系统；</li>
<li>UI：尽量寻找风格化素材；</li>
<li>场景：地形编辑，多个场景转换控制，可交互场景物体；</li>
<li>敌人AI：决策行为树控制怪物的攻击，闪避，移动；</li>
<li><p>敌人控制系统：提供控制攻击、闪避、移动的效果，并管理死亡动画；</p>
</li>
<li><p>特效：怪物、角色、场景中的特效，同样只能使用免费资源；</p>
</li>
<li>着色器：风格化的渲染效果，尽量能展示技术难点，例如云雾渲染，流体渲染等；</li>
</ul>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>unity入门(九)-地形系统</title>
    <url>/2023/04/23/unity9/</url>
    <content><![CDATA[<p>经过前面的学习你肯定大概了解如何制作游戏了，unity的基本内容我们都已经使用过，只是由于经验不足你很多时候难以想到某些问题解决方案，或者一些游戏内容的普遍做法，而且对于网络、服务器、内存管理等部分也一窍不通，不用担心，这些内容我们会在进阶部分时候进行学习。下面我们给自己的游戏创建一个游戏场景，你就了解怎么制作简单的单机游戏了。不过注意地形和场景是两回事，地形只包括地面上的山脉、起伏，而河流、房屋、植被等都要通过另外的资产或预制件制作完成。</p>
<span id="more"></span>
<p>Unity自带的地形系统Terrain据说十分不方便，尤其在诸多开放世界游戏中需要制作精美的大地图，使用自带的系统肯定不能满足要求，感兴趣可以查看这篇<a href="https://gulu-dev.com/post/2014-11-16-open-world/">博客</a>，简单来说就是使用平铺的Tile配合贴图完成。</p>
<p>所以我们这里对地形系统的使用主要还是入门为主，毕竟要制作一个风格统一的游戏需要优质的美术，需要的纹理等可以通过Assets Store搜索满足要求的场景配合我们前面一篇博客导入和渲染的模型。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="导入Terrain-Tools"><a href="#导入Terrain-Tools" class="headerlink" title="导入Terrain Tools"></a>导入Terrain Tools</h2><p>创建一个3D项目，在Packge Manager中找到Registry，搜索Terrain Tools，然后导入；导入完成后还要进一步下载提供的Sample包，提供了很多植被的预制件，地形纹理等素材。</p>
<p>如果搜索不到这个包，可以尝试两种办法：</p>
<ul>
<li>Project Settings/Package Manager，勾选Enable Preview Packages；</li>
<li>点击下图左上角加号，然后输入<strong><em>com.unity.terrain-tools</em></strong>即可；</li>
</ul>
<p><img src="/2023/04/23/unity9/1.png" alt></p>
<h2 id="导入Fantasy-Landscape"><a href="#导入Fantasy-Landscape" class="headerlink" title="导入Fantasy Landscape"></a>导入Fantasy Landscape</h2><p>在Unity Assets Store中搜索并安装这个包，它提供了一个实例场景，以及多种预制件，方便我们制作地形。</p>
<h2 id="修改URP管线"><a href="#修改URP管线" class="headerlink" title="修改URP管线"></a>修改URP管线</h2><p>由于我们之前的角色使用的是URP进行渲染，这里我们也用URP来渲染场景，关于URP的介绍在另一个系列的博客中，这里仅记录如何升级一个项目为URP。</p>
<p>建立3D项目后，在Package Manager/Unity Registry中搜索Universal RP，安装，完成后在最外层文件夹中Create/Rendering/Universal Render Pipeline/Pipeline Asset(Forward Renderer)</p>
<p><img src="/2023/04/23/unity9/2.png" alt></p>
<p>完成后会创建两个Assets，将第一个Assets命名为URP，打开Project Settings/Graphics，将第一项设置为这个资产：</p>
<p><img src="/2023/04/23/unity9/3.png" alt></p>
<p>这里起始就是将默认的渲染管线替换成了URP，URP是可编程的渲染管线，就可以利用它编写Shader了。</p>
<p>导入后在Environments/Scenes中打开实例场景，你会发现场景中的树都变成粉色了，这是因为原本材质上的Shader不能被URP支持，此时我们需要升级材质：</p>
<p><img src="/2023/04/23/unity9/4.png" alt></p>
<p>点击以后发现还是没有完全将材质转化过来，我们只能手动调整，进入Environments/Ambient-Occlusion-Trees/Materials文件夹，全选并修改Shader为Universal Render Pipeline/Simple Lit，这是一个通用的内置Shader，使用它可以正确在渲染管线中渲染我们的材质。</p>
<p>完成后打开Prefabs文件夹，接下来要对这四个树的预制件进行相同操作：</p>
<ul>
<li>打开预制件；</li>
<li>修改树干Bark的材质为：<ul>
<li>Surface Type：Opaque，不透明；</li>
<li>Render Face：Front，只渲染前面；</li>
<li>Base Map：同名纹理图片；</li>
</ul>
</li>
<li>修改树叶Leaves的材质为：<ul>
<li>Surface Type：Opaque，不透明；</li>
<li>Render Face：Both，两面都渲染；</li>
<li>Base Map：同名纹理图片；</li>
<li>Alpha Clipping：勾选后可控制透明度；</li>
</ul>
</li>
</ul>
<p>修改完成后，重新打开样例场景，这一次正确渲染了场景，我们可以开始学习了。</p>
<h1 id="创建并修改地形"><a href="#创建并修改地形" class="headerlink" title="创建并修改地形"></a>创建并修改地形</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>打开Window/Terrain/Terrain Tools，第一栏可以创建基本地形，这里我们选择长宽500，高度为100，然后直接点击下方的Create即可创建。完成后看到层级栏中多出来一个拥有子对象的游戏对象TerrainGroup_0，它的子对象就是我们后续操作的目标。</p>
<p><img src="/2023/04/23/unity9/5.png" alt></p>
<h2 id="用Brush改变地形"><a href="#用Brush改变地形" class="headerlink" title="用Brush改变地形"></a>用Brush改变地形</h2><p>创建之后我们先做一个起伏的地形，选中新建的子对象，看到有一个Terrain组件用于绘制地形，一个Terrain Collider用于进行碰撞检测，我们进入Terrain组件，选择第二个Paint Terrain，下面提供了非常多的绘制模式，我们介绍两种。</p>
<h3 id="Raise-or-Lower-Terrain"><a href="#Raise-or-Lower-Terrain" class="headerlink" title="Raise or Lower Terrain"></a>Raise or Lower Terrain</h3><p>最简单的绘制模式，这个刷子可以帮助我们快速调整地形。</p>
<p><img src="/2023/04/23/unity9/6.png" alt></p>
<p>其中Brush Mask选项提供了很多不同的刷子，也就是我们刚才导入的包中提供的素材，不同的刷子绘制不同的效果，选中一个刷子后进入地图，操作快捷键如下：</p>
<ul>
<li>左键，点击增高地形；</li>
<li>A，按住后移动鼠标调整改变地形的力度；</li>
<li>S，按住后移动鼠标调整刷子大小；</li>
<li>D，按住后旋转刷子；</li>
<li>LShift，按住后点击左键降低高度；</li>
</ul>
<p>利用这些功能就可以方便地制作地形了。</p>
<h3 id="Sculpt-Noise"><a href="#Sculpt-Noise" class="headerlink" title="Sculpt/Noise"></a>Sculpt/Noise</h3><p>这个刷子采用噪声纹理的方式来修改地形，滚轮即可调整噪声大小，然后应用到地形上的方式和上面一样，不过这个就比较自然，刷子区域内会根据噪声来表现起伏。</p>
<p><img src="/2023/04/23/unity9/7.png" alt></p>
<h2 id="添加纹理和法线贴图"><a href="#添加纹理和法线贴图" class="headerlink" title="添加纹理和法线贴图"></a>添加纹理和法线贴图</h2><p>现在地形制作好了，需要给地形添加纹理，在Terrain中地形的纹理通过不同层来实现绘制，选择Paint Texture选项，创建新的层，选择草地和道路的纹理即可。</p>
<p><img src="/2023/04/23/unity9/8.png" alt></p>
<p>先添加草的纹理后，可以看到整个地图都覆盖了草的纹理，之后再添加地面的纹理，就可以使用刷子在草地上覆盖绘制了，现在制作一个简单的道路吧！</p>
<p>绘制后你可能发现道路的质量不高，像素化比较严重，这是因为我们使用的分辨率不够，所以回到Terrain Toolbox，修改Control Texture Resolution，并Apply to All。</p>
<p><img src="/2023/04/23/unity9/11.png" alt></p>
<p>添加后可以转到我们使用的这两个纹理上，双击它们使用的Layer，这里还可以添加法线贴图，增强地图的凹凸感。</p>
<p><img src="/2023/04/23/unity9/12.png" alt></p>
<h2 id="添加内嵌光照"><a href="#添加内嵌光照" class="headerlink" title="添加内嵌光照"></a>添加内嵌光照</h2><p>这里简单介绍下，由于场景中比较暗，一个是Directional Light的强度不够，一个就是缺少内嵌光源，我们打开Window/Rendering/Lighting，选择Environment，点击最下面的Generate Lighting，具体原理在光照部分会详细介绍。</p>
<p><img src="/2023/04/23/unity9/9.png" alt></p>
<p>然后选中层级栏中的方向光，调整光线强度。</p>
<p><img src="/2023/04/23/unity9/10.png" alt></p>
<h2 id="设置树"><a href="#设置树" class="headerlink" title="设置树"></a>设置树</h2><p>现在我们使用提供的四个预制件树木来丰富我们的场景。现在切换到Terrain组件的第三项，Paint Trees，点击Edit Trees/Add Tree，依次添加我们刚才修改过URP管线的四个树木，然后选中想要的树木，就可以用刷子添加了。</p>
<p><img src="/2023/04/23/unity9/13.png" alt></p>
<p>不过这种方法添加太慢了，我们直接使用Mass Place Trees按钮，将一次性随机添加指定数目的Trees到场景中，当然有一些树可能长在我们的道路上，可以按住Shift并点击来擦除不要的树。现在你可以制作完整的场景了。</p>
<p>添加了足够数量的树以后你会发现树的显示有些问题，在远处的树总是会显示一部分，并不会如我们平常见的游戏中那样消失或隐藏，这就需要制作LOD来调整了，Terrain是支持LOD(Level of Detail)的，但是我们这里为了简单使用就不采取这个办法，下面提供两种解决办法。</p>
<h3 id="使用fog来遮挡"><a href="#使用fog来遮挡" class="headerlink" title="使用fog来遮挡"></a>使用fog来遮挡</h3><p>打开Lighting/Environment，勾选fog并调整雾气的颜色，以及雾效果的Density，这样可以用fog来遮盖远处的树木，并且耗费的计算量很小，只是效果可能不会特别好。</p>
<h3 id="设置Billboard-Start"><a href="#设置Billboard-Start" class="headerlink" title="设置Billboard Start"></a>设置Billboard Start</h3><p>转到Terrain组件的最后一项Terrain Settings，找到Tree &amp; Detail Objects，修改Billboard Start的值，这个值和LOD有关，可以通过计算距离来渲染对应距离的模型等级，从而得到较好的效果。缺点则是需要消耗很多CPU计算量，不够这里我们可以暂时使用。</p>
<h2 id="添加草、花"><a href="#添加草、花" class="headerlink" title="添加草、花"></a>添加草、花</h2><p>和前面添加树类似，我们打开Terrain的第四项，Paint Details，然后Edit Details，这里可以使用纹理来创建草的模型，也可使用制作好的Mesh(也就是预制件或者模型)，我们选择后者，然后添加Flower1和Grass1，调整刷子的尺寸、Target Strength等，然后在草地上绘制草花，添加更多细节。</p>
<p>你可能发现有些草由于地形起伏太倾斜了，这时可以使用Terrain Settings/Wind Settings for Grass的Bending属性，通过控制草对风的倾斜程度来改变草原本的倾斜程度。</p>
<p><img src="/2023/04/23/unity9/18.png" alt></p>
<p>最后还可以找到预制件Rock1，直接拖进场景即可，这个由于我们不需要太多，所以可以手动，也可使用前面的方式添加。</p>
<h2 id="设置天空盒"><a href="#设置天空盒" class="headerlink" title="设置天空盒"></a>设置天空盒</h2><p>最后我们使用一个免费的天空盒素材，<a href="https://assetstore.unity.com/packages/2d/textures-materials/sky/fantasy-skybox-free-18353">Fantasy Sky Box Free</a>，导入后转到Lighting/Environment，修改Sky Box Material即可：</p>
<p><img src="/2023/04/23/unity9/14.png" alt></p>
<p>这样我们的场景就制作完成了。</p>
<p>之后通过添加光照、Global Volume可以实现很好的渲染效果，这里我们先不说明了，后面光照部分会主要介绍这些组件。我制作完成的场景如下：</p>
<p><img src="/2023/04/23/unity9/15.png" alt></p>
<p>添加了Global Volume之后的效果：</p>
<p><img src="/2023/04/23/unity9/16.png" alt></p>
<p>加上我们之前导入的模型，使用不同的Shader得到的效果：</p>
<p><img src="/2023/04/23/unity9/17.png" alt></p>
<p>光照渲染这部分还是非常有趣的，不过难度也比较大，值得深入学习。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里我们的Unity基础就算是完成了，包括场景切换，擎界面布局，脚本编写，刚体与碰撞，触发器和射线，UGUI，动画系统入门，以及这里介绍的地形系统，一般来说大规模的项目都有自己开发的地形编辑器，按照Terrain的思路可以想想大概是什么样子。而且我们这里的介绍肯定也不是面面俱到的，Terrain系统中的很多参数都可以自己尝试使用下，Unity中鼠标放上去也会给出解释，总之大概知道如何使用即可。</p>
<p>现在已经可以尝试用免费素材制作一个自己的3D游戏场景了。我们后面的博客重点介绍灯光，摄像机，动画系统和IK，还有场景之间的切换，最后总结下Unity的常用组件及其API，这个Unity入门系列就正式完结了，往后的Unity博客主要就是解决方案的分享，另外还有Unity Shader一个系列会加快更新，届时可能会再回过头来用这些基本操作。都完成后可能会更新非Unity的内容，热更、Lua之类的知识。</p>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>CG</tag>
        <tag>Unity</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity面试问题整理</title>
    <url>/2023/10/18/unityInterview/</url>
    <content><![CDATA[<p>2023.10.19面经整理。</p>
<span id="more"></span>
<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C#基础"></a>C#基础</h2><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>继承</strong>：重用现有代码，提高重用度。继承的传递性，继承的单根性（一个类只能有一个父类）。</p>
<p><strong>封装</strong>：隐藏对象属性，实现细节方法，对外提供方法接口。</p>
<p><strong>多态</strong>：同名方法根据不同环境表现不同的逻辑，静态多态重载，动态多态重写。</p>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><h4 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h4><p>静态多态中，函数响应发生在编译阶段，C#提供两种方法实现该特性：</p>
<ul>
<li>函数重载：参数不同，不能只有返回值不同。</li>
<li>运算符重载：</li>
</ul>
<p>重载定义在一个类中，使用不同参数以调用。</p>
<h4 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h4><p>动态多态中，函数响应发生在运行阶段，C#使用抽象类和虚方法实现。这里可能问到抽象类、虚方法和接口的区别。</p>
<p>访问public，使用abstract创建抽象类，抽象类包含抽象方法，抽象方法可以被派生类实现，使用override重写，没有方法体。但是抽象类无法被直接实例化，抽象类外部也不能声明抽象方法，不能用sealed声明抽象类。派生类必须使用override重写抽象属性和抽象方法，没有全部重写那么派生类就只能是抽象类。此外抽象方法声明不提供实现，因此没有方法体。</p>
<p>访问public，虚方法使用virtual声明，使用override重写，必须有方法体。虚方法在任意类中都可以实现，在子类中可以重写也可以不重写，不能用sealed修饰，否则不能重写。虚方法已经提供了函数实现，不过允许在子类中覆盖。C#中给类进行赋值时使用的是引用类型，也就是说不论是什么类的实例，=赋值其实是让这个符号引用被赋值的对象，实际运行的时候调用的也是被赋值对象的方法。更深入一点可以将这个分为编译时类型和运行时类，前面说的就是虚方法调用的是运行时类的方法，非虚方法调用的是编译时类的方法。</p>
<p>都不能使用其它的访问修饰符，protected也会因为不能访问其它文件而不方便。</p>
<p>总的来说，抽象方法是只有定义，没有函数体的抽象类函数，必须在子类中重写；虚方法是有方法体的函数，并且允许在子类中重写。</p>
<p>还有接口是一种特殊的抽象类，只包含常量和方法定义，没有实现，访问范围都是public，也需要实现全部接口。本来C#不支持多重继承，但是一个类可以继承多个接口。</p>
<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p><strong>值类型</strong>：所有简单类型，int，float，bool，char，struct，enum，继承自System.ValueType，在结构中是堆栈分配的或内联分配的。</p>
<p><strong>引用类型</strong>：string，object，class，interface，delegate，array，继承自System.Object，在结构中是堆分配的。</p>
<p>分配内存的时候值类型只需要一段内存，存放在栈中即可；而引用类型需要两段内存，一段和值类型一样存储实际数据，不过存放在堆中，第二段是存放在栈中的，记录数据在堆中的地址。当调用Console.WriteLine输出，显示的都是栈中的数据。</p>
<p>内存堆栈指内存中两个存储区（堆区，栈区）。栈内存不受我们和GC管理，这个托管堆受GC管理。</p>
<h3 id="Net-framework和-Net-core，Mono，Xamarin的关系"><a href="#Net-framework和-Net-core，Mono，Xamarin的关系" class="headerlink" title=".Net framework和.Net core，Mono，Xamarin的关系"></a>.Net framework和.Net core，Mono，Xamarin的关系</h3><p>.Net是跨语言，跨平台的语言平台，Common Language Runtime是.Net的关键，类似于Java的虚拟机。而.Net framework和.Net core都是.Net的实现，前者在windows上运行，后者windows、linux、iOS上都能运行。而Mono是当年只有.Net framework时为了在Linux上运行推出的，集成并实现了.NET的编译器、CLR和基础类库，后来被微软收购了，就开始弄.Net core。    </p>
<p>Xamarin是基于Mono的APP开发框架，弄好了安卓的可以转成ios，同样ios也可以转成安卓。</p>
<h3 id="类的构造函数加static报错"><a href="#类的构造函数加static报错" class="headerlink" title="类的构造函数加static报错"></a>类的构造函数加static报错</h3><p>静态构造函数不允许添加访问修饰符，且必须无参数。静态构造函数在实例化之前调用。</p>
<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><p>装箱是将值类型转换为引用类型，分为三步：</p>
<ul>
<li>在托管堆中为引用对象分配内存；</li>
<li>将值类型的数据复制到对应内存中，相当于使用副本，不会改变原来的值；</li>
<li>返回堆中地址存入栈中。</li>
</ul>
<p>拆箱是将引用类型转换为值类型，分为两步：</p>
<ul>
<li>获取托管堆中的地址；</li>
<li>将该地址的值拷贝到栈上。</li>
</ul>
<h3 id="数组-Array-、List、ArrayList区别"><a href="#数组-Array-、List、ArrayList区别" class="headerlink" title="数组(Array)、List、ArrayList区别"></a>数组(Array)、List、ArrayList区别</h3><p>三者都是引用类型，数组在内存中是连续的，造成一些不方便，因此提供了ArrayList对象，能够动态扩充和收缩空间，不需要指定长度。</p>
<p>ArrayList将所有插入的数据作为object处理，如果有值类型的数据，需要装箱和拆箱，这些过程容易造成类型不匹配的问题，且消耗性能。于是推出了泛型List，和C++中的vector类似，提前指定其中的类型，不允许添加不同的类型。</p>
<h3 id="结构体、类、接口"><a href="#结构体、类、接口" class="headerlink" title="结构体、类、接口"></a>结构体、类、接口</h3><p>结构体是值类型，类和接口都是引用类型。</p>
<p><strong>【结构体和类的区别】</strong></p>
<ol>
<li><strong>结构体是值类型，类是引用类型</strong></li>
<li><strong>结构体存在栈中，类存在堆中</strong></li>
<li><strong>结构体成员不能使用protected访问修饰符，而类可以</strong></li>
<li><strong>结构体成员变量申明不能指定初始值，而类可以</strong></li>
<li><strong>结构体不能申明无参的构造函数，而类可以</strong></li>
<li><strong>结构体申明有参构造函数后，无参构造不会被顶掉</strong></li>
<li><strong>结构体不能申明析构函数，而类可以</strong></li>
<li><strong>结构体不能被继承，而类可以</strong></li>
<li><strong>结构体需要在构造函数中初始化所有成员变量，而类随意</strong></li>
<li><strong>结构体不能被静态static修饰（不存在静态结构体），而类可以</strong></li>
</ol>
<p>接口是指定一组函数成员而不给出实现的引用类型。可定义属性，但是要在派生类中实现该属性。可定义事件、方法、索引器。方法声明不能写范围修饰符，默认为public。利用接口可以实现多重继承。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一个函数作用域中变量的函数：</p>
<ul>
<li>可以访问另一个函数局部变量；</li>
<li>该函数用完的局部变量不会随函数结束而销毁；</li>
</ul>
<h3 id="string和stringBuider，stringBuffer"><a href="#string和stringBuider，stringBuffer" class="headerlink" title="string和stringBuider，stringBuffer"></a>string和stringBuider，stringBuffer</h3><p>string声明字符串后，作为引用变量需要在栈内存储堆地址，堆内存储字符串内容，而且字符不可变，每次对这个字符进行改变就要更改栈中的引用地址，如果字符串不存在于堆中就得申请一个堆内存，舍弃原来的内容。包括拼接字符串和重新赋值也是，频繁修改会导致无效引用变多，频繁GC。例如拼接字符串”hello”world”，那么需要分配三次空间，两个单词各一次，然后拼接起来还要一次。</p>
<p>如果需要频繁变动字符串，那么就需要使用stringBuilder和stringBuffer，它们的内容可以多次修改，也不会产生新的对象。不过Builder不是线程安全的，Buffer是线程安全的。线程安全就是同时只有一个线程可以访问共享数据，防止不一致的问题。    </p>
<p>速度方面stringBuilder最快，适合单线程，然后是stringBuffer，适合多线程，最后才是string，常量字符串。</p>
<h3 id="static静态"><a href="#static静态" class="headerlink" title="static静态"></a>static静态</h3><p>static可以用来声明类、字段、属性和方法。用它声明的变量将静态执行，内存中只有一个，并且不用创建实例实行，直接使用类名就可以调用。</p>
<ul>
<li><p>静态类内部只能是静态字段方法，没有其它实例，它本身也不能通过new关键字来实例化，本质上是一个密封的抽象类，不能作为基类。</p>
</li>
<li><p>静态变量只能是成员变量而不能是方法的局部变量，类初始加载时具有局部值。</p>
</li>
<li><p>静态方法只能访问静态变量和静态方法，通过类名直接调用。Main方法是程序唯一出入口，用的就是static修饰。</p>
</li>
<li>静态构造函数不能添加其它修饰符，且必须没有参数，只会被执行一次，在实例化之前自动执行，比实例化后调用的构造函数快。</li>
</ul>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a><a href="https://www.cnblogs.com/zblade/p/6445578.html">GC</a></h3><p>垃圾回收机制，避免托管堆内存溢出，定期回收没有有效引用的内存对象。它由CLR实现，GC优化就是优化堆内存，减少堆内存，及时回收堆内存。</p>
<h4 id="堆内存分配和GC步骤"><a href="#堆内存分配和GC步骤" class="headerlink" title="堆内存分配和GC步骤"></a>堆内存分配和GC步骤</h4><p>分配：</p>
<ul>
<li>检查堆内存是否可以分配，如果足够就先分配；</li>
<li>内存不够，触发GC回收再检查分配；</li>
<li>还是不够，将扩展使用的内存，分配对应大小的空间；</li>
</ul>
<p>需要减少第二和第三种情况发生的频率；</p>
<p>回收：</p>
<ul>
<li>检查堆上的每个变量是否处于激活状态；</li>
<li>没激活的标记为可回收；</li>
<li>移除可回收变量，收回内存空间；</li>
</ul>
<p>堆上的变量越多，GC检查就越多，耗费时间边长。</p>
<h4 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h4><ul>
<li>按平台有不同的触发频率；</li>
<li>申请内存时空间不足需要GC；</li>
<li>可以主动强制GC；</li>
</ul>
<h4 id="GC可能带来的问题"><a href="#GC可能带来的问题" class="headerlink" title="GC可能带来的问题"></a>GC可能带来的问题</h4><ul>
<li>堆内存碎片化：总的空间很大，但是连续的空间很小，难以找到合适的分配单元；这会导致游戏内存越来越大，GC越来越频繁；</li>
<li>游戏帧率下降：GC操作代价大，关键时候会使得游戏运行缓慢；</li>
</ul>
<p>使用<a href="https://unity3d.com/cn/learn/tutorials/topics/scripting/data-types">profile window</a>可以查看性能下降是不是由GC导致。</p>
<h4 id="GC优化方法"><a href="#GC优化方法" class="headerlink" title="GC优化方法"></a>GC优化方法</h4><p>我们可以通过三类方法优化GC：</p>
<ul>
<li>减少GC次数；</li>
<li>减少单次GC检查的时间；</li>
<li>延迟GC时间，避免在关键时候触发；</li>
</ul>
<p>对应到游戏中，我们可以使用这些具体手段：</p>
<ul>
<li><p>定时强制GC，减少关键时候出事故的可能；</p>
</li>
<li><p>值类型变量使用后立即回收，引用型变量需要GC；</p>
</li>
<li>字符串拼接使用stringbuilder或者stringbuffer，而不是直接+=，字符串比较先定义变量存储；</li>
<li>List和new的时候规定内存大小；</li>
<li>射线检测，使用避免GC的NoAlloc函数；</li>
<li>foreach迭代器容易导致GC（目前Unity5.5已修复），使用For循环；</li>
<li>使用静态变量，GC不会回收存在的对象，但静态变量的引用对象可能被回收；</li>
<li>使用枚举替代字符串变量；</li>
<li>调用gameobject.tag==”XXX”就会新建字符串变量产生内存垃圾；那么采用GameObject.CompareTag()可以避免内存垃圾的产生：</li>
<li>不要在频繁调用的函数中反复进行堆内存分配，比如OnTriggerXXX，Update等函数；</li>
<li>在Update函数中，运行有规律的但不需要每一帧执行的代码，可以使用计时器，比如1秒执行一次某些代码。</li>
</ul>
<h3 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a,b) =&gt; &#123;return a+b;&#125;;</span><br><span class="line"></span><br><span class="line">//只有一个参数可以省略成这样：</span><br><span class="line">a =&gt; a*a;</span><br></pre></td></tr></table></figure>
<h3 id="常用容器类"><a href="#常用容器类" class="headerlink" title="常用容器类"></a>常用容器类</h3><ul>
<li>Stack：底层泛型数组实现，入栈动态扩容2倍；</li>
<li>Queue：底层泛型数组实现，表头表尾指针，判空还是满通过size比较；</li>
<li>Array：固定长度，类型不安全；</li>
<li>ArrayList：动态数组，类型不安全；</li>
<li>List：底层实现是泛型数组，动态扩容，类型安全；</li>
<li>LinkedList：链表；</li>
<li>HashTable哈希表（散列表）；</li>
<li>Directionary：有序，泛型存储不需要进行类型装换（不需要装箱拆箱）</li>
</ul>
<p>插入性能： LinkedList &gt; Dictionary &gt; HashTable &gt; List<br>遍历性能：List &gt; LinkedList &gt; Dictionary &gt; HashTable<br>删除性能： Dictionary &gt; LinkedList &gt; HashTable &gt; List</p>
<p>在修改较频繁，且查找和删除也较多时，首选LinkedList,<br>在主要以删除为主，插入为辅，且查找较少时，首选Dictionary，<br>在查找频繁，而又无需修改的情况下，则首选List。</p>
<h3 id="常规容器和泛型容器"><a href="#常规容器和泛型容器" class="headerlink" title="常规容器和泛型容器"></a>常规容器和泛型容器</h3><p>常规容器有拆箱和装箱操作，速度慢，消耗性能，泛型容器效率更高。</p>
<h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><p>unsafe 不安全代码，在不安全代码块中可以使用指针。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span>* ptr = &amp;number; <span class="comment">// 声明一个指向整数的指针</span></span><br><span class="line">    Console.WriteLine(*ptr); <span class="comment">// 输出指针所指向的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要指向堆中的托管对象，需要使用fixed，固定对象的地址防止GC回收。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] numbers = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">fixed</span> (<span class="built_in">int</span>* ptr = numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用指针ptr来访问数组中的元素</span></span><br><span class="line">        Console.WriteLine(ptr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以在栈上或者堆上分配内存：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> stackAllocated = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[<span class="number">100</span>]; <span class="comment">// 在栈上分配内存</span></span><br><span class="line">    <span class="built_in">int</span>* heapAllocated = (<span class="built_in">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="built_in">int</span>) * <span class="number">100</span>); <span class="comment">// 在堆上分配内存，需要手动释放</span></span><br><span class="line">    <span class="comment">// 使用 stackAllocated 和 heapAllocated 操作内存</span></span><br><span class="line">    free(heapAllocated); <span class="comment">// 释放堆上分配的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ref和out"><a href="#ref和out" class="headerlink" title="ref和out"></a>ref和out</h3><p>ref可以传递值类型变量的引用版本，类似指针，out也一样。唯一的区别是ref需要已经初始化过具体值，out可以使用没赋值过的变量作为参数传递。底层上看，out在方法内部分配一次地址，将这个地址给引用的变量使用，而ref将被引用变量的地址传递过来。</p>
<h3 id="for和foreach"><a href="#for和foreach" class="headerlink" title="for和foreach"></a>for和foreach</h3><p>for通过当前索引累加偏移量实现遍历，foreach主要通过指针偏移实现遍历，不过foreach要求对象实现了枚举接口，IEnumrable，而且会把对象的值复制到栈上面，效率比for低一些。</p>
<p>foreach操作时不能删除对象中的元素，因为使用的是副本会导致不一致性，程序会抛出异常，可以自行记录要删除的元素序号，结束迭代后再删除。</p>
<h3 id="频繁创建一个对象，怎么减少开销？"><a href="#频繁创建一个对象，怎么减少开销？" class="headerlink" title="频繁创建一个对象，怎么减少开销？"></a>频繁创建一个对象，怎么减少开销？</h3><p>需要初始化就对象池，不需要就单例模式一直用一份内存就行。</p>
<h3 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h3><p>委托类似于一种函数指针，通过委托可以实现事件的订阅和发布；事件基于委托，将方法进行了封装，不能显示调用这些方法，提高了安全性。</p>
<h3 id="using的使用"><a href="#using的使用" class="headerlink" title="using的使用"></a>using的使用</h3><p>用于资源管理和命名空间导入。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (ResourceType resource = <span class="keyword">new</span> ResourceType())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用资源</span></span><br><span class="line">    <span class="comment">// 资源会在这个块结束后自动被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System; <span class="comment">// 导入System命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ExampleNamespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以直接使用System命名空间中的类型，而不需要写成System.Console</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义时不指定具体的数据类型，在使用时再指定数据类型。</p>
<ul>
<li>提高代码复用：处理基本数据类型时用泛型一次性完成；</li>
<li>类型安全：编译阶段提供类型安全检查，List和Dictionary都使用了泛型，确保不会出现类型不匹配的问题；</li>
<li>性能优化：避免了装箱和拆箱，因为类型相同不会发生值类型和引用类型的转换；</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器可以遍历某个集合中的对象而不用关心其中对象的类型，C#中可迭代的对象需要继承IEnumrable接口，实现GetEnumrator方法，获得对象的迭代器，并且要求该迭代器继承IEnumrator接口，该接口提供MoveNext方法判断迭代是否继续，Reset方法重置迭代器，以及Current属性用于返回当前迭代器的值。此外IEnumrable和IEnumrator都有派生的泛型类。返回值为IEnumrable或者IEnumbrator的方法就是迭代器方法。</p>
<p>可迭代对象就能用foreach来访问，foreach依次调用可迭代对象的上述几个方法，就实现了简单的迭代函数。foreach(Type value in IEnumerable)会将value强转成Type，因此Type如果是非泛型可能造成类型不安全。</p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>为了进一步简化迭代器的使用，推出了yield关键字，用于迭代器方法内部。迭代器方法会自动生成一个迭代器，每个yield语句都表示一次暂停或中断，执行迭代器方法的时候程序会在yield return处暂停，并保存当前变量的值，下一次唤醒的时候回复变量，继续执行剩下的语句。yield break则会直接中断该方法，也就是让MoveNext方法返回false。</p>
<p>因此使用yield关键字之后就不用再自行继承IEnumrable和IEnumrator接口并实现，直接用foreach就可以完成对全部元素的迭代。</p>
<h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><p>C#的迭代器是延迟执行的，即只在需要的时候获取数据。实现方式就是yield return后保存当前状态，MoveNext判断是否继续，从而不会一次性申请很多空间来遍历整个集合。</p>
<h2 id="Unity脚本基础"><a href="#Unity脚本基础" class="headerlink" title="Unity脚本基础"></a>Unity脚本基础</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>由于unity只能在主线程中获取对象的组件，所以一般不考虑多线程，而是采用协程来对任务进行分时并行处理。使用StartCoroutine来开启协程，依靠迭代器实现。</p>
<p>首先用IEnumrator来定义一个需要执行的迭代器方法，每一帧将调用迭代器的MoveNext方法，当返回值为false结束该协程。可以使用yield和其它返回值的组合如wait<em>*</em>等来实现延时操作。这些等待方法是Unity函数生命周期中的一部分，定期执行，方便控制什么时候唤醒这些协程。</p>
<p>应用：异步加载场景，字幕单个字符显示等。</p>
<h3 id="函数生命周期"><a href="#函数生命周期" class="headerlink" title="函数生命周期"></a>函数生命周期</h3><p><img src="/2023/10/18/unityInterview/1.png" alt></p>
<h3 id="资源加载方式"><a href="#资源加载方式" class="headerlink" title="资源加载方式"></a>资源加载方式</h3><p>Instantiate：实例化的方式直接加载出来；</p>
<p>Assetbundle：资源打包成AB包，然后用www模块get下来，从其中加载某个对象；可以分成不同patch，按需使用。</p>
<p>Resource.Load：直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不管有没有场景引用，都会将其全部打入到安装包中；这样会比较大。</p>
<h3 id="移动物体的方式"><a href="#移动物体的方式" class="headerlink" title="移动物体的方式"></a>移动物体的方式</h3><ul>
<li>Transform：直接修改物体的位置；</li>
<li>CharacterController：不受物理引擎影响，需要自己实现物理模拟；</li>
<li>Rigidbody：AddForce、velocity等方式。</li>
</ul>
<h3 id="施加力的方式"><a href="#施加力的方式" class="headerlink" title="施加力的方式"></a>施加力的方式</h3><p>需要rigidbody组件：</p>
<p>AddForce、AddForceAtPosition、ConstantForce等。</p>
<h3 id="绕中心旋转和绕某点旋转"><a href="#绕中心旋转和绕某点旋转" class="headerlink" title="绕中心旋转和绕某点旋转"></a>绕中心旋转和绕某点旋转</h3><p>transform.Rotate和transform.RotateAround。</p>
<h3 id="存储数据的方式"><a href="#存储数据的方式" class="headerlink" title="存储数据的方式"></a>存储数据的方式</h3><ul>
<li><p>ScriptableObject：在编辑器模式下可以实现数据持久化，自动序列化到属性面板中方便更改，但发布后数据不是持久化；</p>
</li>
<li><p>PlayerPref：以键值对的形式将数据保存在文件中，跟动画状态机的赋值有点像，支持Int、Float、String的读取和保存，常用于用户设置，具备持久化；</p>
</li>
<li>JSON：编写或者生成对应的实体类，如果有JSON的嵌套还要加一个Root类作为解析类，使用解析库例如newtonsoft来序列化和反序列化；</li>
<li>XML：和JSON类似；</li>
<li>其它文件类型；</li>
</ul>
<h3 id="LocalPosition和Position区别"><a href="#LocalPosition和Position区别" class="headerlink" title="LocalPosition和Position区别"></a>LocalPosition和Position区别</h3><p>LocalPosition相对于父对象的位置，Position是世界坐标系的位置。</p>
<h3 id="Mathf常用方法"><a href="#Mathf常用方法" class="headerlink" title="Mathf常用方法"></a>Mathf常用方法</h3><ul>
<li>Mathf.Round(float f)：四舍五入；</li>
<li>Mathf.Clamp(float value, float min, float max)：截断；</li>
<li>Mathf.Lerp(float a, float b, float t)：插值；</li>
</ul>
<h3 id="Animation组件常用方法"><a href="#Animation组件常用方法" class="headerlink" title="Animation组件常用方法"></a>Animation组件常用方法</h3><ul>
<li>Animation.CorssFade(string animation, float time = 0.3f);</li>
<li>Animation.isPlaying(string name);</li>
</ul>
<h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>需要两个物体都有Collider，其中一个拥有Rigidbody；或者一个拥有CharacterController，一个有Collider。用OnColliderEnter或者OnTriggerEnter方法。</p>
<h3 id="Destroy和DestroyImmediate"><a href="#Destroy和DestroyImmediate" class="headerlink" title="Destroy和DestroyImmediate"></a>Destroy和DestroyImmediate</h3><p>Destroy销毁消息对象，内存中还是存在，只有内存不够才被清除释放内存；DestroyImmediate立即销毁对象，并释放内存。</p>
<h2 id="Unity编辑器基础"><a href="#Unity编辑器基础" class="headerlink" title="Unity编辑器基础"></a>Unity编辑器基础</h2><h3 id="动画原理"><a href="#动画原理" class="headerlink" title="动画原理"></a>动画原理</h3><p>动画包含关键帧，记录顶点位移情况，中间通过插值得到流畅的动画效果。可以给一个物体创建Animation，添加关键帧让它根据动画自行运动起来。还可以给动画Clip添加事件，让动画播放到某一帧时回调动画事件。</p>
<h3 id="Avatar"><a href="#Avatar" class="headerlink" title="Avatar"></a>Avatar</h3><p>为了实现动画复用提出了Avatar，通过骨骼名称进行匹配，让任意符合命名规范的模型骨骼同Unity的标准Avatar匹配，从而让动画能够通过映射的方法，运行在新的模型骨骼上面。</p>
<ul>
<li>Generic：普通模型，没有重定向功能；</li>
<li>Humanoid：人型骨骼，可以重定向以进行动画复用；</li>
</ul>
<p>Avatar Mask可以在多层的动画控制器中控制仅播放某个部位的动画，有利于减少美术资源要求。IK反向动力学通过反向计算运动情况来实现从手、脚部位置控制上级关节动画。</p>
<h3 id="Animation-Layer"><a href="#Animation-Layer" class="headerlink" title="Animation Layer"></a>Animation Layer</h3><p>动画分层，不同层动画控制角色的多种状态。下层状态可以覆盖或同上层动画混合，达到某些效果，同时节省资源，例如持枪动画不需要行走持枪和静止持枪两份，让上半身体持枪即可。或者疲劳的时候使用混合，让角色在其它动画中摇摆身体展示疲劳的效果。</p>
<h3 id="使用过的插件"><a href="#使用过的插件" class="headerlink" title="使用过的插件"></a>使用过的插件</h3><ul>
<li>Magica Cloth：布料模拟的插件；</li>
<li>Cinemachine：快速制作相机系统，支持相机切换、轨迹设置等；</li>
<li>Animation Rigging：骨骼渲染和选中，还能添加一些位置约束；将骨骼摆放到正确位置上；</li>
<li>Input System：输入系统，将按键和变量绑定并自动生成输入类给出监听的方法，调用监听方法可以轻松实现设备输入。</li>
</ul>
<h3 id="保持UGUI位置一致性"><a href="#保持UGUI位置一致性" class="headerlink" title="保持UGUI位置一致性"></a>保持UGUI位置一致性</h3><ul>
<li>分辨率模式设置为Scale with screen size，画布会随分辨率进行缩放；</li>
<li>UI位置通过设置锚点保持相对不变，UI位置会保持和锚点的相对距离；</li>
</ul>
<h3 id="Prefab"><a href="#Prefab" class="headerlink" title="Prefab"></a>Prefab</h3><p>是已经设置好的游戏对象，已经被序列化为二进制文件，可以方便地进行实例化。创建方法是将场景中的物体直接拖进Resource文件夹，再拖进属性面板或者直接用Resource.Load即可实例化。</p>
<h3 id="组件上对象变成null是为什么"><a href="#组件上对象变成null是为什么" class="headerlink" title="组件上对象变成null是为什么"></a>组件上对象变成null是为什么</h3><p>绑定的对象删除了，就没有引用了。</p>
<h3 id="高速对象碰撞大体积物体"><a href="#高速对象碰撞大体积物体" class="headerlink" title="高速对象碰撞大体积物体"></a>高速对象碰撞大体积物体</h3><p>碰撞检测会失败，速度太快可能前后两帧里面都没有碰撞，把Collision Detection修改为Continuous Dynamic。包括角色动画也是，如果仅使用碰撞检测来触发是不行的。</p>
<p>此外还可以设计一个自己的方法来检测有没有碰撞到，例如用射线探测，用球体在某一帧探测等。</p>
<h3 id="MeshRender组件"><a href="#MeshRender组件" class="headerlink" title="MeshRender组件"></a>MeshRender组件</h3><ul>
<li>sharedMaterial：公共的材质，修改的是材质源文件；</li>
<li>material：该对象自己的材质。</li>
</ul>
<h3 id="CharacterController"><a href="#CharacterController" class="headerlink" title="CharacterController"></a>CharacterController</h3><p>继承自Collider，同时具有Rigidbody的一些属性，可以轻松设置角色的碰撞体、物理计算，使用CharacterController.Move。</p>
<h3 id="光源类型"><a href="#光源类型" class="headerlink" title="光源类型"></a>光源类型</h3><ul>
<li>Point：向四面八方发射光线；</li>
<li>Direction：平行光；</li>
<li>Spot：锥形聚光灯；</li>
</ul>
<h3 id="向量计算"><a href="#向量计算" class="headerlink" title="向量计算"></a>向量计算</h3><p>叉乘、点乘、Normalized、Project。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="level-of-detail"><a href="#level-of-detail" class="headerlink" title="level of detail"></a>level of detail</h3><p>细节表现级别，根据距离动态变化，远离的时候丢失细节不影响表现效果，可以减少性能开销。</p>
<h3 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h3><p>对纹理进行了lod处理，原理是当纹理分辨率大于模型表面时，查询一个纹理值可能对应多个像素点，可以采用Mipmap对纹理区域进行平均，缩小纹理分辨率，既不会浪费多余的像素，也不会造成视觉上的错误效果。</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul>
<li>托管堆泄露：不安全代码块中申请后忘记释放。</li>
<li>资源内存泄漏：申请资源后忘记释放。</li>
<li>无效的堆内存：例如多此创建了字符串，导致内存碎片化。</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类只有一个实例，提供能全局访问该实例的方法。类内部创建自己的静态实例，然后写一个静态方法返回该实例。</p>
<p>不会因为多次创建对象而导致冗余的变量副本，例如管理器脚本可以使用单例模式。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>是一种行为设计模式，允许你定义一种订阅通知机制。分为下面几个角色：</p>
<ul>
<li>发布者：事件发生后向订阅的对象发送消息。具体为一个委托或者事件。</li>
<li>观察者：监听该消息，发生事件时更新自己。将更新自己的方法添加到发布者的委托和事件中。</li>
</ul>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>Model-View-Controller，Model封装对底层数据的操作，View根据数据情况控制界面显示，Controller处理逻辑业务和交互，调用数据和视图更改的接口。</p>
<p><img src="/2023/10/18/unityInterview/2.png" alt></p>
<h2 id="简历相关问题"><a href="#简历相关问题" class="headerlink" title="简历相关问题"></a>简历相关问题</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>面试官你好，我目前是本科大四的在校生，拟录取到软件学院，联系了梁老师想进入游戏开发的项目，明年9月份入学。我自己从今年四月份开始接触了游戏开发，用了四个月左右的事件学习Unity和Unity Shader，更早之前主要学的是图形学，了解基本的图形学原理。Unity这块lua和热更新还有网络编程暂时没有学习过，主要是写游戏逻辑做过自己的简单游戏demo，就是我简历里写的那个；Unity Shader是学过一些基本的图形学案例，了解语法。目前规划是继续学习，</p>
<h3 id="项目中数据存储是怎么使用的"><a href="#项目中数据存储是怎么使用的" class="headerlink" title="项目中数据存储是怎么使用的"></a>项目中数据存储是怎么使用的</h3><p>EXCEL转JSON文件的脚本，然后JSON的序列化和反序列化来持久化存储，主要是怪物的属性，任务状态，还有背包信息用了这个存储，暂时没有太多要配置的数据。</p>
<h3 id="你用了两种设计模式介绍一下"><a href="#你用了两种设计模式介绍一下" class="headerlink" title="你用了两种设计模式介绍一下"></a>你用了两种设计模式介绍一下</h3><p>观察者模式和单例模式，单例模式用在UI的管理器上面，用一个UI管理器保存了对其它UI的引用，方便获取并修改；观察者模式用在更新UI上面，发布者是角色和敌人的Controller，写了一个委托订阅者是UI管理器，血量改变时让管理器更新血条显示。攻击检测应该没用，攻击检测目前是直接拿过来调用，写的时候还没学到。</p>
<p>三层架构MVC，用来同步UI，Model负责数据更改，项目中其实就是json存储，View就是UI的管理器，提供更新UI的接口，剩下的几乎都是Controller，处理游戏逻辑。 </p>
<h3 id="介绍一下你实现的系统"><a href="#介绍一下你实现的系统" class="headerlink" title="介绍一下你实现的系统"></a>介绍一下你实现的系统</h3><ul>
<li>战斗：核心系统，本来想做成ACT，不过现在完成度还不够，做了3C(Character、Camera、Controll)，角色做了两种武器的各一套普通攻击，可以循环，然后有翻滚和奔跑，以及不同方向的受击。攻击检测使用的是动画事件，设置一个攻击区域检测在动画的某一帧是否有敌人，打到了就播放音效，调用敌人的受击接口，敌人的受击接口也会调UI管理器更新血条，同时播放受击动画和音效。怪物写了一个简单的AI，锁定玩家后根据距离行动，靠近就释放技能（对象池的计时器）或者普攻，远离了靠近玩家，距离适中就左右随机移动。</li>
<li>对话：txt存对话数据，协程让字符逐个显示填充到Text组件中，用一个变量标志当前迭代器方法是否执行完成，按下对话按键的时候开启协程，当角色远离了NPC或者播放完一句话后协程终止。</li>
<li>任务：EXCEL记录当前任务状态，根据任务状态来显示对话文字，UI还没制作。</li>
<li>副本：就是场景切换，走到一个位置后用LoadScene切换，不是异步加载。</li>
<li>摄像机：带碰撞的摄像机，原理是用输入系统获取鼠标的移动插值，左右移动就让相机沿着圆形轨道移动并旋转指向角色某个身体部位，上下移动也一样。碰撞检测从角色往摄像机位置发射一条长度为两者间距离的射线，如果射线碰到了地形，就将距离设置为从出发点到相交点距离的0.9倍，否则让相机保持距离。</li>
<li>背包系统：用Panel管理，将一个物品的UI显示格子创建成Prefab，Instantiate实例化添加到Panel的Grid中自动排列即可，json存储实现持久化。</li>
</ul>
<h3 id="现代渲染流水线（光栅化为例）"><a href="#现代渲染流水线（光栅化为例）" class="headerlink" title="现代渲染流水线（光栅化为例）"></a>现代渲染流水线（光栅化为例）</h3><ul>
<li><p>CPU阶段（应用阶段）</p>
<ul>
<li>加载数据到显存中；</li>
<li>设置渲染状态；</li>
<li>DrawCall调用；</li>
</ul>
</li>
<li><p>GPU阶段</p>
<ul>
<li>顶点数据传入</li>
<li>几何阶段：顶点着色器、几何着色器、裁剪、屏幕映射；</li>
<li>光栅化阶段：三角形组织，片元着色器，逐片元计算，得到屏幕像素。</li>
</ul>
</li>
</ul>
<h3 id="光线追踪和路径追踪"><a href="#光线追踪和路径追踪" class="headerlink" title="光线追踪和路径追踪"></a>光线追踪和路径追踪</h3><p>以Whited-style光线追踪为例，从摄像机发射一束光线，打到物体上进行反射，如果能打到光源上，那么这个点就是可见的；如果没有到达光源，那么这个点不可见。</p>
<p>路径追踪可以看作优化的光线追踪，古典光线追踪仅仅反射一次，虽然解决了光栅化没有阴影的问题，但是光线只会在光滑表面上反射，忽略了漫反射，丢失了间接光照的细节。路径追踪发出很多条光线，通过渲染方程计算反射和折射光，反射光不再向一个方向反射，而是模拟真实物理情况，充分考虑了间接光照。</p>
<h3 id="遇到过什么问题？"><a href="#遇到过什么问题？" class="headerlink" title="遇到过什么问题？"></a>遇到过什么问题？</h3><ul>
<li>攻击输入：直接使用Trigger有问题，Animation系统的Trigger要求触发一次之后重置，但是这种游戏需要一直点鼠标，所以Trigger没等重置就触发了，这种情况需要对攻击输入进行限制，当角色攻击动画没结束时输入无效，否则会立即进入下一次攻击；同时要在两个时间重置Trigger，一个是Animation的OnStateEnter中，需要继承StateMachineBehaviour，一个是点击后重置或者让状态机不接受。</li>
<li>攻击检测：直接使用碰撞检测失效，没有勾选continuous Dynamic；后面用动画事件检测的。</li>
</ul>
<h3 id="举例说明UI怎么实现的"><a href="#举例说明UI怎么实现的" class="headerlink" title="举例说明UI怎么实现的"></a>举例说明UI怎么实现的</h3><ul>
<li>对话框：添加一个Panle，选一个背景图片，然后加一个文本框组件作为子对象，加一个Image作为人物头像展示即可。更新UI就只需要更新头像图片和文本内容。</li>
</ul>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><h3 id="寻路算法"><a href="#寻路算法" class="headerlink" title="寻路算法"></a>寻路算法</h3><p>广度优先、Dijkastra、启发式方法、A star算法。</p>
<h2 id="Lua和热更新"><a href="#Lua和热更新" class="headerlink" title="Lua和热更新"></a>Lua和热更新</h2>]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Engine</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer架构解析</title>
    <url>/2024/10/17/transformer/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Transformer在现在人工智能领域几乎是很多任务的backbone，不过网上很多解析都不够小白，分析太多，本文将详细解读Transformer的架构和Transformer的代码，遵循是什么，为什么来介绍，分析放在最后。</p>
<span id="more"></span>
<h1 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h1><p><img src="/2024/10/17/transformer/workSpace\ANKIIMA.github.io\source\_posts\transformer\1729147994777.jpg" alt></p>
<p>现在从下往上，从左到右我们分部介绍其中的细节。</p>
<h2 id="Inputs"><a href="#Inputs" class="headerlink" title="Inputs"></a>Inputs</h2><p><img src="/2024/10/17/transformer/workSpace\ANKIIMA.github.io\source\_posts\transformer\1729153056118.jpg" alt></p>
<p>在大多情况下，作为NLP任务，假设模型的输入是一串英文文本（texts），它由很多词（words）和标点（punctuations）组成。我们把每个词和标点看作一个单位，为了输入模型，目前的相关工作中有各种方法，如word2vec，one-hot编码等，将它们转换为一个一维的嵌入向量（Embeddings）。那么假设texts中有n个words（包括标点），在生成词嵌入的方法中我们规定嵌入向量的长度为k，就生成一个n*k的矩阵，每行都是一个词的特征向量（features），这其实就是图中的inputs和embeddings。</p>
<h2 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h2><p><img src="/2024/10/17/transformer/workSpace\ANKIIMA.github.io\source\_posts\transformer\1729153115341.jpg" alt></p>
<p>位置编码就是将每个词在文本序列中的位置进行编码得到的向量，将它作为额外的特征拼接到每个单词向量的后面。可以有不同的计算方式，Transformer中使用下面的式子：</p>
<p><img src="/2024/10/17/transformer/workSpace\ANKIIMA.github.io\source\_posts\transformer\1729151622585.jpg" alt></p>
<p>位置编码有很多不同的方式，发展到这里已经比较成熟，公式中pos是word在文本中的位置，i指PE中第i个元素，d_model是词向量的维度。实际上这种编码就是正余弦函数在不断震荡。</p>
<p>之所以加入位置编码是因为，得到每个词的特征向量后，我们实际上是做了一个类似字典的工作，然而在模型中我们如果仅仅将代表整个文本的特征矩阵输入进行乘法，实际上代表words的不同行都在同时进行计算。因此不同于RNN，Transformer没有将输入作为一个序列而是作为一个整体，也就确实了每个words在文本序列中本来的位置信息。</p>
<p>除了这个原因外，Transformer中还会进行自注意力的计算，如果不加上位置特征，那么不同位置的同个word会查询出相同的value，后面我们会再讲到。</p>
<p>到这里我们计算了完整的输入特征矩阵，它包括原本的词嵌入和位置编码。</p>
<h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><p><img src="/2024/10/17/transformer/workSpace\ANKIIMA.github.io\source\_posts\transformer\1729153091134.jpg" alt></p>
<p>这是Transformer非常著名的部分，多头注意力由多个自注意力机制组成，上面Add表示残差连接，Norm表示归一化。我们先看注意力机制。</p>
<p><img src="/2024/10/17/transformer/workSpace\ANKIIMA.github.io\source\_posts\transformer\1729153249741.jpg" alt></p>
<h3 id="自注意力机制"><a href="#自注意力机制" class="headerlink" title="自注意力机制"></a>自注意力机制</h3><p>图中左边是自注意力的计算方式，其实就是用三个公用的可训练的参数矩阵W_Q，W_K，W_V，分别乘以输入的特征矩阵X，就为每个词都得到Q(query)，K(key)，V(value)三个矩阵（图是偷的）：</p>
<p><img src="/2024/10/17/transformer/workSpace\ANKIIMA.github.io\source\_posts\transformer\1729154044431.jpg" alt></p>
<p>同样每一行代表一个单词，这三个矩阵随着训练会包含所有位置上单词的信息，为了方便理解我们认为Q提炼了单词会对其他哪些单词感兴趣，K提炼了单词哪些部分可能会被其他哪些单词注意，V尽可能保留单词意义，提供健全的查询内容。</p>
<p><img src="/2024/10/17/transformer/workSpace\ANKIIMA.github.io\source\_posts\transformer\1729154985769.jpg" alt></p>
<p>如图中所示使用该公式计算注意力矩阵，该矩阵Z尺寸和Q，K，V相同。</p>
<h3 id="多头注意力机制"><a href="#多头注意力机制" class="headerlink" title="多头注意力机制"></a>多头注意力机制</h3><p>多头注意力就是多个自注意力的组合，前面图中h表示注意力头的数量，按照自注意力方式计算h个自注意力矩阵Z，然后直接按行拼接，再用一个线性变换矩阵将矩阵变换为和输入X一致的尺寸。</p>
<p><img src="/2024/10/17/transformer/workSpace\ANKIIMA.github.io\source\_posts\transformer\1729156175267.jpg" alt></p>
<p>此外，在这里还有一个Mask机制，分别是padding mask和sequence mask，分别在encoder和decoder中使用，前者对空闲的输入位置补负无穷，以保证这些位置的预测概率为0，后者对序列中第i个位置之后的输入元素补0以保证encoder不会使用未来的信息进行预测，以模拟类似RNN的输入方式。</p>
<h2 id="Add-amp-Norm"><a href="#Add-amp-Norm" class="headerlink" title="Add &amp; Norm"></a>Add &amp; Norm</h2><h3 id="残差连接"><a href="#残差连接" class="headerlink" title="残差连接"></a>残差连接</h3><p>是一种提升网络训练性能的方法，将输入X加到输出中，就可以让网络仅关注该层上差异的部分。</p>
<h3 id="LayerNormalization"><a href="#LayerNormalization" class="headerlink" title="LayerNormalization"></a>LayerNormalization</h3><p>把数据变回正态分布的计算方法，对输出的矩阵进行了变换。</p>
<h2 id="Feed-Forward"><a href="#Feed-Forward" class="headerlink" title="Feed Forward"></a>Feed Forward</h2><p>两层的MLP，第一层用ReLU，第二层不用激活函数。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Deep Learning</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>Transfoermer</tag>
      </tags>
  </entry>
</search>
